!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACK_TO_SENDER	reliable/relrecv.hpp	/^      ACK_TO_SENDER = (1<<0), \/\/ ACK for this packet should be returned to sender$/;"	e	enum:openvpn::ReliableRecvTemplate::__anon76
ACK_V1	ssl/proto.hpp	/^      ACK_V1 =                       5,   \/\/ acknowledgement for packets received$/;"	e	enum:openvpn::ProtoContext::__anon80
ACTIVATE_PRIMARY	crypto/cryptodc.hpp	/^      ACTIVATE_PRIMARY,$/;"	e	enum:openvpn::CryptoDCInstance::RekeyType
ACTIVE	ssl/proto.hpp	/^      ACTIVE=10,$/;"	e	enum:openvpn::ProtoContext::__anon80
ADAPTER	tun/win/tunutil.hpp	/^	const char ADAPTER[] = ADAPTER_KEY; \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::TunWin::Util::__anon94
ADDR_DEFINED	tun/mac/gwv4.hpp	/^      ADDR_DEFINED     = (1<<0), \/* set if gateway.addr defined *\/$/;"	e	enum:openvpn::MacGatewayInfoV4::__anon92
ADD_ROUTES	client/clievent.hpp	/^      ADD_ROUTES,$/;"	e	enum:openvpn::ClientEvent::Type
AEAD	crypto/crypto_aead.hpp	/^  namespace AEAD {$/;"	n	namespace:openvpn
AEAD	crypto/cryptoalgs.hpp	/^      AEAD,$/;"	e	enum:openvpn::CryptoAlgs::Mode
AES_128_CBC	crypto/cryptoalgs.hpp	/^      AES_128_CBC,$/;"	e	enum:openvpn::CryptoAlgs::Type
AES_128_GCM	crypto/cryptoalgs.hpp	/^      AES_128_GCM,$/;"	e	enum:openvpn::CryptoAlgs::Type
AES_192_CBC	crypto/cryptoalgs.hpp	/^      AES_192_CBC,$/;"	e	enum:openvpn::CryptoAlgs::Type
AES_192_GCM	crypto/cryptoalgs.hpp	/^      AES_192_GCM,$/;"	e	enum:openvpn::CryptoAlgs::Type
AES_256_CBC	crypto/cryptoalgs.hpp	/^      AES_256_CBC,$/;"	e	enum:openvpn::CryptoAlgs::Type
AES_256_GCM	crypto/cryptoalgs.hpp	/^      AES_256_GCM,$/;"	e	enum:openvpn::CryptoAlgs::Type
ALLOW_EMPTY	client/remotelist.hpp	/^      ALLOW_EMPTY=1<<3,$/;"	e	enum:openvpn::RemoteList::__anon17
ANY	compress/compress.hpp	/^      ANY,        \/\/ placeholder for any method on client, before server assigns it$/;"	e	enum:openvpn::CompressContext::Type
ANY_LZO	compress/compress.hpp	/^      ANY_LZO,    \/\/ placeholder for LZO or LZO_STUB methods on client, before server assigns it$/;"	e	enum:openvpn::CompressContext::Type
APP_MSG_MAX	ssl/proto.hpp	/^    static constexpr size_t APP_MSG_MAX = 65536;$/;"	m	class:openvpn::ProtoContext
ARRAY	buffer/buffer.hpp	/^      ARRAY = (1<<3),           \/\/ if enabled, use as array$/;"	e	enum:openvpn::BufferAllocatedType::__anon14
ASIOSignals	common/asiosignal.hpp	/^    ASIOSignals(asio::io_context& io_context)$/;"	f	class:openvpn::ASIOSignals
ASIOSignals	common/asiosignal.hpp	/^  class ASIOSignals : public RC<thread_safe_refcount>$/;"	c	namespace:openvpn
ASSIGN_IP	client/clievent.hpp	/^      ASSIGN_IP,$/;"	e	enum:openvpn::ClientEvent::Type
AUTH_FAILED	client/clievent.hpp	/^      AUTH_FAILED,$/;"	e	enum:openvpn::ClientEvent::Type
AUTH_FAILED	error/error.hpp	/^      AUTH_FAILED,         \/\/ general authentication failure$/;"	e	enum:openvpn::Error::Type
AUTH_FAILED	server/servhalt.hpp	/^      AUTH_FAILED,      \/\/ auth fail, don't preserve session token$/;"	e	enum:openvpn::HaltRestart::Type
AUTH_TAG_LEN	openssl/crypto/ciphergcm.hpp	/^	AUTH_TAG_LEN = 16,$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContextGCM::__anon58
AUTH_TAG_LEN	polarssl/crypto/ciphergcm.hpp	/^	AUTH_TAG_LEN = 16,$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContextGCM::__anon70
Action	common/action.hpp	/^  struct Action : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
ActionCreate	tun/win/nrpt.hpp	/^	ActionCreate(const std::vector<std::string>& names_arg,$/;"	f	class:openvpn::TunWin::NRPT::ActionCreate
ActionCreate	tun/win/nrpt.hpp	/^      class ActionCreate : public Action$/;"	c	class:openvpn::TunWin::NRPT
ActionDelete	tun/win/nrpt.hpp	/^      class ActionDelete : public Action$/;"	c	class:openvpn::TunWin::NRPT
ActionDeleteAllRoutesOnInterface	tun/win/tunutil.hpp	/^	ActionDeleteAllRoutesOnInterface(const DWORD iface_index_arg)$/;"	f	class:openvpn::TunWin::Util::ActionDeleteAllRoutesOnInterface
ActionDeleteAllRoutesOnInterface	tun/win/tunutil.hpp	/^      class ActionDeleteAllRoutesOnInterface : public Action$/;"	c	namespace:openvpn::TunWin::Util
ActionEnableDHCP	tun/win/tunutil.hpp	/^	ActionEnableDHCP(const TapNameGuidPair& tap)$/;"	f	class:openvpn::TunWin::Util::ActionEnableDHCP
ActionEnableDHCP	tun/win/tunutil.hpp	/^      class ActionEnableDHCP : public WinCmd$/;"	c	namespace:openvpn::TunWin::Util
ActionList	common/action.hpp	/^    ActionList()$/;"	f	class:openvpn::ActionList
ActionList	common/action.hpp	/^  class ActionList : public std::vector<Action::Ptr>, public DestructorBase$/;"	c	namespace:openvpn
ActionListFactory	common/action.hpp	/^  struct ActionListFactory : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
ActionListReversed	common/action.hpp	/^    ActionListReversed()$/;"	f	struct:openvpn::ActionListReversed
ActionListReversed	common/action.hpp	/^  struct ActionListReversed : public ActionList$/;"	s	namespace:openvpn
ActionSetAdapterDomainSuffix	tun/win/tunutil.hpp	/^	ActionSetAdapterDomainSuffix(const std::string& search_domain_arg,$/;"	f	class:openvpn::TunWin::Util::ActionSetAdapterDomainSuffix
ActionSetAdapterDomainSuffix	tun/win/tunutil.hpp	/^      class ActionSetAdapterDomainSuffix : public Action$/;"	c	namespace:openvpn::TunWin::Util
ActionThread	common/actionthread.hpp	/^    ActionThread(asio::io_context& io_context_arg,$/;"	f	class:openvpn::ActionThread
ActionThread	common/actionthread.hpp	/^  class ActionThread : public RC<thread_safe_refcount>$/;"	c	namespace:openvpn
ActionWFP	tun/win/wfp.hpp	/^      ActionWFP(const std::wstring& openvpn_app_path_arg,$/;"	f	class:openvpn::TunWin::ActionWFP
ActionWFP	tun/win/wfp.hpp	/^    class ActionWFP : public Action$/;"	c	namespace:openvpn::TunWin
AddRoutes	client/clievent.hpp	/^      AddRoutes() : Base(ADD_ROUTES) {}$/;"	f	struct:openvpn::ClientEvent::AddRoutes
AddRoutes	client/clievent.hpp	/^    struct AddRoutes : public Base$/;"	s	namespace:openvpn::ClientEvent
Addr	addr/ip.hpp	/^      Addr()$/;"	f	class:openvpn::IP::Addr
Addr	addr/ip.hpp	/^      Addr(const Addr& other, const char *title = nullptr, Version required_version = UNSPEC)$/;"	f	class:openvpn::IP::Addr
Addr	addr/ip.hpp	/^      Addr(const std::string& ipstr, const char *title = nullptr, Version required_version = UNSPEC)$/;"	f	class:openvpn::IP::Addr
Addr	addr/ip.hpp	/^      Addr(const std::string& ipstr, const std::string& title, Version required_version = UNSPEC)$/;"	f	class:openvpn::IP::Addr
Addr	addr/ip.hpp	/^    class Addr$/;"	c	namespace:openvpn::IP
Addr	addr/ipv4.hpp	/^    class Addr \/\/ NOTE: must be union-legal, so default constructor does not initialize$/;"	c	namespace:openvpn::IPv4
Addr	addr/ipv6.hpp	/^    class Addr \/\/ NOTE: must be union-legal, so default constructor does not initialize$/;"	c	namespace:openvpn::IPv6
Addr	addr/route.hpp	/^      typedef ADDR Addr;$/;"	t	struct:openvpn::IP::RouteType
AddrList	addr/addrlist.hpp	/^    class AddrList : public std::vector<IP::Addr>, public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::IP
AddrMaskPair	addr/addrpair.hpp	/^    struct AddrMaskPair$/;"	s	namespace:openvpn::IP
AddrPort	server/peeraddr.hpp	/^    AddrPort() : port(0) {}$/;"	f	struct:openvpn::AddrPort
AddrPort	server/peeraddr.hpp	/^  struct AddrPort$/;"	s	namespace:openvpn
Alg	crypto/cryptoalgs.hpp	/^      constexpr Alg(const char *name,$/;"	f	class:openvpn::CryptoAlgs::Alg
Alg	crypto/cryptoalgs.hpp	/^    class Alg$/;"	c	namespace:openvpn::CryptoAlgs
AlgFlags	crypto/cryptoalgs.hpp	/^    enum AlgFlags {       \/\/ bits below must start after Mode bits$/;"	g	namespace:openvpn::CryptoAlgs
AllowDefault	server/listenlist.hpp	/^	AllowDefault,$/;"	e	enum:openvpn::Listen::List::LoadMode
AllowEmpty	server/listenlist.hpp	/^	AllowEmpty$/;"	e	enum:openvpn::Listen::List::LoadMode
AllowSuffix	transport/protocol.hpp	/^    enum AllowSuffix {$/;"	g	class:openvpn::Protocol
AltProxy	transport/altproxy.hpp	/^  struct AltProxy : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
AppleCrypto	applecrypto/crypto/cipher.hpp	/^  namespace AppleCrypto {$/;"	n	namespace:openvpn
AppleCrypto	applecrypto/crypto/digest.hpp	/^  namespace AppleCrypto {$/;"	n	namespace:openvpn
AppleCrypto	applecrypto/crypto/hmac.hpp	/^  namespace AppleCrypto {$/;"	n	namespace:openvpn
AppleCryptoAPI	applecrypto/crypto/api.hpp	/^  struct AppleCryptoAPI {$/;"	s	namespace:openvpn
AppleRandom	applecrypto/util/rand.hpp	/^    AppleRandom(const bool prng)$/;"	f	class:openvpn::AppleRandom
AppleRandom	applecrypto/util/rand.hpp	/^  class AppleRandom : public RandomAPI$/;"	c	namespace:openvpn
AppleSSLContext	applecrypto/ssl/sslctx.hpp	/^    AppleSSLContext(Config* config)$/;"	f	class:openvpn::AppleSSLContext
AppleSSLContext	applecrypto/ssl/sslctx.hpp	/^  class AppleSSLContext : public SSLFactoryAPI$/;"	c	namespace:openvpn
AppleSSLContextPtr	applecrypto/ssl/sslctx.hpp	/^  typedef AppleSSLContext::Ptr AppleSSLContextPtr;$/;"	t	namespace:openvpn
AppleVersion	apple/ver.hpp	/^    AppleVersion()$/;"	f	class:openvpn::AppleVersion
AppleVersion	apple/ver.hpp	/^  class AppleVersion$/;"	c	namespace:openvpn
Argv	common/argv.hpp	/^    Argv(const size_t capacity=16)$/;"	f	class:openvpn::Argv
Argv	common/argv.hpp	/^  class Argv : public std::vector<std::string>$/;"	c	namespace:openvpn
ArgvWrapper	common/argv.hpp	/^    explicit ArgvWrapper(const std::vector<std::string>& argv)$/;"	f	class:openvpn::ArgvWrapper
ArgvWrapper	common/argv.hpp	/^  class ArgvWrapper$/;"	c	namespace:openvpn
AsioBoundSocket	common/asioboundsock.hpp	/^  namespace AsioBoundSocket {$/;"	n	namespace:openvpn
AsioClock	time/asiotimer.hpp	/^  struct AsioClock$/;"	s	namespace:openvpn
AsioConstBufferSeq2	buffer/asiobuf.hpp	/^    AsioConstBufferSeq2(const Buffer& b1, const Buffer& b2)$/;"	f	class:openvpn::AsioConstBufferSeq2
AsioConstBufferSeq2	buffer/asiobuf.hpp	/^  class AsioConstBufferSeq2$/;"	c	namespace:openvpn
AsioContextStore	common/asiocontext.hpp	/^  class AsioContextStore$/;"	c	namespace:openvpn
AsioEndpoint	transport/udplink.hpp	/^    typedef asio::ip::udp::endpoint AsioEndpoint;$/;"	t	namespace:openvpn::UDPTransport
AsioPolySock	common/asiopolysock.hpp	/^  namespace AsioPolySock {$/;"	n	namespace:openvpn
AsioStopScope	common/asiostop.hpp	/^    AsioStopScope(asio::io_context& io_context,$/;"	f	class:openvpn::AsioStopScope
AsioStopScope	common/asiostop.hpp	/^  class AsioStopScope : public Stop::Scope$/;"	c	namespace:openvpn
AsioTimer	time/asiotimer.hpp	/^    AsioTimer(asio::io_context& io_context)$/;"	f	class:openvpn::AsioTimer
AsioTimer	time/asiotimer.hpp	/^  class AsioTimer : public asio::basic_waitable_timer<AsioClock>$/;"	c	namespace:openvpn
AssignIP	client/clievent.hpp	/^      AssignIP() : Base(ASSIGN_IP) {}$/;"	f	struct:openvpn::ClientEvent::AssignIP
AssignIP	client/clievent.hpp	/^    struct AssignIP : public Base$/;"	s	namespace:openvpn::ClientEvent
AuthCert	auth/authcert.hpp	/^      AuthCert()$/;"	f	struct:openvpn::AuthCert
AuthCert	auth/authcert.hpp	/^    struct AuthCert : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
AuthCreds	auth/authcreds.hpp	/^      AuthCreds(std::string&& username_arg,$/;"	f	class:openvpn::AuthCreds
AuthCreds	auth/authcreds.hpp	/^    class AuthCreds : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
AuthFailed	client/clievent.hpp	/^      AuthFailed(std::string reason) : ReasonBase(AUTH_FAILED, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::AuthFailed
AuthFailed	client/clievent.hpp	/^    struct AuthFailed : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
AutoReset	common/autoreset.hpp	/^    AutoReset(T& obj)$/;"	f	class:openvpn::AutoReset
AutoReset	common/autoreset.hpp	/^  class AutoReset$/;"	c	namespace:openvpn
BAD_CERT_TYPE	auth/authcert.hpp	/^	  BAD_CERT_TYPE,$/;"	e	enum:openvpn::AuthCert::Fail::Type
BAD_SRC_ADDR	error/error.hpp	/^      BAD_SRC_ADDR,        \/\/ packet from unknown source address$/;"	e	enum:openvpn::Error::Type
BF_CBC	crypto/cryptoalgs.hpp	/^      BF_CBC,$/;"	e	enum:openvpn::CryptoAlgs::Type
BIO_TYPE_MEMQ	openssl/bio/bio_memq_dgram.hpp	/^	BIO_TYPE_MEMQ = (94|BIO_TYPE_SOURCE_SINK) \/\/ make sure type 94 doesn't collide with anything in bio.h$/;"	e	enum:openvpn::bmq_dgram::bio_memq_internal::__anon53
BIO_TYPE_MEMQ	openssl/bio/bio_memq_stream.hpp	/^	BIO_TYPE_MEMQ = (95|BIO_TYPE_SOURCE_SINK) \/\/ make sure type 95 doesn't collide with anything in bio.h$/;"	e	enum:openvpn::bmq_stream::bio_memq_internal::__anon54
BIO_s_memq	openssl/bio/bio_memq_dgram.hpp	/^    inline BIO_METHOD *BIO_s_memq(void)$/;"	f	namespace:openvpn::bmq_dgram
BIO_s_memq	openssl/bio/bio_memq_stream.hpp	/^    inline BIO_METHOD *BIO_s_memq(void)$/;"	f	namespace:openvpn::bmq_stream
BOOTPC_PORT	ip/dhcp.hpp	/^      BOOTPC_PORT = 68,$/;"	e	enum:openvpn::DHCP::__anon46
BOOTPS_PORT	ip/dhcp.hpp	/^      BOOTPS_PORT = 67,$/;"	e	enum:openvpn::DHCP::__anon46
BOOTREPLY	ip/dhcp.hpp	/^      BOOTREPLY   = 2,$/;"	e	enum:openvpn::DHCP::__anon46
BOOTREQUEST	ip/dhcp.hpp	/^      BOOTREQUEST = 1,$/;"	e	enum:openvpn::DHCP::__anon46
BORROW	applecrypto/cf/cf.hpp	/^      BORROW$/;"	e	enum:openvpn::CF::Own
BUFFER_ERROR	error/error.hpp	/^      BUFFER_ERROR,        \/\/ exception thrown in Buffer methods$/;"	e	enum:openvpn::Error::Type
BUF_FLAGS	buffer/safestr.hpp	/^    static constexpr unsigned int BUF_FLAGS = BufferAllocated::DESTRUCT_ZERO|BufferAllocated::GROW;$/;"	m	class:openvpn::SafeString
BYTES_IN	log/sessionstats.hpp	/^      BYTES_IN = 0,        \/\/ network bytes in$/;"	e	enum:openvpn::SessionStats::Stats
BYTES_OUT	log/sessionstats.hpp	/^      BYTES_OUT,           \/\/ network bytes out$/;"	e	enum:openvpn::SessionStats::Stats
BY_MINUTE	log/logperiod.hpp	/^      BY_MINUTE,$/;"	e	enum:openvpn::LogPeriod::Period
BadRequest	http/status.hpp	/^	BadRequest=400,$/;"	e	enum:openvpn::HTTP::Status::__anon45
Base	addr/route.hpp	/^      typedef std::vector< RouteType<ADDR> > Base;$/;"	t	struct:openvpn::IP::RouteTypeList
Base	client/clievent.hpp	/^      Base(Type id) : id_(id) {}$/;"	f	class:openvpn::ClientEvent::Base
Base	client/clievent.hpp	/^    class Base : public RC<thread_safe_refcount>$/;"	c	namespace:openvpn::ClientEvent
Base	client/cliproto.hpp	/^      typedef ProtoContext Base;$/;"	t	class:openvpn::ClientProto::Session
Base	common/asiopolysock.hpp	/^      Base(const size_t index)$/;"	f	class:openvpn::AsioPolySock::Base
Base	common/asiopolysock.hpp	/^    class Base : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::AsioPolySock
Base	crypto/crypto_aead.hpp	/^      typedef CryptoDCInstance Base;$/;"	t	class:openvpn::AEAD::Crypto
Base	crypto/crypto_chm.hpp	/^    typedef CryptoDCInstance Base;$/;"	t	class:openvpn::CryptoCHM
Base	server/servproto.hpp	/^    typedef ProtoContext Base;$/;"	t	class:openvpn::ServerProto
Base	ssl/proto.hpp	/^      typedef ProtoStackBase<Packet, KeyContext> Base;$/;"	t	class:openvpn::ProtoContext::KeyContext
Base	tun/builder/client.hpp	/^      typedef TunIO<ReadHandler, PacketFrom, asio::posix::stream_descriptor> Base;$/;"	t	class:openvpn::TunBuilderClient::Tun
Base	tun/builder/setup.hpp	/^    struct Base : public DestructorBase$/;"	s	namespace:openvpn::TunBuilderSetup
Base	tun/linux/tun.hpp	/^      typedef TunIO<ReadHandler, PacketFrom, asio::posix::stream_descriptor> Base;$/;"	t	class:openvpn::TunLinux::Tun
Base	tun/mac/client/tuncli.hpp	/^      typedef TunIO<ReadHandler, PacketFrom, TunWrapAsioStream<TunPersist>  > Base;$/;"	t	class:openvpn::TunMac::Tun
Base	tun/win/client/tuncli.hpp	/^      typedef TunIO<ReadHandler, PacketFrom, TunWrapAsioStream<TunPersist>  > Base;$/;"	t	class:openvpn::TunWin::Tun
Base64	common/base64.hpp	/^    Base64(const char *altmap = nullptr)$/;"	f	class:openvpn::Base64
Base64	common/base64.hpp	/^  class Base64 {$/;"	c	namespace:openvpn
BufHex	buffer/bufhex.hpp	/^  namespace BufHex {$/;"	n	namespace:openvpn
Buffer	buffer/buffer.hpp	/^  typedef BufferType<unsigned char> Buffer;$/;"	t	namespace:openvpn
BufferAllocated	buffer/buffer.hpp	/^  typedef BufferAllocatedType<unsigned char> BufferAllocated;$/;"	t	namespace:openvpn
BufferAllocatedType	buffer/buffer.hpp	/^    BufferAllocatedType()$/;"	f	class:openvpn::BufferAllocatedType
BufferAllocatedType	buffer/buffer.hpp	/^    BufferAllocatedType(const BufferAllocatedType& other)$/;"	f	class:openvpn::BufferAllocatedType
BufferAllocatedType	buffer/buffer.hpp	/^    BufferAllocatedType(const BufferType<OT>& other, const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
BufferAllocatedType	buffer/buffer.hpp	/^    BufferAllocatedType(const T* data, const size_t size, const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
BufferAllocatedType	buffer/buffer.hpp	/^    BufferAllocatedType(const size_t capacity, const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
BufferAllocatedType	buffer/buffer.hpp	/^  class BufferAllocatedType : public BufferType<T>, public RC<R>$/;"	c	namespace:openvpn
BufferCollection	buffer/buflist.hpp	/^  struct BufferCollection : public COLLECTION<BufferPtr>$/;"	s	namespace:openvpn
BufferComplete	buffer/bufcomplete.hpp	/^  class BufferComplete$/;"	c	namespace:openvpn
BufferComposed	buffer/bufcomposed.hpp	/^  class BufferComposed$/;"	c	namespace:openvpn
BufferException	buffer/buffer.hpp	/^    BufferException(Status status)$/;"	f	class:openvpn::BufferException
BufferException	buffer/buffer.hpp	/^  class BufferException : public std::exception$/;"	c	namespace:openvpn
BufferLimit	buffer/buflimit.hpp	/^    BufferLimit()$/;"	f	class:openvpn::BufferLimit
BufferLimit	buffer/buflimit.hpp	/^    BufferLimit(const T max_lines_arg,$/;"	f	class:openvpn::BufferLimit
BufferLimit	buffer/buflimit.hpp	/^  class BufferLimit$/;"	c	namespace:openvpn
BufferList	buffer/buflist.hpp	/^  typedef BufferCollection<std::list> BufferList;$/;"	t	namespace:openvpn
BufferPtr	buffer/buffer.hpp	/^  typedef RCPtr<BufferAllocated> BufferPtr;$/;"	t	namespace:openvpn
BufferStream	buffer/bufstream.hpp	/^    BufferStream(Buffer& buffer) : buf(buffer) {}$/;"	f	class:openvpn::BufferStream
BufferStream	buffer/bufstream.hpp	/^  class BufferStream : public std::streambuf$/;"	c	namespace:openvpn
BufferStreamOut	buffer/bufstream.hpp	/^    BufferStreamOut(Buffer& buffer)$/;"	f	class:openvpn::BufferStreamOut
BufferStreamOut	buffer/bufstream.hpp	/^  class BufferStreamOut : public std::ostream$/;"	c	namespace:openvpn
BufferType	buffer/buffer.hpp	/^    BufferType()$/;"	f	class:openvpn::BufferType
BufferType	buffer/buffer.hpp	/^    BufferType(T* data, const size_t offset, const size_t size, const size_t capacity)$/;"	f	class:openvpn::BufferType
BufferType	buffer/buffer.hpp	/^    BufferType(T* data, const size_t size, const bool filled)$/;"	f	class:openvpn::BufferType
BufferType	buffer/buffer.hpp	/^  class BufferType {$/;"	c	namespace:openvpn
BufferVector	buffer/buflist.hpp	/^  typedef BufferCollection<std::vector> BufferVector;$/;"	t	namespace:openvpn
C	pki/x509track.hpp	/^      C,$/;"	e	enum:openvpn::X509Track::Type
CBC_HMAC	crypto/cryptoalgs.hpp	/^      CBC_HMAC,$/;"	e	enum:openvpn::CryptoAlgs::Mode
CC_ERROR	error/error.hpp	/^      CC_ERROR,            \/\/ general control channel errors$/;"	e	enum:openvpn::Error::Type
CC_SHA224_CTX	applecrypto/crypto/digest.hpp	/^    typedef CC_SHA256_CTX CC_SHA224_CTX;$/;"	t	namespace:openvpn::AppleCrypto
CC_SHA384_CTX	applecrypto/crypto/digest.hpp	/^    typedef CC_SHA512_CTX CC_SHA384_CTX;$/;"	t	namespace:openvpn::AppleCrypto
CERT_VERIFY_FAIL	client/clievent.hpp	/^      CERT_VERIFY_FAIL,$/;"	e	enum:openvpn::ClientEvent::Type
CERT_VERIFY_FAIL	error/error.hpp	/^      CERT_VERIFY_FAIL,    \/\/ peer certificate verification failure$/;"	e	enum:openvpn::Error::Type
CF	apple/runloop.hpp	/^  namespace CF {$/;"	n	namespace:openvpn
CF	apple/scdynstore.hpp	/^  namespace CF {$/;"	n	namespace:openvpn
CF	applecrypto/cf/cf.hpp	/^  namespace CF$/;"	n	namespace:openvpn
CF	applecrypto/cf/cfhelper.hpp	/^  namespace CF {$/;"	n	namespace:openvpn
CF	applecrypto/cf/cfsec.hpp	/^  namespace CF {$/;"	n	namespace:openvpn
CF	applecrypto/cf/cftimer.hpp	/^  namespace CF {$/;"	n	namespace:openvpn
CF	applecrypto/util/reachable.hpp	/^  namespace CF {$/;"	n	namespace:openvpn
CFException	applecrypto/cf/error.hpp	/^    CFException(const std::string& text)$/;"	f	class:openvpn::CFException
CFException	applecrypto/cf/error.hpp	/^    CFException(const std::string& text, const OSStatus status)$/;"	f	class:openvpn::CFException
CFException	applecrypto/cf/error.hpp	/^  class CFException : public std::exception$/;"	c	namespace:openvpn
CHECKED_PTR_OF	openssl/pki/dh.hpp	/^#define CHECKED_PTR_OF(/;"	d
CHECKED_PTR_OF	openssl/pki/dh.hpp	/^#undef CHECKED_PTR_OF$/;"	d
CHOSEN_ONE	common/pthreadcond.hpp	/^      CHOSEN_ONE, \/\/ successful and chosen (only one thread is chosen)$/;"	e	enum:openvpn::PThreadBarrier::Status
CIPHER	crypto/static_key.hpp	/^      CIPHER = 0,$/;"	e	enum:openvpn::OpenVPNStaticKey::__anon42
CIPHER_DEFINED	crypto/cryptodc.hpp	/^      CIPHER_DEFINED=(1<<0),  \/\/ may call init_cipher method$/;"	e	enum:openvpn::CryptoDCInstance::__anon38
CIPH_CBC_MODE	applecrypto/crypto/cipher.hpp	/^	CIPH_CBC_MODE = 0$/;"	e	enum:openvpn::AppleCrypto::CipherContext::__anon8
CIPH_CBC_MODE	openssl/crypto/cipher.hpp	/^	CIPH_CBC_MODE = EVP_CIPH_CBC_MODE$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContext::__anon56
CIPH_CBC_MODE	polarssl/crypto/cipher.hpp	/^	CIPH_CBC_MODE = POLARSSL_MODE_CBC$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContext::__anon68
CLIENT	common/mode.hpp	/^      CLIENT,$/;"	e	enum:openvpn::Mode::Type
CLIENT	ssl/nscert.hpp	/^      CLIENT,$/;"	e	enum:openvpn::NSCert::Type
CLIENT_HALT	client/clievent.hpp	/^      CLIENT_HALT,$/;"	e	enum:openvpn::ClientEvent::Type
CLIENT_HALT	error/error.hpp	/^      CLIENT_HALT,         \/\/ HALT message from server received$/;"	e	enum:openvpn::Error::Type
CLIENT_RESTART	client/clievent.hpp	/^      CLIENT_RESTART,$/;"	e	enum:openvpn::ClientEvent::Type
CLIENT_RESTART	error/error.hpp	/^      CLIENT_RESTART,      \/\/ RESTART message from server received$/;"	e	enum:openvpn::Error::Type
CLIENT_SUFFIX	transport/protocol.hpp	/^      CLIENT_SUFFIX,$/;"	e	enum:openvpn::Protocol::AllowSuffix
CN	pki/x509track.hpp	/^      CN,$/;"	e	enum:openvpn::X509Track::Type
COMPONENT_ID	tun/win/tunutil.hpp	/^	const char COMPONENT_ID[] = OPENVPN_STRINGIZE(TAP_WIN_COMPONENT_ID); \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::TunWin::Util::__anon94
COMPRESS_ASYM	ssl/proto_context_options.hpp	/^      COMPRESS_ASYM$/;"	e	enum:openvpn::ProtoContextOptions::CompressionMode
COMPRESS_ERROR	error/error.hpp	/^      COMPRESS_ERROR,      \/\/ compress\/decompress errors on data channel$/;"	e	enum:openvpn::Error::Type
COMPRESS_NO	ssl/proto_context_options.hpp	/^      COMPRESS_NO,$/;"	e	enum:openvpn::ProtoContextOptions::CompressionMode
COMPRESS_V2_ESCAPE	compress/compress.hpp	/^      COMPRESS_V2_ESCAPE=0x50,$/;"	e	enum:openvpn::Compress::__anon31
COMPRESS_WORK	frame/frame.hpp	/^      COMPRESS_WORK,$/;"	e	enum:openvpn::Frame::__anon44
COMPRESS_YES	ssl/proto_context_options.hpp	/^      COMPRESS_YES,$/;"	e	enum:openvpn::ProtoContextOptions::CompressionMode
COMP_STUB	compress/compress.hpp	/^      COMP_STUB,  \/\/ generic compression stub$/;"	e	enum:openvpn::CompressContext::Type
COMP_STUBv2	compress/compress.hpp	/^      COMP_STUBv2,  \/\/ generic compression stub using v2 protocol$/;"	e	enum:openvpn::CompressContext::Type
CONNECTED	client/clievent.hpp	/^      CONNECTED,$/;"	e	enum:openvpn::ClientEvent::Type
CONNECTING	client/clievent.hpp	/^      CONNECTING,$/;"	e	enum:openvpn::ClientEvent::Type
CONNECTION_TIMEOUT	client/clievent.hpp	/^      CONNECTION_TIMEOUT,$/;"	e	enum:openvpn::ClientEvent::Type
CONNECTION_TIMEOUT	error/error.hpp	/^      CONNECTION_TIMEOUT,  \/\/ connection failed to establish within given time$/;"	e	enum:openvpn::Error::Type
CONN_BLOCK_OMIT_UNDEF	client/remotelist.hpp	/^      CONN_BLOCK_OMIT_UNDEF=1<<2,$/;"	e	enum:openvpn::RemoteList::__anon17
CONN_BLOCK_ONLY	client/remotelist.hpp	/^      CONN_BLOCK_ONLY=1<<1,$/;"	e	enum:openvpn::RemoteList::__anon17
CONSTRUCT_ZERO	buffer/buffer.hpp	/^      CONSTRUCT_ZERO = (1<<0),  \/\/ if enabled, constructors\/init will zero allocated space$/;"	e	enum:openvpn::BufferAllocatedType::__anon14
CONTENT	http/htmlskip.hpp	/^	CONTENT,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
CONTROL	ssl/proto.hpp	/^	CONTROL=1<<1,     \/\/ packet for control channel (otherwise for data channel)$/;"	e	enum:openvpn::ProtoContext::PacketType::__anon81
CONTROL_HARD_RESET_CLIENT_V2	ssl/proto.hpp	/^      CONTROL_HARD_RESET_CLIENT_V2 = 7,   \/\/ initial key from client, forget previous state$/;"	e	enum:openvpn::ProtoContext::__anon80
CONTROL_HARD_RESET_SERVER_V2	ssl/proto.hpp	/^      CONTROL_HARD_RESET_SERVER_V2 = 8,   \/\/ initial key from server, forget previous state$/;"	e	enum:openvpn::ProtoContext::__anon80
CONTROL_SOFT_RESET_V1	ssl/proto.hpp	/^      CONTROL_SOFT_RESET_V1 =        3,   \/\/ new key, graceful transition from old to new key$/;"	e	enum:openvpn::ProtoContext::__anon80
CONTROL_V1	ssl/proto.hpp	/^      CONTROL_V1 =                   4,   \/\/ control channel packet (usually TLS ciphertext)$/;"	e	enum:openvpn::ProtoContext::__anon80
CRL	openssl/pki/crl.hpp	/^      CRL() : crl_(nullptr) {}$/;"	f	class:openvpn::OpenSSLPKI::CRL
CRL	openssl/pki/crl.hpp	/^      CRL(const CRL& other)$/;"	f	class:openvpn::OpenSSLPKI::CRL
CRL	openssl/pki/crl.hpp	/^      explicit CRL(const std::string& crl_txt)$/;"	f	class:openvpn::OpenSSLPKI::CRL
CRL	openssl/pki/crl.hpp	/^    class CRL : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::OpenSSLPKI
CRLList	openssl/pki/crl.hpp	/^    class CRLList : public std::vector<CRLPtr>$/;"	c	namespace:openvpn::OpenSSLPKI
CRLPtr	openssl/pki/crl.hpp	/^    typedef RCPtr<CRL> CRLPtr;$/;"	t	namespace:openvpn::OpenSSLPKI
CRYPTO_DEFINED	crypto/cryptodc.hpp	/^      CRYPTO_DEFINED=(1<<2),  \/\/ may call encrypt or decrypt methods$/;"	e	enum:openvpn::CryptoDCInstance::__anon38
CT_INTERNAL_ERROR	polarssl/ssl/sslctx.hpp	/^	CT_INTERNAL_ERROR = -0x8001$/;"	e	enum:openvpn::PolarSSLContext::SSL::__anon75
CT_WOULD_BLOCK	polarssl/ssl/sslctx.hpp	/^	CT_WOULD_BLOCK = -0x8000,$/;"	e	enum:openvpn::PolarSSLContext::SSL::__anon75
C_CRLF	http/htmlskip.hpp	/^	C_CRLF,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
C_HTML_H	http/htmlskip.hpp	/^	C_HTML_H,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
C_HTML_L	http/htmlskip.hpp	/^	C_HTML_L,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
C_HTML_M	http/htmlskip.hpp	/^	C_HTML_M,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
C_HTML_T	http/htmlskip.hpp	/^	C_HTML_T,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
C_INITIAL	ssl/proto.hpp	/^      C_INITIAL=4,$/;"	e	enum:openvpn::ProtoContext::__anon80
C_OPEN	http/htmlskip.hpp	/^	C_OPEN,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
C_SLASH	http/htmlskip.hpp	/^	C_SLASH,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
C_WAIT_AUTH	ssl/proto.hpp	/^      C_WAIT_AUTH=6,$/;"	e	enum:openvpn::ProtoContext::__anon80
C_WAIT_AUTH_ACK	ssl/proto.hpp	/^      C_WAIT_AUTH_ACK=1,$/;"	e	enum:openvpn::ProtoContext::__anon80
C_WAIT_RESET	ssl/proto.hpp	/^      C_WAIT_RESET=5,   \/\/ must be C_INITIAL+1$/;"	e	enum:openvpn::ProtoContext::__anon80
C_WAIT_RESET_ACK	ssl/proto.hpp	/^      C_WAIT_RESET_ACK=0,$/;"	e	enum:openvpn::ProtoContext::__anon80
CertCRLList	openssl/pki/x509store.hpp	/^      typedef CertCRLListTemplate<X509List, CRLList> CertCRLList;$/;"	t	class:openvpn::OpenSSLPKI::X509Store
CertCRLList	openssl/ssl/sslctx.hpp	/^    typedef CertCRLListTemplate<OpenSSLPKI::X509List, OpenSSLPKI::CRLList> CertCRLList;$/;"	t	class:openvpn::OpenSSLContext
CertCRLListTemplate	pki/cclist.hpp	/^    CertCRLListTemplate() {}$/;"	f	class:openvpn::CertCRLListTemplate
CertCRLListTemplate	pki/cclist.hpp	/^    explicit CertCRLListTemplate(const std::string& content, const std::string& title)$/;"	f	class:openvpn::CertCRLListTemplate
CertCRLListTemplate	pki/cclist.hpp	/^  class CertCRLListTemplate$/;"	c	namespace:openvpn
CertVerifyFail	client/clievent.hpp	/^      CertVerifyFail(std::string reason) : ReasonBase(CERT_VERIFY_FAIL, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::CertVerifyFail
CertVerifyFail	client/clievent.hpp	/^    struct CertVerifyFail : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
ChallengeResponse	auth/cr.hpp	/^    ChallengeResponse()$/;"	f	class:openvpn::ChallengeResponse
ChallengeResponse	auth/cr.hpp	/^    ChallengeResponse(const std::string& cookie, const std::string& user)$/;"	f	class:openvpn::ChallengeResponse
ChallengeResponse	auth/cr.hpp	/^    explicit ChallengeResponse(const std::string& cookie)$/;"	f	class:openvpn::ChallengeResponse
ChallengeResponse	auth/cr.hpp	/^  class ChallengeResponse : public RC<thread_unsafe_refcount> {$/;"	c	namespace:openvpn
Char	common/unicode.hpp	/^      struct Char$/;"	s	class:openvpn::Unicode::UTF8Iterator
CipherContext	applecrypto/crypto/api.hpp	/^    typedef AppleCrypto::CipherContext CipherContext;$/;"	t	struct:openvpn::AppleCryptoAPI
CipherContext	applecrypto/crypto/cipher.hpp	/^      CipherContext()$/;"	f	class:openvpn::AppleCrypto::CipherContext
CipherContext	applecrypto/crypto/cipher.hpp	/^    class CipherContext$/;"	c	namespace:openvpn::AppleCrypto
CipherContext	crypto/cipher.hpp	/^    CipherContext() : mode_(CRYPTO_API::CipherContext::MODE_UNDEF) {}$/;"	f	class:openvpn::CipherContext
CipherContext	crypto/cipher.hpp	/^    CipherContext(const CryptoAlgs::Type cipher, const StaticKey& key, const int mode)$/;"	f	class:openvpn::CipherContext
CipherContext	crypto/cipher.hpp	/^  class CipherContext$/;"	c	namespace:openvpn
CipherContext	openssl/crypto/api.hpp	/^    typedef OpenSSLCrypto::CipherContext CipherContext;$/;"	t	struct:openvpn::OpenSSLCryptoAPI
CipherContext	openssl/crypto/cipher.hpp	/^      CipherContext()$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
CipherContext	openssl/crypto/cipher.hpp	/^    class CipherContext$/;"	c	namespace:openvpn::OpenSSLCrypto
CipherContext	polarssl/crypto/api.hpp	/^    typedef PolarSSLCrypto::CipherContext CipherContext;$/;"	t	struct:openvpn::PolarSSLCryptoAPI
CipherContext	polarssl/crypto/cipher.hpp	/^      CipherContext()$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
CipherContext	polarssl/crypto/cipher.hpp	/^    class CipherContext$/;"	c	namespace:openvpn::PolarSSLCrypto
CipherContextGCM	applecrypto/crypto/api.hpp	/^    typedef AppleCrypto::CipherContextGCM CipherContextGCM;$/;"	t	struct:openvpn::AppleCryptoAPI
CipherContextGCM	openssl/crypto/api.hpp	/^    typedef OpenSSLCrypto::CipherContextGCM CipherContextGCM;$/;"	t	struct:openvpn::OpenSSLCryptoAPI
CipherContextGCM	openssl/crypto/ciphergcm.hpp	/^      CipherContextGCM()$/;"	f	class:openvpn::OpenSSLCrypto::CipherContextGCM
CipherContextGCM	openssl/crypto/ciphergcm.hpp	/^    class CipherContextGCM$/;"	c	namespace:openvpn::OpenSSLCrypto
CipherContextGCM	polarssl/crypto/api.hpp	/^    typedef PolarSSLCrypto::CipherContextGCM CipherContextGCM;$/;"	t	struct:openvpn::PolarSSLCryptoAPI
CipherContextGCM	polarssl/crypto/ciphergcm.hpp	/^      CipherContextGCM()$/;"	f	class:openvpn::PolarSSLCrypto::CipherContextGCM
CipherContextGCM	polarssl/crypto/ciphergcm.hpp	/^    class CipherContextGCM$/;"	c	namespace:openvpn::PolarSSLCrypto
CircList	common/circ_list.hpp	/^    CircList() { init(0); }$/;"	f	class:openvpn::CircList
CircList	common/circ_list.hpp	/^    explicit CircList(const size_t capacity) { init(capacity); }$/;"	f	class:openvpn::CircList
CircList	common/circ_list.hpp	/^  class CircList$/;"	c	namespace:openvpn
CleanupType	common/cleanup.hpp	/^  class CleanupType$/;"	c	namespace:openvpn
Client	client/cliconnect.hpp	/^    typedef ClientOptions::Client Client;$/;"	t	class:openvpn::ClientConnect
Client	client/cliopt.hpp	/^    typedef ClientProto::Session Client;$/;"	t	class:openvpn::ClientOptions
Client	transport/client/httpcli.hpp	/^      Client(asio::io_context& io_context_arg,$/;"	f	class:openvpn::HTTPProxyTransport::Client
Client	transport/client/httpcli.hpp	/^    class Client : public TransportClient$/;"	c	namespace:openvpn::HTTPProxyTransport
Client	transport/client/tcpcli.hpp	/^      Client(asio::io_context& io_context_arg,$/;"	f	class:openvpn::TCPTransport::Client
Client	transport/client/tcpcli.hpp	/^    class Client : public TransportClient$/;"	c	namespace:openvpn::TCPTransport
Client	transport/client/udpcli.hpp	/^      Client(asio::io_context& io_context_arg,$/;"	f	class:openvpn::UDPTransport::Client
Client	transport/client/udpcli.hpp	/^    class Client : public TransportClient$/;"	c	namespace:openvpn::UDPTransport
Client	tun/builder/client.hpp	/^      Client(asio::io_context& io_context_arg,$/;"	f	class:openvpn::TunBuilderClient::Client
Client	tun/builder/client.hpp	/^    class Client : public TunClient$/;"	c	namespace:openvpn::TunBuilderClient
Client	tun/client/tunnull.hpp	/^      Client(asio::io_context& io_context_arg,$/;"	f	class:openvpn::TunNull::Client
Client	tun/client/tunnull.hpp	/^    class Client : public TunClient$/;"	c	namespace:openvpn::TunNull
Client	tun/linux/client/tuncli.hpp	/^      Client(asio::io_context& io_context_arg,$/;"	f	class:openvpn::TunLinux::Client
Client	tun/linux/client/tuncli.hpp	/^    class Client : public TunClient$/;"	c	namespace:openvpn::TunLinux
Client	tun/mac/client/tuncli.hpp	/^      Client(asio::io_context& io_context_arg,$/;"	f	class:openvpn::TunMac::Client
Client	tun/mac/client/tuncli.hpp	/^    class Client : public TunClient$/;"	c	namespace:openvpn::TunMac
Client	tun/win/client/tuncli.hpp	/^      Client(asio::io_context& io_context_arg,$/;"	f	class:openvpn::TunWin::Client
Client	tun/win/client/tuncli.hpp	/^    class Client : public TunClient$/;"	c	namespace:openvpn::TunWin
ClientConfig	transport/client/httpcli.hpp	/^      ClientConfig()$/;"	f	class:openvpn::HTTPProxyTransport::ClientConfig
ClientConfig	transport/client/httpcli.hpp	/^    class ClientConfig : public TransportClientFactory$/;"	c	namespace:openvpn::HTTPProxyTransport
ClientConfig	transport/client/tcpcli.hpp	/^      ClientConfig()$/;"	f	class:openvpn::TCPTransport::ClientConfig
ClientConfig	transport/client/tcpcli.hpp	/^    class ClientConfig : public TransportClientFactory$/;"	c	namespace:openvpn::TCPTransport
ClientConfig	transport/client/udpcli.hpp	/^      ClientConfig()$/;"	f	class:openvpn::UDPTransport::ClientConfig
ClientConfig	transport/client/udpcli.hpp	/^    class ClientConfig : public TransportClientFactory$/;"	c	namespace:openvpn::UDPTransport
ClientConfig	tun/builder/client.hpp	/^      ClientConfig()$/;"	f	class:openvpn::TunBuilderClient::ClientConfig
ClientConfig	tun/builder/client.hpp	/^    class ClientConfig : public TunClientFactory$/;"	c	namespace:openvpn::TunBuilderClient
ClientConfig	tun/client/tunnull.hpp	/^      ClientConfig() {}$/;"	f	class:openvpn::TunNull::ClientConfig
ClientConfig	tun/client/tunnull.hpp	/^    class ClientConfig : public TunClientFactory$/;"	c	namespace:openvpn::TunNull
ClientConfig	tun/linux/client/tuncli.hpp	/^      ClientConfig() {}$/;"	f	class:openvpn::TunLinux::ClientConfig
ClientConfig	tun/linux/client/tuncli.hpp	/^    class ClientConfig : public TunClientFactory$/;"	c	namespace:openvpn::TunLinux
ClientConfig	tun/mac/client/tuncli.hpp	/^    class ClientConfig : public TunClientFactory$/;"	c	namespace:openvpn::TunMac
ClientConfig	tun/win/client/tuncli.hpp	/^    class ClientConfig : public TunClientFactory$/;"	c	namespace:openvpn::TunWin
ClientConnect	client/cliconnect.hpp	/^    ClientConnect(asio::io_context& io_context_arg,$/;"	f	class:openvpn::ClientConnect
ClientConnect	client/cliconnect.hpp	/^  class ClientConnect : ClientProto::NotifyCallback,$/;"	c	namespace:openvpn
ClientCreds	client/clicreds.hpp	/^    ClientCreds() : allow_cache_password(false),$/;"	f	class:openvpn::ClientCreds
ClientCreds	client/clicreds.hpp	/^  class ClientCreds : public RC<thread_unsafe_refcount> {$/;"	c	namespace:openvpn
ClientEvent	client/clievent.hpp	/^  namespace ClientEvent {$/;"	n	namespace:openvpn
ClientHalt	client/clievent.hpp	/^      ClientHalt(std::string reason) : ReasonBase(CLIENT_HALT, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::ClientHalt
ClientHalt	client/clievent.hpp	/^    struct ClientHalt : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
ClientHalt	client/clihalt.hpp	/^    ClientHalt(const std::string& msg, const bool unicode_filter)$/;"	f	class:openvpn::ClientHalt
ClientHalt	client/clihalt.hpp	/^  class ClientHalt$/;"	c	namespace:openvpn
ClientLifeCycle	client/clilife.hpp	/^    class ClientLifeCycle : public RC<thread_unsafe_refcount> {$/;"	c	namespace:openvpn
ClientOptions	client/cliopt.hpp	/^    ClientOptions(const OptionList& opt,   \/\/ only needs to remain in scope for duration of constructor call$/;"	f	class:openvpn::ClientOptions
ClientOptions	client/cliopt.hpp	/^  class ClientOptions : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
ClientProto	client/cliproto.hpp	/^  namespace ClientProto {$/;"	n	namespace:openvpn
ClientRestart	client/clievent.hpp	/^      ClientRestart(std::string reason) : ReasonBase(CLIENT_RESTART, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::ClientRestart
ClientRestart	client/clievent.hpp	/^    struct ClientRestart : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
CoarseTime	time/coarsetime.hpp	/^    CoarseTime() {}$/;"	f	class:openvpn::CoarseTime
CoarseTime	time/coarsetime.hpp	/^    CoarseTime(const Time::Duration& pre, const Time::Duration& post)$/;"	f	class:openvpn::CoarseTime
CoarseTime	time/coarsetime.hpp	/^  class CoarseTime$/;"	c	namespace:openvpn
Command	common/process.hpp	/^    Command() {}$/;"	f	struct:openvpn::Command
Command	common/process.hpp	/^    Command(Argv argv_arg)$/;"	f	struct:openvpn::Command
Command	common/process.hpp	/^  struct Command : public Action$/;"	s	namespace:openvpn
Complete	buffer/bufcomposed.hpp	/^      Complete(BufferComposed& bc_arg)$/;"	f	class:openvpn::BufferComposed::Complete
Complete	buffer/bufcomposed.hpp	/^    class Complete : public BufferComplete$/;"	c	class:openvpn::BufferComposed
Component	ssl/datalimit.hpp	/^      Component(const size_type red_limit_arg)$/;"	f	class:openvpn::DataLimit::Component
Component	ssl/datalimit.hpp	/^    class Component$/;"	c	class:openvpn::DataLimit
Compress	compress/compress.hpp	/^    Compress(const Frame::Ptr& frame_arg,$/;"	f	class:openvpn::Compress
Compress	compress/compress.hpp	/^  class Compress : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
CompressContext	compress/compress.hpp	/^    CompressContext() : type_(NONE) {}$/;"	f	class:openvpn::CompressContext
CompressContext	compress/compress.hpp	/^    explicit CompressContext(const Type t, const bool asym)$/;"	f	class:openvpn::CompressContext
CompressContext	compress/compress.hpp	/^  class CompressContext$/;"	c	namespace:openvpn
CompressLZ4	compress/lz4.hpp	/^    CompressLZ4(const Frame::Ptr& frame, const SessionStats::Ptr& stats, const bool asym_arg)$/;"	f	class:openvpn::CompressLZ4
CompressLZ4	compress/lz4.hpp	/^  class CompressLZ4 : public CompressLZ4Base$/;"	c	namespace:openvpn
CompressLZ4Base	compress/lz4.hpp	/^    CompressLZ4Base(const Frame::Ptr& frame, const SessionStats::Ptr& stats)$/;"	f	class:openvpn::CompressLZ4Base
CompressLZ4Base	compress/lz4.hpp	/^  class CompressLZ4Base : public Compress$/;"	c	namespace:openvpn
CompressLZ4v2	compress/lz4.hpp	/^    CompressLZ4v2(const Frame::Ptr& frame, const SessionStats::Ptr& stats, const bool asym_arg)$/;"	f	class:openvpn::CompressLZ4v2
CompressLZ4v2	compress/lz4.hpp	/^  class CompressLZ4v2 : public CompressLZ4Base$/;"	c	namespace:openvpn
CompressLZO	compress/lzo.hpp	/^    CompressLZO(const Frame::Ptr& frame,$/;"	f	class:openvpn::CompressLZO
CompressLZO	compress/lzo.hpp	/^  class CompressLZO : public Compress$/;"	c	namespace:openvpn
CompressLZO	compress/lzoselect.hpp	/^  typedef CompressLZOAsym CompressLZO;$/;"	t	namespace:openvpn
CompressLZOAsym	compress/lzoasym.hpp	/^    CompressLZOAsym(const Frame::Ptr& frame,$/;"	f	class:openvpn::CompressLZOAsym
CompressLZOAsym	compress/lzoasym.hpp	/^  class CompressLZOAsym : public Compress$/;"	c	namespace:openvpn
CompressNull	compress/compnull.hpp	/^    CompressNull(const Frame::Ptr& frame, const SessionStats::Ptr& stats)$/;"	f	class:openvpn::CompressNull
CompressNull	compress/compnull.hpp	/^  class CompressNull : public Compress$/;"	c	namespace:openvpn
CompressSnappy	compress/snappy.hpp	/^    CompressSnappy(const Frame::Ptr& frame, const SessionStats::Ptr& stats, const bool asym_arg)$/;"	f	class:openvpn::CompressSnappy
CompressSnappy	compress/snappy.hpp	/^  class CompressSnappy : public Compress$/;"	c	namespace:openvpn
CompressStub	compress/compstub.hpp	/^    CompressStub(const Frame::Ptr& frame, const SessionStats::Ptr& stats, const bool support_swap_arg)$/;"	f	class:openvpn::CompressStub
CompressStub	compress/compstub.hpp	/^  class CompressStub : public Compress$/;"	c	namespace:openvpn
CompressStubV2	compress/compstub.hpp	/^    CompressStubV2(const Frame::Ptr& frame, const SessionStats::Ptr& stats)$/;"	f	class:openvpn::CompressStubV2
CompressStubV2	compress/compstub.hpp	/^  class CompressStubV2 : public Compress$/;"	c	namespace:openvpn
CompressionMode	ssl/proto_context_options.hpp	/^    enum CompressionMode {$/;"	g	struct:openvpn::ProtoContextOptions
Config	applecrypto/ssl/sslctx.hpp	/^      Config() {}$/;"	f	class:openvpn::AppleSSLContext::Config
Config	applecrypto/ssl/sslctx.hpp	/^    class Config : public SSLConfigAPI$/;"	c	class:openvpn::AppleSSLContext
Config	client/cliopt.hpp	/^    struct Config$/;"	s	class:openvpn::ClientOptions
Config	client/cliproto.hpp	/^	Config()$/;"	f	struct:openvpn::ClientProto::Session::Config
Config	client/cliproto.hpp	/^      struct Config : public RC<thread_unsafe_refcount>$/;"	s	class:openvpn::ClientProto::Session
Config	openssl/ssl/sslctx.hpp	/^      Config() : external_pki(nullptr),$/;"	f	class:openvpn::OpenSSLContext::Config
Config	openssl/ssl/sslctx.hpp	/^    class Config : public SSLConfigAPI$/;"	c	class:openvpn::OpenSSLContext
Config	pki/x509track.hpp	/^      Config(const Type type_arg, const bool full_chain_arg)$/;"	f	struct:openvpn::X509Track::Config
Config	pki/x509track.hpp	/^      Config(const std::string& spec)$/;"	f	struct:openvpn::X509Track::Config
Config	pki/x509track.hpp	/^    struct Config$/;"	s	namespace:openvpn::X509Track
Config	polarssl/ssl/sslctx.hpp	/^      Config() : external_pki(nullptr),$/;"	f	class:openvpn::PolarSSLContext::Config
Config	polarssl/ssl/sslctx.hpp	/^    class Config : public SSLConfigAPI$/;"	c	class:openvpn::PolarSSLContext
Config	ssl/proto.hpp	/^    class Config : public RCCopyable<thread_unsafe_refcount>$/;"	c	class:openvpn::ProtoContext
Config	transport/altproxy.hpp	/^      Config()$/;"	f	struct:openvpn::AltProxy::Config
Config	transport/altproxy.hpp	/^    struct Config$/;"	s	struct:openvpn::AltProxy
Config	transport/gremlin.hpp	/^      Config(const std::string& config_str)$/;"	f	class:openvpn::Gremlin::Config
Config	transport/gremlin.hpp	/^    class Config : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::Gremlin
Config	tun/builder/setup.hpp	/^    struct Config$/;"	s	namespace:openvpn::TunBuilderSetup
Config	tun/client/tunprop.hpp	/^    struct Config$/;"	s	class:openvpn::TunProp
Config	tun/mac/client/tunsetup.hpp	/^      struct Config : public TunBuilderSetup::Config$/;"	s	class:openvpn::TunMac::Setup
Config	tun/mac/macdns.hpp	/^      Config()$/;"	f	class:openvpn::MacDNS::Config
Config	tun/mac/macdns.hpp	/^      Config(const TunBuilderCapture& settings)$/;"	f	class:openvpn::MacDNS::Config
Config	tun/mac/macdns.hpp	/^    class Config : public RC<thread_safe_refcount>$/;"	c	class:openvpn::MacDNS
ConfigSet	pki/x509track.hpp	/^      ConfigSet() {}$/;"	f	struct:openvpn::X509Track::ConfigSet
ConfigSet	pki/x509track.hpp	/^      ConfigSet(const OptionList& opt,$/;"	f	struct:openvpn::X509Track::ConfigSet
ConfigSet	pki/x509track.hpp	/^    struct ConfigSet : public std::vector<Config>$/;"	s	namespace:openvpn::X509Track
ConnBlock	client/remotelist.hpp	/^    struct ConnBlock : public RC<thread_unsafe_refcount>$/;"	s	class:openvpn::RemoteList
ConnBlockFactory	client/remotelist.hpp	/^    struct ConnBlockFactory$/;"	s	class:openvpn::RemoteList
Connected	client/clievent.hpp	/^      Connected() : Base(CONNECTED) {}$/;"	f	struct:openvpn::ClientEvent::Connected
Connected	client/clievent.hpp	/^    struct Connected : public Base$/;"	s	namespace:openvpn::ClientEvent
Connected	http/status.hpp	/^	Connected=200,$/;"	e	enum:openvpn::HTTP::Status::__anon45
Connecting	client/clievent.hpp	/^      Connecting() : Base(CONNECTING) {}$/;"	f	struct:openvpn::ClientEvent::Connecting
Connecting	client/clievent.hpp	/^    struct Connecting : public Base$/;"	s	namespace:openvpn::ClientEvent
ConnectionTimeout	client/clievent.hpp	/^      ConnectionTimeout() : Base(CONNECTION_TIMEOUT) {}$/;"	f	struct:openvpn::ClientEvent::ConnectionTimeout
ConnectionTimeout	client/clievent.hpp	/^    struct ConnectionTimeout : public Base$/;"	s	namespace:openvpn::ClientEvent
Console	win/console.hpp	/^    namespace Console {$/;"	n	namespace:openvpn::Win
ConstBuffer	buffer/buffer.hpp	/^  typedef BufferType<const unsigned char> ConstBuffer;$/;"	t	namespace:openvpn
Context	frame/frame.hpp	/^      Context()$/;"	f	class:openvpn::Frame::Context
Context	frame/frame.hpp	/^      Context(const size_t headroom,$/;"	f	class:openvpn::Frame::Context
Context	frame/frame.hpp	/^    class Context$/;"	c	class:openvpn::Frame
Context	log/logsimple.hpp	/^      Context(const Wrapper&) {}$/;"	f	struct:openvpn::Log::Context
Context	log/logsimple.hpp	/^    struct Context$/;"	s	namespace:openvpn::Log
Context	log/logthread.hpp	/^      Context(OPENVPN_LOG_CLASS *cli)$/;"	f	struct:openvpn::Log::Context
Context	log/logthread.hpp	/^      Context(const Wrapper& wrap)$/;"	f	struct:openvpn::Log::Context
Context	log/logthread.hpp	/^    struct Context$/;"	s	namespace:openvpn::Log
Controller	common/rc.hpp	/^    struct Controller : public RC<RCImpl>$/;"	s	class:openvpn::RCWeak
ControllerRef	common/rc.hpp	/^    struct ControllerRef$/;"	s	namespace:openvpn
ConversionFlags	common/unicode-impl.hpp	/^    } ConversionFlags;$/;"	t	namespace:openvpn::Unicode	typeref:enum:openvpn::Unicode::__anon26
ConversionResult	common/unicode-impl.hpp	/^    } ConversionResult;$/;"	t	namespace:openvpn::Unicode	typeref:enum:openvpn::Unicode::__anon25
ConvertUTF16toUTF32	common/unicode-impl.hpp	/^    inline ConversionResult ConvertUTF16toUTF32 ($/;"	f	namespace:openvpn::Unicode
ConvertUTF16toUTF8	common/unicode-impl.hpp	/^    inline ConversionResult ConvertUTF16toUTF8 ($/;"	f	namespace:openvpn::Unicode
ConvertUTF32toUTF16	common/unicode-impl.hpp	/^    inline ConversionResult ConvertUTF32toUTF16 ($/;"	f	namespace:openvpn::Unicode
ConvertUTF32toUTF8	common/unicode-impl.hpp	/^    inline ConversionResult ConvertUTF32toUTF8 ($/;"	f	namespace:openvpn::Unicode
ConvertUTF8toUTF16	common/unicode-impl.hpp	/^    inline ConversionResult ConvertUTF8toUTF16 ($/;"	f	namespace:openvpn::Unicode
ConvertUTF8toUTF32	common/unicode-impl.hpp	/^    inline ConversionResult ConvertUTF8toUTF32 ($/;"	f	namespace:openvpn::Unicode
Creds	common/peercred.hpp	/^      Creds(const int uid_arg=-1, const int gid_arg=-1, const int pid_arg=-1)$/;"	f	struct:openvpn::SockOpt::Creds
Creds	common/peercred.hpp	/^    struct Creds$/;"	s	namespace:openvpn::SockOpt
Crypto	crypto/crypto_aead.hpp	/^      Crypto(const CryptoAlgs::Type cipher_arg,$/;"	f	class:openvpn::AEAD::Crypto
Crypto	crypto/crypto_aead.hpp	/^    class Crypto : public CryptoDCInstance$/;"	c	namespace:openvpn::AEAD
CryptoAPI	ssl/sslchoose.hpp	/^    typedef PolarSSLCryptoAPI CryptoAPI;$/;"	t	namespace:openvpn::SSLLib
CryptoAlgs	crypto/cryptoalgs.hpp	/^  namespace CryptoAlgs {$/;"	n	namespace:openvpn
CryptoCHM	crypto/crypto_chm.hpp	/^    CryptoCHM(const CryptoAlgs::Type cipher_arg,$/;"	f	class:openvpn::CryptoCHM
CryptoCHM	crypto/crypto_chm.hpp	/^  class CryptoCHM : public CryptoDCInstance$/;"	c	namespace:openvpn
CryptoContext	crypto/crypto_aead.hpp	/^      CryptoContext(const CryptoAlgs::Type cipher_arg,$/;"	f	class:openvpn::AEAD::CryptoContext
CryptoContext	crypto/crypto_aead.hpp	/^    class CryptoContext : public CryptoDCContext$/;"	c	namespace:openvpn::AEAD
CryptoContextCHM	crypto/crypto_chm.hpp	/^    CryptoContextCHM(const CryptoAlgs::Type cipher_arg,$/;"	f	class:openvpn::CryptoContextCHM
CryptoContextCHM	crypto/crypto_chm.hpp	/^  class CryptoContextCHM : public CryptoDCContext$/;"	c	namespace:openvpn
CryptoDCContext	crypto/cryptodc.hpp	/^  class CryptoDCContext : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
CryptoDCFactory	crypto/cryptodc.hpp	/^  class CryptoDCFactory : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
CryptoDCInstance	crypto/cryptodc.hpp	/^  class CryptoDCInstance : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
CryptoDCSelect	crypto/cryptodcsel.hpp	/^    CryptoDCSelect(const Frame::Ptr& frame_arg,$/;"	f	class:openvpn::CryptoDCSelect
CryptoDCSelect	crypto/cryptodcsel.hpp	/^  class CryptoDCSelect : public CryptoDCFactory$/;"	c	namespace:openvpn
CryptoDCSettings	crypto/cryptodc.hpp	/^    CryptoDCSettings()$/;"	f	class:openvpn::CryptoDCSettings
CryptoDCSettings	crypto/cryptodc.hpp	/^  class CryptoDCSettings$/;"	c	namespace:openvpn
CryptoDigestContext	crypto/digestapi.hpp	/^    CryptoDigestContext(const CryptoAlgs::Type digest_type)$/;"	f	class:openvpn::CryptoDigestContext
CryptoDigestContext	crypto/digestapi.hpp	/^  class CryptoDigestContext : public DigestContext$/;"	c	namespace:openvpn
CryptoDigestFactory	crypto/digestapi.hpp	/^class CryptoDigestFactory : public DigestFactory$/;"	c	namespace:openvpn
CryptoDigestInstance	crypto/digestapi.hpp	/^    CryptoDigestInstance(const CryptoAlgs::Type digest)$/;"	f	class:openvpn::CryptoDigestInstance
CryptoDigestInstance	crypto/digestapi.hpp	/^  class CryptoDigestInstance : public DigestInstance$/;"	c	namespace:openvpn
CryptoHMACInstance	crypto/digestapi.hpp	/^    CryptoHMACInstance(const CryptoAlgs::Type digest,$/;"	f	class:openvpn::CryptoHMACInstance
CryptoHMACInstance	crypto/digestapi.hpp	/^  class CryptoHMACInstance : public HMACInstance$/;"	c	namespace:openvpn
CryptoOvpnHMACContext	crypto/ovpnhmac.hpp	/^    CryptoOvpnHMACContext(const CryptoAlgs::Type digest_type)$/;"	f	class:openvpn::CryptoOvpnHMACContext
CryptoOvpnHMACContext	crypto/ovpnhmac.hpp	/^  class CryptoOvpnHMACContext : public OvpnHMACContext$/;"	c	namespace:openvpn
CryptoOvpnHMACFactory	crypto/ovpnhmac.hpp	/^  class CryptoOvpnHMACFactory : public OvpnHMACFactory$/;"	c	namespace:openvpn
CryptoOvpnHMACInstance	crypto/ovpnhmac.hpp	/^    CryptoOvpnHMACInstance(const CryptoAlgs::Type digest_arg)$/;"	f	class:openvpn::CryptoOvpnHMACInstance
CryptoOvpnHMACInstance	crypto/ovpnhmac.hpp	/^  class CryptoOvpnHMACInstance : public OvpnHMACInstance$/;"	c	namespace:openvpn
CryptoTLSPRFFactory	ssl/tlsprf.hpp	/^  class CryptoTLSPRFFactory : public TLSPRFFactory$/;"	c	namespace:openvpn
CryptoTLSPRFInstance	ssl/tlsprf.hpp	/^    CryptoTLSPRFInstance(const bool self_is_server)$/;"	f	class:openvpn::CryptoTLSPRFInstance
CryptoTLSPRFInstance	ssl/tlsprf.hpp	/^  class CryptoTLSPRFInstance : public TLSPRFInstance$/;"	c	namespace:openvpn
CustomHeader	transport/client/httpcli.hpp	/^      struct CustomHeader : public RC<thread_unsafe_refcount>$/;"	s	class:openvpn::HTTPProxyTransport::Options
CustomHeaderList	transport/client/httpcli.hpp	/^      struct CustomHeaderList : public std::vector<CustomHeader::Ptr>$/;"	s	class:openvpn::HTTPProxyTransport::Options
DAILY	log/logperiod.hpp	/^      DAILY,$/;"	e	enum:openvpn::LogPeriod::Period
DATA_V1	ssl/proto.hpp	/^      DATA_V1 =                      6,   \/\/ data channel packet with 1-byte header$/;"	e	enum:openvpn::ProtoContext::__anon80
DATA_V2	ssl/proto.hpp	/^      DATA_V2 =                      9,   \/\/ data channel packet with 4-byte header$/;"	e	enum:openvpn::ProtoContext::__anon80
DCO	transport/dco.hpp	/^  struct DCO : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
DCOTransportSource	log/sessionstats.hpp	/^    struct DCOTransportSource : public virtual RC<thread_unsafe_refcount>$/;"	s	class:openvpn::SessionStats
DEACTIVATE_ALL	crypto/cryptodc.hpp	/^      DEACTIVATE_ALL,$/;"	e	enum:openvpn::CryptoDCInstance::RekeyType
DEACTIVATE_SECONDARY	crypto/cryptodc.hpp	/^      DEACTIVATE_SECONDARY,$/;"	e	enum:openvpn::CryptoDCInstance::RekeyType
DECOMPRESS_WORK	frame/frame.hpp	/^      DECOMPRESS_WORK,$/;"	e	enum:openvpn::Frame::__anon44
DECRYPT	applecrypto/crypto/cipher.hpp	/^	DECRYPT = kCCDecrypt$/;"	e	enum:openvpn::AppleCrypto::CipherContext::__anon7
DECRYPT	crypto/static_key.hpp	/^      DECRYPT = (1<<1),$/;"	e	enum:openvpn::OpenVPNStaticKey::__anon42
DECRYPT	openssl/crypto/cipher.hpp	/^	DECRYPT = 0$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContext::__anon55
DECRYPT	openssl/crypto/ciphergcm.hpp	/^	DECRYPT = 0$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContextGCM::__anon57
DECRYPT	openssl/util/tokenencrypt.hpp	/^      DECRYPT = 0$/;"	e	enum:openvpn::TokenEncrypt::__anon63
DECRYPT	polarssl/crypto/cipher.hpp	/^	DECRYPT = POLARSSL_DECRYPT$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContext::__anon67
DECRYPT	polarssl/crypto/ciphergcm.hpp	/^	DECRYPT = POLARSSL_DECRYPT$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContextGCM::__anon69
DECRYPT_ERROR	error/error.hpp	/^      DECRYPT_ERROR,       \/\/ data channel encrypt\/decrypt error$/;"	e	enum:openvpn::Error::Type
DECRYPT_WORK	frame/frame.hpp	/^      DECRYPT_WORK,$/;"	e	enum:openvpn::Frame::__anon44
DEFAULT	tun/ipv6_setting.hpp	/^      DEFAULT,$/;"	e	enum:openvpn::IPv6Setting::Type
DEFERRED_CERT_VERIFY	ssl/sslconsts.hpp	/^      DEFERRED_CERT_VERIFY=(1<<3),$/;"	e	enum:openvpn::SSLConst::__anon84
DEFINED	ssl/proto.hpp	/^	DEFINED=1<<0,     \/\/ packet is valid (otherwise invalid)$/;"	e	enum:openvpn::ProtoContext::PacketType::__anon81
DESTRUCT_ZERO	buffer/buffer.hpp	/^      DESTRUCT_ZERO  = (1<<1),  \/\/ if enabled, destructor will zero data before deletion$/;"	e	enum:openvpn::BufferAllocatedType::__anon14
DES_CBC	crypto/cryptoalgs.hpp	/^      DES_CBC,$/;"	e	enum:openvpn::CryptoAlgs::Type
DES_EDE3_CBC	crypto/cryptoalgs.hpp	/^      DES_EDE3_CBC,$/;"	e	enum:openvpn::CryptoAlgs::Type
DH	openssl/pki/dh.hpp	/^      DH() : dh_(nullptr) {}$/;"	f	class:openvpn::OpenSSLPKI::DH
DH	openssl/pki/dh.hpp	/^      DH(const DH& other)$/;"	f	class:openvpn::OpenSSLPKI::DH
DH	openssl/pki/dh.hpp	/^      explicit DH(const std::string& dh_txt)$/;"	f	class:openvpn::OpenSSLPKI::DH
DH	openssl/pki/dh.hpp	/^    class DH$/;"	c	namespace:openvpn::OpenSSLPKI
DH	polarssl/pki/dh.hpp	/^      DH() : dhc(nullptr) {}$/;"	f	class:openvpn::PolarSSLPKI::DH
DH	polarssl/pki/dh.hpp	/^      DH(const std::string& dh_txt, const std::string& title)$/;"	f	class:openvpn::PolarSSLPKI::DH
DH	polarssl/pki/dh.hpp	/^    class DH : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::PolarSSLPKI
DHCP	ip/dhcp.hpp	/^  struct DHCP {$/;"	s	namespace:openvpn
DHCPACK	ip/dhcp.hpp	/^      DHCPACK      =  5,$/;"	e	enum:openvpn::DHCP::__anon46
DHCPCapture	tun/client/dhcp_capture.hpp	/^    DHCPCapture(const TunBuilderCapture::Ptr& props_arg)$/;"	f	class:openvpn::DHCPCapture
DHCPCapture	tun/client/dhcp_capture.hpp	/^  class DHCPCapture$/;"	c	namespace:openvpn
DHCPDECLINE	ip/dhcp.hpp	/^      DHCPDECLINE  =  4,$/;"	e	enum:openvpn::DHCP::__anon46
DHCPDISCOVER	ip/dhcp.hpp	/^      DHCPDISCOVER =  1,$/;"	e	enum:openvpn::DHCP::__anon46
DHCPINFORM	ip/dhcp.hpp	/^      DHCPINFORM   =  8,$/;"	e	enum:openvpn::DHCP::__anon46
DHCPNAK	ip/dhcp.hpp	/^      DHCPNAK      =  6,$/;"	e	enum:openvpn::DHCP::__anon46
DHCPOFFER	ip/dhcp.hpp	/^      DHCPOFFER    =  2,$/;"	e	enum:openvpn::DHCP::__anon46
DHCPPacket	ip/dhcp.hpp	/^  struct DHCPPacket {$/;"	s	namespace:openvpn
DHCPRELEASE	ip/dhcp.hpp	/^      DHCPRELEASE  =  7,$/;"	e	enum:openvpn::DHCP::__anon46
DHCPREQUEST	ip/dhcp.hpp	/^      DHCPREQUEST  =  3,$/;"	e	enum:openvpn::DHCP::__anon46
DHCP_DNS	ip/dhcp.hpp	/^      DHCP_DNS      =  6,$/;"	e	enum:openvpn::DHCP::__anon46
DHCP_END	ip/dhcp.hpp	/^      DHCP_END      =  255,$/;"	e	enum:openvpn::DHCP::__anon46
DHCP_MSG_TYPE	ip/dhcp.hpp	/^      DHCP_MSG_TYPE =  53  \/* message type (u8) *\/,$/;"	e	enum:openvpn::DHCP::__anon46
DHCP_NETMASK	ip/dhcp.hpp	/^      DHCP_NETMASK  =  1,$/;"	e	enum:openvpn::DHCP::__anon46
DHCP_PAD	ip/dhcp.hpp	/^      DHCP_PAD      =  0,$/;"	e	enum:openvpn::DHCP::__anon46
DHCP_ROUTER	ip/dhcp.hpp	/^      DHCP_ROUTER   =  3,$/;"	e	enum:openvpn::DHCP::__anon46
DH_private	openssl/pki/dh.hpp	/^    namespace DH_private {$/;"	n	namespace:openvpn::OpenSSLPKI
DISCONNECTED	client/clievent.hpp	/^      DISCONNECTED=0,$/;"	e	enum:openvpn::ClientEvent::Type
DNSAction	tun/mac/macdns_watchdog.hpp	/^      DNSAction(const MacDNSWatchdog::Ptr& parent_arg,$/;"	f	class:openvpn::MacDNSWatchdog::DNSAction
DNSAction	tun/mac/macdns_watchdog.hpp	/^    class DNSAction : public Action$/;"	c	class:openvpn::MacDNSWatchdog
DNSServer	tun/builder/capture.hpp	/^    class DNSServer$/;"	c	class:openvpn::TunBuilderCapture
DONE	http/htmlskip.hpp	/^	DONE,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
DSDict	tun/mac/macdns.hpp	/^      DSDict(CF::DynamicStore& sc_arg, const std::string& sname_arg, const std::string& dskey_arg)$/;"	f	class:openvpn::MacDNS::DSDict
DSDict	tun/mac/macdns.hpp	/^    class DSDict {$/;"	c	class:openvpn::MacDNS
DYNAMIC_CHALLENGE	client/clievent.hpp	/^      DYNAMIC_CHALLENGE,$/;"	e	enum:openvpn::ClientEvent::Type
Data	log/sessionstats.hpp	/^	Data()$/;"	f	struct:openvpn::SessionStats::DCOTransportSource::Data
Data	log/sessionstats.hpp	/^	Data(count_t bytes_in_arg, count_t bytes_out_arg)$/;"	f	struct:openvpn::SessionStats::DCOTransportSource::Data
Data	log/sessionstats.hpp	/^      struct Data {$/;"	s	struct:openvpn::SessionStats::DCOTransportSource
DataChannelKey	ssl/proto.hpp	/^	DataChannelKey() : rekey_defined(false) {}$/;"	f	struct:openvpn::ProtoContext::KeyContext::DataChannelKey
DataChannelKey	ssl/proto.hpp	/^      struct DataChannelKey$/;"	s	class:openvpn::ProtoContext::KeyContext
DataLimit	ssl/datalimit.hpp	/^    DataLimit(const Parameters& p)$/;"	f	class:openvpn::DataLimit
DataLimit	ssl/datalimit.hpp	/^  class DataLimit$/;"	c	namespace:openvpn
Decrypt	crypto/crypto_aead.hpp	/^      struct Decrypt {$/;"	s	class:openvpn::AEAD::Crypto
Decrypt	ssl/datalimit.hpp	/^      Decrypt=1,$/;"	e	enum:openvpn::DataLimit::Mode
DecryptCHM	crypto/decrypt_chm.hpp	/^  class DecryptCHM {$/;"	c	namespace:openvpn
DefaultGateway	tun/win/tunutil.hpp	/^	DefaultGateway()$/;"	f	class:openvpn::TunWin::Util::DefaultGateway
DefaultGateway	tun/win/tunutil.hpp	/^      class DefaultGateway$/;"	c	namespace:openvpn::TunWin::Util
DelayedQueue	transport/gremlin.hpp	/^      DelayedQueue(asio::io_context& io_context,$/;"	f	struct:openvpn::Gremlin::DelayedQueue
DelayedQueue	transport/gremlin.hpp	/^    struct DelayedQueue : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn::Gremlin
DestructorBase	common/destruct.hpp	/^  struct DestructorBase : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
DevURand	random/devurand.hpp	/^    DevURand()$/;"	f	class:openvpn::DevURand
DevURand	random/devurand.hpp	/^  class DevURand : public RandomAPI$/;"	c	namespace:openvpn
Digest	proxy/httpdigest.hpp	/^    class Digest$/;"	c	namespace:openvpn::HTTPProxy
DigestAlgorithm	applecrypto/crypto/digest.hpp	/^    struct DigestAlgorithm {$/;"	s	namespace:openvpn::AppleCrypto
DigestCTX	applecrypto/crypto/digest.hpp	/^    struct DigestCTX {$/;"	s	namespace:openvpn::AppleCrypto
DigestContext	applecrypto/crypto/api.hpp	/^    typedef AppleCrypto::DigestContext DigestContext;$/;"	t	struct:openvpn::AppleCryptoAPI
DigestContext	applecrypto/crypto/digest.hpp	/^      DigestContext()$/;"	f	class:openvpn::AppleCrypto::DigestContext
DigestContext	applecrypto/crypto/digest.hpp	/^      DigestContext(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::AppleCrypto::DigestContext
DigestContext	applecrypto/crypto/digest.hpp	/^    class DigestContext$/;"	c	namespace:openvpn::AppleCrypto
DigestContext	crypto/digestapi.hpp	/^  class DigestContext : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
DigestContext	openssl/crypto/api.hpp	/^    typedef OpenSSLCrypto::DigestContext DigestContext;$/;"	t	struct:openvpn::OpenSSLCryptoAPI
DigestContext	openssl/crypto/digest.hpp	/^      DigestContext()$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
DigestContext	openssl/crypto/digest.hpp	/^      DigestContext(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
DigestContext	openssl/crypto/digest.hpp	/^    class DigestContext$/;"	c	namespace:openvpn::OpenSSLCrypto
DigestContext	polarssl/crypto/api.hpp	/^    typedef PolarSSLCrypto::DigestContext DigestContext;$/;"	t	struct:openvpn::PolarSSLCryptoAPI
DigestContext	polarssl/crypto/digest.hpp	/^      DigestContext()$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
DigestContext	polarssl/crypto/digest.hpp	/^      DigestContext(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
DigestContext	polarssl/crypto/digest.hpp	/^    class DigestContext$/;"	c	namespace:openvpn::PolarSSLCrypto
DigestFactory	crypto/digestapi.hpp	/^  class DigestFactory : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
DigestInfo	applecrypto/crypto/digest.hpp	/^      DigestInfo(CryptoAlgs::Type type,$/;"	f	class:openvpn::AppleCrypto::DigestInfo
DigestInfo	applecrypto/crypto/digest.hpp	/^    class DigestInfo$/;"	c	namespace:openvpn::AppleCrypto
DigestInstance	crypto/digestapi.hpp	/^  class DigestInstance : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
DigestPrefix	pki/pkcs1.hpp	/^    namespace DigestPrefix { \/\/ CONST GLOBAL$/;"	n	namespace:openvpn::PKCS1
Directives	client/remotelist.hpp	/^    struct Directives$/;"	s	class:openvpn::RemoteList
Disconnected	client/clievent.hpp	/^      Disconnected() : Base(DISCONNECTED) {}$/;"	f	struct:openvpn::ClientEvent::Disconnected
Disconnected	client/clievent.hpp	/^    struct Disconnected : public Base$/;"	s	namespace:openvpn::ClientEvent
Duration	time/time.hpp	/^      explicit Duration(const T duration) : duration_(duration) {}$/;"	f	class:openvpn::TimeType::Duration
Duration	time/time.hpp	/^    class Duration$/;"	c	class:openvpn::TimeType
DynamicChallenge	client/clievent.hpp	/^      DynamicChallenge(std::string reason) : ReasonBase(DYNAMIC_CHALLENGE, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::DynamicChallenge
DynamicChallenge	client/clievent.hpp	/^    struct DynamicChallenge : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
DynamicStoreCopy	apple/scdynstore.hpp	/^    inline RET DynamicStoreCopy(const DynamicStore& ds, const KEY& key)$/;"	f	namespace:openvpn::CF
DynamicStoreCopyDict	apple/scdynstore.hpp	/^    inline Dict DynamicStoreCopyDict(const DynamicStore& ds, const KEY& key)$/;"	f	namespace:openvpn::CF
ECHO_OPT	client/clievent.hpp	/^      ECHO_OPT,$/;"	e	enum:openvpn::ClientEvent::Type
ECHO_REPLY	ip/icmp.hpp	/^      ECHO_REPLY = 0,$/;"	e	enum:openvpn::ICMP::__anon47
ECHO_REQUEST	ip/icmp.hpp	/^      ECHO_REQUEST = 8,$/;"	e	enum:openvpn::ICMP::__anon47
EMAIL	pki/x509track.hpp	/^      EMAIL,$/;"	e	enum:openvpn::X509Track::Type
ENABLE_SNI	ssl/sslconsts.hpp	/^      ENABLE_SNI=(1<<2),$/;"	e	enum:openvpn::SSLConst::__anon84
ENABLE_WATCHDOG	tun/mac/macdns_watchdog.hpp	/^      ENABLE_WATCHDOG  = (1<<0),$/;"	e	enum:openvpn::MacDNSWatchdog::__anon93
ENCAPSULATION_ERROR	error/error.hpp	/^      ENCAPSULATION_ERROR, \/\/ exceptions thrown during packet encapsulation$/;"	e	enum:openvpn::Error::Type
ENCRYPT	applecrypto/crypto/cipher.hpp	/^	ENCRYPT = kCCEncrypt,$/;"	e	enum:openvpn::AppleCrypto::CipherContext::__anon7
ENCRYPT	crypto/static_key.hpp	/^      ENCRYPT = 0,$/;"	e	enum:openvpn::OpenVPNStaticKey::__anon42
ENCRYPT	openssl/crypto/cipher.hpp	/^	ENCRYPT = 1,$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContext::__anon55
ENCRYPT	openssl/crypto/ciphergcm.hpp	/^	ENCRYPT = 1,$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContextGCM::__anon57
ENCRYPT	openssl/util/tokenencrypt.hpp	/^      ENCRYPT = 1,$/;"	e	enum:openvpn::TokenEncrypt::__anon63
ENCRYPT	polarssl/crypto/cipher.hpp	/^	ENCRYPT = POLARSSL_ENCRYPT,$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContext::__anon67
ENCRYPT	polarssl/crypto/ciphergcm.hpp	/^	ENCRYPT = POLARSSL_ENCRYPT,$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContextGCM::__anon69
ENCRYPT_WORK	frame/frame.hpp	/^      ENCRYPT_WORK=0,$/;"	e	enum:openvpn::Frame::__anon44
EPKI_CERT_ERROR	error/error.hpp	/^      EPKI_CERT_ERROR,     \/\/ error obtaining certificate from External PKI provider$/;"	e	enum:openvpn::Error::Type
EPKI_ERROR	client/clievent.hpp	/^      EPKI_ERROR,          \/\/ EPKI refers to External PKI errors, i.e. errors in accessing external$/;"	e	enum:openvpn::ClientEvent::Type
EPKI_INVALID_ALIAS	client/clievent.hpp	/^      EPKI_INVALID_ALIAS,  \/\/    certificates or keys.$/;"	e	enum:openvpn::ClientEvent::Type
EPKI_SIGN_ERROR	error/error.hpp	/^      EPKI_SIGN_ERROR,     \/\/ error obtaining RSA signature from External PKI provider$/;"	e	enum:openvpn::Error::Type
EQUAL	addr/routeinv.hpp	/^	EQUAL,$/;"	e	enum:openvpn::IP::RouteInverter::Type
ERROR	common/pthreadcond.hpp	/^      ERROR,      \/\/ at least one thread called error()$/;"	e	enum:openvpn::PThreadBarrier::Status
ERROR_THROWN	common/pthreadcond.hpp	/^      ERROR_THROWN,  \/\/ error() was called$/;"	e	enum:openvpn::PThreadBarrier::State
EXPIRED	auth/authcert.hpp	/^	  EXPIRED,$/;"	e	enum:openvpn::AuthCert::Fail::Type
EXPLICIT_EXIT_NOTIFY_DEFINED	crypto/cryptodc.hpp	/^      EXPLICIT_EXIT_NOTIFY_DEFINED=(1<<3),  \/\/ may call explicit_exit_notify method$/;"	e	enum:openvpn::CryptoDCInstance::__anon38
EXPLICIT_EXIT_NOTIFY_FIRST_BYTE	ssl/proto.hpp	/^	EXPLICIT_EXIT_NOTIFY_FIRST_BYTE = 0x28  \/\/ first byte of exit message$/;"	e	enum:openvpn::proto_context_private::__anon77::__anon79
Echo	client/clievent.hpp	/^      Echo(std::string value) : ReasonBase(ECHO_OPT, std::move(value)) {}$/;"	f	struct:openvpn::ClientEvent::Echo
Echo	client/clievent.hpp	/^    struct Echo : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
EmulateExcludeRoute	tun/client/emuexr.hpp	/^  struct EmulateExcludeRoute : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
EmulateExcludeRouteFactory	tun/client/emuexr.hpp	/^  struct EmulateExcludeRouteFactory : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
EmulateExcludeRouteFactoryImpl	client/cliemuexr.hpp	/^    EmulateExcludeRouteFactoryImpl(const bool exclude_server_address)$/;"	f	class:openvpn::EmulateExcludeRouteFactoryImpl
EmulateExcludeRouteFactoryImpl	client/cliemuexr.hpp	/^  class EmulateExcludeRouteFactoryImpl : public EmulateExcludeRouteFactory$/;"	c	namespace:openvpn
EmulateExcludeRouteImpl	client/cliemuexr.hpp	/^    EmulateExcludeRouteImpl(const bool exclude_server_address)$/;"	f	class:openvpn::EmulateExcludeRouteImpl
EmulateExcludeRouteImpl	client/cliemuexr.hpp	/^  class EmulateExcludeRouteImpl : public EmulateExcludeRoute$/;"	c	namespace:openvpn
EmulateExcludeRoutes	tun/builder/rgwflags.hpp	/^      EmulateExcludeRoutes=(1<<16),$/;"	e	enum:openvpn::RGWFlags::__anon87
Encrypt	crypto/crypto_aead.hpp	/^      struct Encrypt {$/;"	s	class:openvpn::AEAD::Crypto
Encrypt	ssl/datalimit.hpp	/^      Encrypt=0,$/;"	e	enum:openvpn::DataLimit::Mode
EncryptCHM	crypto/encrypt_chm.hpp	/^  class EncryptCHM {$/;"	c	namespace:openvpn
Endian	common/endian.hpp	/^  namespace Endian {$/;"	n	namespace:openvpn
EnumIface	netconf/enumiface.hpp	/^      EnumIface()$/;"	f	class:openvpn::EnumIface
EnumIface	netconf/enumiface.hpp	/^    class EnumIface$/;"	c	namespace:openvpn
Environ	common/process.hpp	/^  class Environ : public std::vector<std::string>$/;"	c	namespace:openvpn
EpkiError	client/clievent.hpp	/^      EpkiError(std::string reason) : ReasonBase(EPKI_ERROR, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::EpkiError
EpkiError	client/clievent.hpp	/^    struct EpkiError : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
EpkiInvalidAlias	client/clievent.hpp	/^      EpkiInvalidAlias(std::string reason) : ReasonBase(EPKI_INVALID_ALIAS, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::EpkiInvalidAlias
EpkiInvalidAlias	client/clievent.hpp	/^    struct EpkiInvalidAlias : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
Error	error/error.hpp	/^  namespace Error {$/;"	n	namespace:openvpn
Error	win/winerr.hpp	/^      Error(const DWORD err)$/;"	f	struct:openvpn::Win::Error
Error	win/winerr.hpp	/^    struct Error : public asio::error_code$/;"	s	namespace:openvpn::Win
ErrorCode	error/excode.hpp	/^    ErrorCode(const Error::Type code, const bool fatal, const std::string& err)$/;"	f	class:openvpn::ErrorCode
ErrorCode	error/excode.hpp	/^  class ErrorCode : public ExceptionCode$/;"	c	namespace:openvpn
EthHeader	ip/eth.hpp	/^  struct EthHeader {$/;"	s	namespace:openvpn
Event	transport/gremlin.hpp	/^	Event(Time fire_arg, F&& func_arg)$/;"	f	struct:openvpn::Gremlin::DelayedQueue::Event
Event	transport/gremlin.hpp	/^      struct Event : public EventBase$/;"	s	struct:openvpn::Gremlin::DelayedQueue
EventBase	transport/gremlin.hpp	/^      struct EventBase$/;"	s	struct:openvpn::Gremlin::DelayedQueue
EventType	ssl/proto.hpp	/^      enum EventType {$/;"	g	class:openvpn::ProtoContext::KeyContext
Exception	common/exception.hpp	/^  class Exception : public std::exception$/;"	c	namespace:openvpn
ExceptionCode	error/excode.hpp	/^    ExceptionCode()$/;"	f	class:openvpn::ExceptionCode
ExceptionCode	error/excode.hpp	/^    ExceptionCode(const Error::Type code)$/;"	f	class:openvpn::ExceptionCode
ExceptionCode	error/excode.hpp	/^    ExceptionCode(const Error::Type code, const bool fatal)$/;"	f	class:openvpn::ExceptionCode
ExceptionCode	error/excode.hpp	/^  class ExceptionCode : public std::exception$/;"	c	namespace:openvpn
ExternalPKIBase	pki/epkibase.hpp	/^  class ExternalPKIBase$/;"	c	namespace:openvpn
ExternalPKIImpl	openssl/ssl/sslctx.hpp	/^      ExternalPKIImpl(SSL_CTX* ssl_ctx, ::X509* cert, ExternalPKIBase* external_pki_arg)$/;"	f	class:openvpn::OpenSSLContext::ExternalPKIImpl
ExternalPKIImpl	openssl/ssl/sslctx.hpp	/^    class ExternalPKIImpl {$/;"	c	class:openvpn::OpenSSLContext
FAIL	http/htmlskip.hpp	/^	FAIL,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
FATAL_ERROR_START	client/clievent.hpp	/^      FATAL_ERROR_START    = AUTH_FAILED,     \/\/ start of fatal errors$/;"	e	enum:openvpn::ClientEvent::__anon16
FATAL_FLAG	error/excode.hpp	/^      FATAL_FLAG = 0x80000000$/;"	e	enum:openvpn::ExceptionCode::__anon43
FIRST_OPCODE	ssl/proto.hpp	/^      FIRST_OPCODE =                3,$/;"	e	enum:openvpn::ProtoContext::__anon80
FLAGS_APPEND	common/redir.hpp	/^    static constexpr int FLAGS_APPEND = O_CREAT | O_WRONLY | O_APPEND;$/;"	m	class:openvpn::RedirectStd
FLAGS_MUST_NOT_EXIST	common/redir.hpp	/^    static constexpr int FLAGS_MUST_NOT_EXIST = O_CREAT | O_WRONLY | O_EXCL;$/;"	m	class:openvpn::RedirectStd
FLAGS_OVERWRITE	common/redir.hpp	/^    static constexpr int FLAGS_OVERWRITE = O_CREAT | O_WRONLY | O_TRUNC;$/;"	m	class:openvpn::RedirectStd
FLUSH_RECONFIG	tun/mac/macdns_watchdog.hpp	/^      FLUSH_RECONFIG   = (1<<2),$/;"	e	enum:openvpn::MacDNSWatchdog::__anon93
FOLLOW_FULL	options/merge.hpp	/^      FOLLOW_FULL,$/;"	e	enum:openvpn::ProfileMerge::Follow
FOLLOW_NONE	options/merge.hpp	/^      FOLLOW_NONE,$/;"	e	enum:openvpn::ProfileMerge::Follow
FOLLOW_PARTIAL	options/merge.hpp	/^      FOLLOW_PARTIAL,$/;"	e	enum:openvpn::ProfileMerge::Follow
F_ADD_DNS	tun/client/tunprop.hpp	/^      F_ADD_DNS=(1<<0),$/;"	e	enum:openvpn::TunProp::__anon88
F_ALLOW_DC	crypto/cryptoalgs.hpp	/^      F_ALLOW_DC=(1<<4),  \/\/ alg may be used in OpenVPN data channel$/;"	e	enum:openvpn::CryptoAlgs::AlgFlags
F_CIPHER	crypto/cryptoalgs.hpp	/^      F_CIPHER=(1<<2),    \/\/ alg is a cipher$/;"	e	enum:openvpn::CryptoAlgs::AlgFlags
F_DIGEST	crypto/cryptoalgs.hpp	/^      F_DIGEST=(1<<3),    \/\/ alg is a digest$/;"	e	enum:openvpn::CryptoAlgs::AlgFlags
F_HTTP_PROXY	options/merge.hpp	/^      F_HTTP_PROXY = (1<<2),$/;"	e	enum:openvpn::ProfileMerge::__anon64
F_MAY_INCLUDE_KEY_DIRECTION	options/merge.hpp	/^      F_MAY_INCLUDE_KEY_DIRECTION = (1<<0),$/;"	e	enum:openvpn::ProfileMerge::__anon64
F_PKCS12	options/merge.hpp	/^      F_PKCS12 = (1<<1),$/;"	e	enum:openvpn::ProfileMerge::__anon64
F_SIGHUP	common/signal.hpp	/^      F_SIGHUP  = (1<<2),$/;"	e	enum:openvpn::Signal::__anon23
F_SIGINT	common/signal.hpp	/^      F_SIGINT  = (1<<0),$/;"	e	enum:openvpn::Signal::__anon23
F_SIGPIPE	common/signal.hpp	/^      F_SIGPIPE  = (1<<5),$/;"	e	enum:openvpn::Signal::__anon23
F_SIGTERM	common/signal.hpp	/^      F_SIGTERM = (1<<1),$/;"	e	enum:openvpn::Signal::__anon23
F_SIGUSR1	common/signal.hpp	/^      F_SIGUSR1  = (1<<3),$/;"	e	enum:openvpn::Signal::__anon23
F_SIGUSR2	common/signal.hpp	/^      F_SIGUSR2  = (1<<4),$/;"	e	enum:openvpn::Signal::__anon23
Factory	server/servproto.hpp	/^      Factory(asio::io_context& io_context_arg,$/;"	f	class:openvpn::ServerProto::Factory
Factory	server/servproto.hpp	/^    class Factory : public TransportClientInstanceFactory$/;"	c	class:openvpn::ServerProto
Factory	tun/builder/setup.hpp	/^    struct Factory : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn::TunBuilderSetup
Fail	auth/authcert.hpp	/^      class Fail$/;"	c	struct:openvpn::AuthCert
FilterBase	common/options.hpp	/^    struct FilterBase : public RC<thread_unsafe_refcount>$/;"	s	class:openvpn::OptionList
Flags	client/rgopt.hpp	/^    enum Flags {$/;"	g	class:openvpn::RedirectGatewayFlags
Flags	common/userpass.hpp	/^    enum Flags {$/;"	g	namespace:openvpn::UserPass
Flags	server/vpnservpool.hpp	/^      enum Flags {$/;"	g	class:openvpn::VPNServerPool::Pool
Follow	options/merge.hpp	/^    enum Follow {$/;"	g	class:openvpn::ProfileMerge
Forbidden	http/status.hpp	/^	Forbidden=403,$/;"	e	enum:openvpn::HTTP::Status::__anon45
Frame	frame/frame.hpp	/^    Frame() {}$/;"	f	class:openvpn::Frame
Frame	frame/frame.hpp	/^    explicit Frame(const Context& c) { set_default_context(c); }$/;"	f	class:openvpn::Frame
Frame	frame/frame.hpp	/^  class Frame : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
Function	common/function.hpp	/^  class Function<R(A...)>$/;"	c	namespace:openvpn
GET	http/method.hpp	/^	GET,$/;"	e	enum:openvpn::HTTP::Method::Type
GETOPT_BADARG	common/getopt.hpp	/^#define	GETOPT_BADARG	/;"	d
GETOPT_BADCH	common/getopt.hpp	/^#define	GETOPT_BADCH	/;"	d
GETOPT_EMSG	common/getopt.hpp	/^#define	GETOPT_EMSG	/;"	d
GET_CONFIG	client/clievent.hpp	/^      GET_CONFIG,$/;"	e	enum:openvpn::ClientEvent::Type
GROW	buffer/buffer.hpp	/^      GROW  = (1<<2),           \/\/ if enabled, buffer will grow (otherwise buffer_full exception will be thrown)$/;"	e	enum:openvpn::BufferAllocatedType::__anon14
Generic	applecrypto/cf/cf.hpp	/^    typedef Wrap<CFTypeRef> Generic;$/;"	t	namespace:openvpn::CF
GetConfig	client/clievent.hpp	/^      GetConfig() : Base(GET_CONFIG) {}$/;"	f	struct:openvpn::ClientEvent::GetConfig
GetConfig	client/clievent.hpp	/^    struct GetConfig : public Base$/;"	s	namespace:openvpn::ClientEvent
Glob	common/glob.hpp	/^    Glob(const std::string& pattern, const int flags)$/;"	f	class:openvpn::Glob
Glob	common/glob.hpp	/^  class Glob$/;"	c	namespace:openvpn
Green	ssl/datalimit.hpp	/^      Green=1,$/;"	e	enum:openvpn::DataLimit::State
Gremlin	transport/gremlin.hpp	/^  namespace Gremlin {$/;"	n	namespace:openvpn
HALT	server/servhalt.hpp	/^      HALT,             \/\/ disconnect$/;"	e	enum:openvpn::HaltRestart::Type
HANDSHAKE_TIMEOUT	error/error.hpp	/^      HANDSHAKE_TIMEOUT,   \/\/ handshake failed to complete within given time frame$/;"	e	enum:openvpn::Error::Type
HMAC	crypto/static_key.hpp	/^      HMAC = (1<<0),$/;"	e	enum:openvpn::OpenVPNStaticKey::__anon42
HMACContext	applecrypto/crypto/api.hpp	/^    typedef AppleCrypto::HMACContext HMACContext;$/;"	t	struct:openvpn::AppleCryptoAPI
HMACContext	applecrypto/crypto/hmac.hpp	/^      HMACContext()$/;"	f	class:openvpn::AppleCrypto::HMACContext
HMACContext	applecrypto/crypto/hmac.hpp	/^      HMACContext(const CryptoAlgs::Type digest, const unsigned char *key, const size_t key_size)$/;"	f	class:openvpn::AppleCrypto::HMACContext
HMACContext	applecrypto/crypto/hmac.hpp	/^    class HMACContext$/;"	c	namespace:openvpn::AppleCrypto
HMACContext	openssl/crypto/api.hpp	/^    typedef OpenSSLCrypto::HMACContext HMACContext;$/;"	t	struct:openvpn::OpenSSLCryptoAPI
HMACContext	openssl/crypto/hmac.hpp	/^      HMACContext()$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
HMACContext	openssl/crypto/hmac.hpp	/^      HMACContext(const CryptoAlgs::Type digest, const unsigned char *key, const size_t key_size)$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
HMACContext	openssl/crypto/hmac.hpp	/^    class HMACContext$/;"	c	namespace:openvpn::OpenSSLCrypto
HMACContext	polarssl/crypto/api.hpp	/^    typedef PolarSSLCrypto::HMACContext HMACContext;$/;"	t	struct:openvpn::PolarSSLCryptoAPI
HMACContext	polarssl/crypto/hmac.hpp	/^      HMACContext()$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
HMACContext	polarssl/crypto/hmac.hpp	/^      HMACContext(const CryptoAlgs::Type digest, const unsigned char *key, const size_t key_size)$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
HMACContext	polarssl/crypto/hmac.hpp	/^    class HMACContext$/;"	c	namespace:openvpn::PolarSSLCrypto
HMACInstance	crypto/digestapi.hpp	/^  class HMACInstance : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
HMAC_DEFINED	crypto/cryptodc.hpp	/^      HMAC_DEFINED=(1<<1),    \/\/ may call init_hmac method$/;"	e	enum:openvpn::CryptoDCInstance::__anon38
HMAC_ERROR	error/error.hpp	/^      HMAC_ERROR,          \/\/ HMAC verification failure$/;"	e	enum:openvpn::Error::Type
HOURLY	log/logperiod.hpp	/^      HOURLY,$/;"	e	enum:openvpn::LogPeriod::Period
HTMLSkip	http/htmlskip.hpp	/^      HTMLSkip()$/;"	f	class:openvpn::HTTP::HTMLSkip
HTMLSkip	http/htmlskip.hpp	/^    class HTMLSkip$/;"	c	namespace:openvpn::HTTP
HTTP	http/header.hpp	/^  namespace HTTP {$/;"	n	namespace:openvpn
HTTP	http/htmlskip.hpp	/^  namespace HTTP {$/;"	n	namespace:openvpn
HTTP	http/method.hpp	/^  namespace HTTP {$/;"	n	namespace:openvpn
HTTP	http/parseutil.hpp	/^  namespace HTTP {$/;"	n	namespace:openvpn
HTTP	http/reply.hpp	/^  namespace HTTP {$/;"	n	namespace:openvpn
HTTP	http/request.hpp	/^  namespace HTTP {$/;"	n	namespace:openvpn
HTTP	http/status.hpp	/^  namespace HTTP {$/;"	n	namespace:openvpn
HTTP	http/webexcept.hpp	/^  namespace HTTP {$/;"	n	namespace:openvpn
HTTPProxy	proxy/httpdigest.hpp	/^  namespace HTTPProxy {$/;"	n	namespace:openvpn
HTTPProxy	proxy/ntlm.hpp	/^  namespace HTTPProxy {$/;"	n	namespace:openvpn
HTTPProxy	proxy/proxyauth.hpp	/^  namespace HTTPProxy {$/;"	n	namespace:openvpn
HTTPProxyTransport	transport/client/httpcli.hpp	/^  namespace HTTPProxyTransport {$/;"	n	namespace:openvpn
HWADDR_DEFINED	tun/mac/gwv4.hpp	/^      HWADDR_DEFINED   = (1<<2), \/* set if hwaddr is defined *\/$/;"	e	enum:openvpn::MacGatewayInfoV4::__anon92
HaltRestart	server/servhalt.hpp	/^  namespace HaltRestart {$/;"	n	namespace:openvpn
Handle	win/handle.hpp	/^    namespace Handle {$/;"	n	namespace:openvpn::Win
Hash	common/hash.hpp	/^  namespace Hash {$/;"	n	namespace:openvpn
HashString	crypto/hashstr.hpp	/^    HashString(DigestFactory& digest_factory,$/;"	f	class:openvpn::HashString
HashString	crypto/hashstr.hpp	/^  class HashString$/;"	c	namespace:openvpn
Header	http/header.hpp	/^      Header() {}$/;"	f	struct:openvpn::HTTP::Header
Header	http/header.hpp	/^      Header(const std::string& name_arg, const std::string& value_arg)$/;"	f	struct:openvpn::HTTP::Header
Header	http/header.hpp	/^    struct Header {$/;"	s	namespace:openvpn::HTTP
HeaderList	http/header.hpp	/^    struct HeaderList : public std::vector<Header>$/;"	s	namespace:openvpn::HTTP
Host	common/hostlist.hpp	/^      Host() {}$/;"	f	struct:openvpn::HostList::Host
Host	common/hostlist.hpp	/^      Host(const std::string& host_arg, const std::string& port_arg)$/;"	f	struct:openvpn::HostList::Host
Host	common/hostlist.hpp	/^    struct Host$/;"	s	namespace:openvpn::HostList
HostList	common/hostlist.hpp	/^  namespace HostList {$/;"	n	namespace:openvpn
HostPort	common/hostport.hpp	/^  namespace HostPort {$/;"	n	namespace:openvpn
ICMP	ip/icmp.hpp	/^  struct ICMP {$/;"	s	namespace:openvpn
ICMP	ip/ip.hpp	/^      ICMP = 1, \/* ICMP protocol *\/$/;"	e	enum:openvpn::IPHeader::__anon51
IFACE_DEFINED	tun/mac/gwv4.hpp	/^      IFACE_DEFINED    = (1<<3), \/* set if iface is defined *\/$/;"	e	enum:openvpn::MacGatewayInfoV4::__anon92
IGMP	ip/ip.hpp	/^      IGMP = 2, \/* IGMP protocol *\/$/;"	e	enum:openvpn::IPHeader::__anon51
INACTIVE_TIMEOUT	client/clievent.hpp	/^      INACTIVE_TIMEOUT,$/;"	e	enum:openvpn::ClientEvent::Type
INACTIVE_TIMEOUT	error/error.hpp	/^      INACTIVE_TIMEOUT,    \/\/ disconnected due to inactive timer$/;"	e	enum:openvpn::Error::Type
INFO	client/clievent.hpp	/^      INFO,$/;"	e	enum:openvpn::ClientEvent::Type
INITIAL	http/htmlskip.hpp	/^	INITIAL,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
INITIAL_CAPACITY	buffer/safestr.hpp	/^    static constexpr size_t INITIAL_CAPACITY = 32;$/;"	m	class:openvpn::SafeString
INVALID_OPCODE	ssl/proto.hpp	/^      INVALID_OPCODE =              0,$/;"	e	enum:openvpn::ProtoContext::__anon80
INVERSE	crypto/static_key.hpp	/^      INVERSE = (1<<2)$/;"	e	enum:openvpn::OpenVPNStaticKey::__anon42
IN_WINDOW	reliable/relrecv.hpp	/^      IN_WINDOW = (1<<1)      \/\/ Packet is in-window (otherwise, packet is dropped)$/;"	e	enum:openvpn::ReliableRecvTemplate::__anon76
INotify	common/inotify.hpp	/^  namespace INotify {$/;"	n	namespace:openvpn
IP	addr/addrlist.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/addrpair.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/ip.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/iperr.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/ipv4.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/ipv6.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/pool.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/range.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/regex.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/route.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP	addr/routeinv.hpp	/^  namespace IP {$/;"	n	namespace:openvpn
IP46	server/vpnservpool.hpp	/^    struct IP46$/;"	s	namespace:openvpn::VPNServerPool
IP46AutoRelease	server/vpnservpool.hpp	/^      IP46AutoRelease(Pool* pool_arg)$/;"	f	class:openvpn::VPNServerPool::IP46AutoRelease
IP46AutoRelease	server/vpnservpool.hpp	/^    class IP46AutoRelease : public IP46, public RC<thread_safe_refcount>$/;"	c	namespace:openvpn::VPNServerPool
IPAdaptersInfo	tun/win/tunutil.hpp	/^	IPAdaptersInfo()$/;"	f	struct:openvpn::TunWin::Util::IPAdaptersInfo
IPAdaptersInfo	tun/win/tunutil.hpp	/^      struct IPAdaptersInfo$/;"	s	namespace:openvpn::TunWin::Util
IPHeader	ip/ip.hpp	/^  struct IPHeader$/;"	s	namespace:openvpn
IPNetmask4	tun/win/tunutil.hpp	/^	IPNetmask4() {}$/;"	f	struct:openvpn::TunWin::Util::IPNetmask4
IPNetmask4	tun/win/tunutil.hpp	/^	IPNetmask4(const IP_ADDR_STRING *ias)$/;"	f	struct:openvpn::TunWin::Util::IPNetmask4
IPNetmask4	tun/win/tunutil.hpp	/^	IPNetmask4(const TunBuilderCapture& pull, const char *title)$/;"	f	struct:openvpn::TunWin::Util::IPNetmask4
IPNetmask4	tun/win/tunutil.hpp	/^      struct IPNetmask4$/;"	s	namespace:openvpn::TunWin::Util
IPPerAdapterInfo	tun/win/tunutil.hpp	/^	IPPerAdapterInfo(const DWORD index)$/;"	f	struct:openvpn::TunWin::Util::IPPerAdapterInfo
IPPerAdapterInfo	tun/win/tunutil.hpp	/^      struct IPPerAdapterInfo$/;"	s	namespace:openvpn::TunWin::Util
IPVerFlags	client/ipverflags.hpp	/^    IPVerFlags(const OptionList& opt,$/;"	f	class:openvpn::IPVerFlags
IPVerFlags	client/ipverflags.hpp	/^  class IPVerFlags$/;"	c	namespace:openvpn
IPv4	addr/ipv4.hpp	/^  namespace IPv4 {$/;"	n	namespace:openvpn
IPv4_DEPLETION	server/vpnservpool.hpp	/^	IPv4_DEPLETION=(1<<0),$/;"	e	enum:openvpn::VPNServerPool::Pool::Flags
IPv6	addr/ipv6.hpp	/^  namespace IPv6 {$/;"	n	namespace:openvpn
IPv6Setting	tun/ipv6_setting.hpp	/^    IPv6Setting()$/;"	f	class:openvpn::IPv6Setting
IPv6Setting	tun/ipv6_setting.hpp	/^    explicit IPv6Setting(const Type t)$/;"	f	class:openvpn::IPv6Setting
IPv6Setting	tun/ipv6_setting.hpp	/^  class IPv6Setting$/;"	c	namespace:openvpn
IPv6_DEPLETION	server/vpnservpool.hpp	/^	IPv6_DEPLETION=(1<<1),$/;"	e	enum:openvpn::VPNServerPool::Pool::Flags
IV_LEN	openssl/crypto/ciphergcm.hpp	/^	IV_LEN = 12,$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContextGCM::__anon58
IV_LEN	polarssl/crypto/ciphergcm.hpp	/^	IV_LEN = 12,$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContextGCM::__anon70
InOut	common/redir.hpp	/^    struct InOut$/;"	s	class:openvpn::RedirectPipe
InactiveTimeout	client/clievent.hpp	/^      InactiveTimeout() : Base(INACTIVE_TIMEOUT) {}$/;"	f	struct:openvpn::ClientEvent::InactiveTimeout
InactiveTimeout	client/clievent.hpp	/^    struct InactiveTimeout : public Base$/;"	s	namespace:openvpn::ClientEvent
Index	client/remotelist.hpp	/^      Index()$/;"	f	class:openvpn::RemoteList::Index
Index	client/remotelist.hpp	/^    class Index$/;"	c	class:openvpn::RemoteList
IndexList	common/options.hpp	/^    typedef std::vector<unsigned int> IndexList;$/;"	t	class:openvpn::OptionList
IndexMap	common/options.hpp	/^    typedef std::unordered_map<std::string, IndexList> IndexMap;$/;"	t	class:openvpn::OptionList
IndexPair	common/options.hpp	/^    typedef std::pair<std::string, IndexList> IndexPair;$/;"	t	class:openvpn::OptionList
Info	client/clievent.hpp	/^      Info(std::string value) : ReasonBase(INFO, std::move(value)) {}$/;"	f	struct:openvpn::ClientEvent::Info
Info	client/clievent.hpp	/^    struct Info : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
Info	crypto/cryptodc.hpp	/^      Info() : cipher_alg(CryptoAlgs::NONE), hmac_alg(CryptoAlgs::NONE) {}$/;"	f	struct:openvpn::CryptoDCContext::Info
Info	crypto/cryptodc.hpp	/^    struct Info {$/;"	s	class:openvpn::CryptoDCContext
Info	tun/mac/macdns.hpp	/^      Info(CF::DynamicStore& sc, const std::string& sname)$/;"	f	class:openvpn::MacDNS::Info
Info	tun/mac/macdns.hpp	/^    class Info : public RC<thread_unsafe_refcount>$/;"	c	class:openvpn::MacDNS
Init	init/initprocess.hpp	/^      Init()$/;"	f	class:openvpn::InitProcess::Init
Init	init/initprocess.hpp	/^    class Init$/;"	c	namespace:openvpn::InitProcess
InitProcess	init/initprocess.hpp	/^  namespace InitProcess {$/;"	n	namespace:openvpn
InitialSeed	common/hash.hpp	/^      InitialSeed(std::size_t seed) : seed_(seed) {}$/;"	f	class:openvpn::Hash::InitialSeed
InitialSeed	common/hash.hpp	/^    class InitialSeed$/;"	c	namespace:openvpn::Hash
Input	win/console.hpp	/^	Input()$/;"	f	class:openvpn::Win::Console::Input
Input	win/console.hpp	/^      class Input$/;"	c	namespace:openvpn::Win::Console
InterfaceInfoList	tun/win/tunutil.hpp	/^	InterfaceInfoList()$/;"	f	struct:openvpn::TunWin::Util::InterfaceInfoList
InterfaceInfoList	tun/win/tunutil.hpp	/^      struct InterfaceInfoList$/;"	s	namespace:openvpn::TunWin::Util
Intern	common/function.hpp	/^    class Intern$/;"	c	class:openvpn::Function
InternalServerError	http/status.hpp	/^	InternalServerError=500,$/;"	e	enum:openvpn::HTTP::Status::__anon45
Internet	applecrypto/util/reachable.hpp	/^      Internet,$/;"	e	enum:openvpn::ReachabilityBase::Type
Item	client/remotelist.hpp	/^    struct Item : public RC<thread_unsafe_refcount>$/;"	s	class:openvpn::RemoteList
Item	openssl/pki/crl.hpp	/^      typedef CRL Item;$/;"	t	class:openvpn::OpenSSLPKI::CRLList
Item	openssl/pki/x509.hpp	/^      typedef X509 Item;$/;"	t	class:openvpn::OpenSSLPKI::X509List
Item	server/listenlist.hpp	/^    struct Item$/;"	s	namespace:openvpn::Listen
ItemPtr	openssl/pki/crl.hpp	/^      typedef CRLPtr ItemPtr;$/;"	t	class:openvpn::OpenSSLPKI::CRLList
ItemPtr	openssl/pki/x509.hpp	/^      typedef X509Ptr ItemPtr;$/;"	t	class:openvpn::OpenSSLPKI::X509List
Iter	common/action.hpp	/^      Iter(size_t size, const bool reverse)$/;"	f	class:openvpn::ActionList::Iter
Iter	common/action.hpp	/^    class Iter$/;"	c	class:openvpn::ActionList
Iterator	addr/range.hpp	/^	Iterator(const RangeType& range)$/;"	f	class:openvpn::IP::RangeType::Iterator
Iterator	addr/range.hpp	/^      class Iterator$/;"	c	class:openvpn::IP::RangeType
Iterator	common/hostlist.hpp	/^      Iterator()$/;"	f	class:openvpn::HostList::Iterator
Iterator	common/hostlist.hpp	/^    class Iterator$/;"	c	namespace:openvpn::HostList
KEEPALIVE_FIRST_BYTE	ssl/proto.hpp	/^	KEEPALIVE_FIRST_BYTE = 0x2a  \/\/ first byte of keepalive message$/;"	e	enum:openvpn::proto_context_private::__anon77::__anon78
KEEPALIVE_TIMEOUT	error/error.hpp	/^      KEEPALIVE_TIMEOUT,   \/\/ lost contact with peer$/;"	e	enum:openvpn::Error::Type
KEV_ACTIVE	ssl/proto.hpp	/^	KEV_ACTIVE,$/;"	e	enum:openvpn::ProtoContext::KeyContext::EventType
KEV_BECOME_PRIMARY	ssl/proto.hpp	/^	KEV_BECOME_PRIMARY,$/;"	e	enum:openvpn::ProtoContext::KeyContext::EventType
KEV_EXPIRE	ssl/proto.hpp	/^	KEV_EXPIRE,$/;"	e	enum:openvpn::ProtoContext::KeyContext::EventType
KEV_NEGOTIATE	ssl/proto.hpp	/^	KEV_NEGOTIATE,$/;"	e	enum:openvpn::ProtoContext::KeyContext::EventType
KEV_NEGOTIATE_ERROR	error/error.hpp	/^      KEV_NEGOTIATE_ERROR,$/;"	e	enum:openvpn::Error::Type
KEV_NONE	ssl/proto.hpp	/^	KEV_NONE,$/;"	e	enum:openvpn::ProtoContext::KeyContext::EventType
KEV_PENDING_ERROR	error/error.hpp	/^      KEV_PENDING_ERROR,$/;"	e	enum:openvpn::Error::Type
KEV_PRIMARY_PENDING	ssl/proto.hpp	/^	KEV_PRIMARY_PENDING,$/;"	e	enum:openvpn::ProtoContext::KeyContext::EventType
KEV_RENEGOTIATE	ssl/proto.hpp	/^	KEV_RENEGOTIATE,$/;"	e	enum:openvpn::ProtoContext::KeyContext::EventType
KEV_RENEGOTIATE_FORCE	ssl/proto.hpp	/^	KEV_RENEGOTIATE_FORCE,$/;"	e	enum:openvpn::ProtoContext::KeyContext::EventType
KEV_RENEGOTIATE_QUEUE	ssl/proto.hpp	/^	KEV_RENEGOTIATE_QUEUE,$/;"	e	enum:openvpn::ProtoContext::KeyContext::EventType
KEY_ID_MASK	ssl/proto.hpp	/^      KEY_ID_MASK =             0x07,$/;"	e	enum:openvpn::ProtoContext::__anon80
KEY_SIZE	crypto/static_key.hpp	/^      KEY_SIZE = 256 \/\/ bytes$/;"	e	enum:openvpn::OpenVPNStaticKey::__anon41
KEY_STATE_ERROR	error/error.hpp	/^      KEY_STATE_ERROR,     \/\/ Received packet didn't match expected key state$/;"	e	enum:openvpn::Error::Type
KUParse	ssl/kuparse.hpp	/^  namespace KUParse {$/;"	n	namespace:openvpn
Key	openssl/util/tokenencrypt.hpp	/^      Key(RandomAPI& rng)$/;"	f	struct:openvpn::TokenEncrypt::Key
Key	openssl/util/tokenencrypt.hpp	/^    struct Key$/;"	s	class:openvpn::TokenEncrypt
KeyContext	ssl/proto.hpp	/^      KeyContext(ProtoContext& p, const bool initiator)$/;"	f	class:openvpn::ProtoContext::KeyContext
KeyContext	ssl/proto.hpp	/^    class KeyContext : ProtoStackBase<Packet, KeyContext>, public RC<thread_unsafe_refcount>$/;"	c	class:openvpn::ProtoContext
KeyValue	common/options.hpp	/^      KeyValue() : key_priority(0) {}$/;"	f	class:openvpn::OptionList::KeyValue
KeyValue	common/options.hpp	/^      KeyValue(const std::string& key_arg, const std::string& value_arg, const int key_priority_arg=0)$/;"	f	class:openvpn::OptionList::KeyValue
KeyValue	common/options.hpp	/^    class KeyValue : public RC<thread_unsafe_refcount>$/;"	c	class:openvpn::OptionList
KeyValue	pki/x509track.hpp	/^      KeyValue(const Type type_arg,$/;"	f	struct:openvpn::X509Track::KeyValue
KeyValue	pki/x509track.hpp	/^    struct KeyValue$/;"	s	namespace:openvpn::X509Track
KeyValue	ssl/peerinfo.hpp	/^      KeyValue(const std::string& key_arg, const std::string& value_arg)$/;"	f	struct:openvpn::PeerInfo::KeyValue
KeyValue	ssl/peerinfo.hpp	/^    struct KeyValue$/;"	s	namespace:openvpn::PeerInfo
KeyValueList	common/options.hpp	/^    struct KeyValueList : public std::vector<KeyValue::Ptr>$/;"	s	class:openvpn::OptionList
L	pki/x509track.hpp	/^      L,$/;"	e	enum:openvpn::X509Track::Type
L2State	tun/win/client/tunsetup.hpp	/^	L2State(const Util::TapNameGuidPair& tap_arg,$/;"	f	struct:openvpn::TunWin::Setup::L2State
L2State	tun/win/client/tunsetup.hpp	/^      struct L2State$/;"	s	class:openvpn::TunWin::Setup
LAST_ACK_STATE	ssl/proto.hpp	/^      LAST_ACK_STATE=3, \/\/ all ACK states must be <= this value$/;"	e	enum:openvpn::ProtoContext::__anon80
LAST_OPCODE	ssl/proto.hpp	/^      LAST_OPCODE =                 9,$/;"	e	enum:openvpn::ProtoContext::__anon80
LEAF	addr/routeinv.hpp	/^	LEAF,$/;"	e	enum:openvpn::IP::RouteInverter::Type
LF_ALLOW_CLIENT_CERT_NOT_REQUIRED	ssl/sslapi.hpp	/^      LF_ALLOW_CLIENT_CERT_NOT_REQUIRED = (1<<1),$/;"	e	enum:openvpn::SSLConfigAPI::LoadFlags
LF_PARSE_MODE	ssl/sslapi.hpp	/^      LF_PARSE_MODE = (1<<0),$/;"	e	enum:openvpn::SSLConfigAPI::LoadFlags
LOAD_COMMON_CLIENT	ssl/proto.hpp	/^	LOAD_COMMON_CLIENT,$/;"	e	enum:openvpn::ProtoContext::Config::LoadCommonType
LOAD_COMMON_CLIENT_PUSHED	ssl/proto.hpp	/^	LOAD_COMMON_CLIENT_PUSHED,$/;"	e	enum:openvpn::ProtoContext::Config::LoadCommonType
LOAD_COMMON_SERVER	ssl/proto.hpp	/^	LOAD_COMMON_SERVER,$/;"	e	enum:openvpn::ProtoContext::Config::LoadCommonType
LOG_VERIFY_STATUS	ssl/sslconsts.hpp	/^      LOG_VERIFY_STATUS=(1<<0),$/;"	e	enum:openvpn::SSLConst::__anon84
LONG_FORM	crypto/packet_id.hpp	/^      LONG_FORM = 1,  \/\/ long form of ID (8 bytes)$/;"	e	enum:openvpn::PacketID::__anon39
LZ4	compress/compress.hpp	/^      LZ4,$/;"	e	enum:openvpn::CompressContext::Type
LZ4_COMPRESS	compress/lz4.hpp	/^      LZ4_COMPRESS = 0x69,$/;"	e	enum:openvpn::CompressLZ4::__anon32
LZ4v2	compress/compress.hpp	/^      LZ4v2,$/;"	e	enum:openvpn::CompressContext::Type
LZO	compress/compress.hpp	/^      LZO,$/;"	e	enum:openvpn::CompressContext::Type
LZOASYM_ASSERT	compress/lzoasym_impl.hpp	/^#define LZOASYM_ASSERT(/;"	d
LZOASYM_ASSERT	compress/lzoasym_impl.hpp	/^#undef LZOASYM_ASSERT$/;"	d
LZOASYM_CHECK_INPUT_OVERFLOW	compress/lzoasym_impl.hpp	/^#define LZOASYM_CHECK_INPUT_OVERFLOW(/;"	d
LZOASYM_CHECK_INPUT_OVERFLOW	compress/lzoasym_impl.hpp	/^#undef LZOASYM_CHECK_INPUT_OVERFLOW$/;"	d
LZOASYM_CHECK_MATCH_OVERFLOW	compress/lzoasym_impl.hpp	/^#define LZOASYM_CHECK_MATCH_OVERFLOW(/;"	d
LZOASYM_CHECK_MATCH_OVERFLOW	compress/lzoasym_impl.hpp	/^#undef LZOASYM_CHECK_MATCH_OVERFLOW$/;"	d
LZOASYM_CHECK_OUTPUT_OVERFLOW	compress/lzoasym_impl.hpp	/^#define LZOASYM_CHECK_OUTPUT_OVERFLOW(/;"	d
LZOASYM_CHECK_OUTPUT_OVERFLOW	compress/lzoasym_impl.hpp	/^#undef LZOASYM_CHECK_OUTPUT_OVERFLOW$/;"	d
LZOASYM_EOF_CODE	compress/lzoasym_impl.hpp	/^      LZOASYM_EOF_CODE=1,$/;"	e	enum:openvpn::lzo_asym_impl::__anon36
LZOASYM_E_ASSERT_FAILED	compress/lzoasym_impl.hpp	/^      LZOASYM_E_ASSERT_FAILED=-6,$/;"	e	enum:openvpn::lzo_asym_impl::__anon35
LZOASYM_E_EOF_NOT_FOUND	compress/lzoasym_impl.hpp	/^      LZOASYM_E_EOF_NOT_FOUND=-1,$/;"	e	enum:openvpn::lzo_asym_impl::__anon35
LZOASYM_E_INPUT_NOT_CONSUMED	compress/lzoasym_impl.hpp	/^      LZOASYM_E_INPUT_NOT_CONSUMED=-2,$/;"	e	enum:openvpn::lzo_asym_impl::__anon35
LZOASYM_E_INPUT_OVERFLOW	compress/lzoasym_impl.hpp	/^      LZOASYM_E_INPUT_OVERFLOW=-3,$/;"	e	enum:openvpn::lzo_asym_impl::__anon35
LZOASYM_E_INPUT_TOO_LARGE	compress/lzoasym_impl.hpp	/^      LZOASYM_E_INPUT_TOO_LARGE=-7,$/;"	e	enum:openvpn::lzo_asym_impl::__anon35
LZOASYM_E_MATCH_OVERFLOW	compress/lzoasym_impl.hpp	/^      LZOASYM_E_MATCH_OVERFLOW=-5,$/;"	e	enum:openvpn::lzo_asym_impl::__anon35
LZOASYM_E_OK	compress/lzoasym_impl.hpp	/^      LZOASYM_E_OK=0,$/;"	e	enum:openvpn::lzo_asym_impl::__anon35
LZOASYM_E_OUTPUT_OVERFLOW	compress/lzoasym_impl.hpp	/^      LZOASYM_E_OUTPUT_OVERFLOW=-4,$/;"	e	enum:openvpn::lzo_asym_impl::__anon35
LZOASYM_LIKELY	compress/lzoasym_impl.hpp	/^# define LZOASYM_LIKELY(/;"	d
LZOASYM_LIKELY	compress/lzoasym_impl.hpp	/^#undef LZOASYM_LIKELY$/;"	d
LZOASYM_M2_MAX_OFFSET	compress/lzoasym_impl.hpp	/^      LZOASYM_M2_MAX_OFFSET=0x0800,$/;"	e	enum:openvpn::lzo_asym_impl::__anon36
LZOASYM_UNLIKELY	compress/lzoasym_impl.hpp	/^# define LZOASYM_UNLIKELY(/;"	d
LZOASYM_UNLIKELY	compress/lzoasym_impl.hpp	/^#undef LZOASYM_UNLIKELY$/;"	d
LZO_COMPRESS	compress/lzo.hpp	/^      LZO_COMPRESS = 0x66,$/;"	e	enum:openvpn::CompressLZO::__anon33
LZO_COMPRESS	compress/lzoasym.hpp	/^      LZO_COMPRESS = 0x66,$/;"	e	enum:openvpn::CompressLZOAsym::__anon34
LZO_COMPRESS_SWAP	compress/lzo.hpp	/^      LZO_COMPRESS_SWAP = 0x67,$/;"	e	enum:openvpn::CompressLZO::__anon33
LZO_COMPRESS_SWAP	compress/lzoasym.hpp	/^      LZO_COMPRESS_SWAP = 0x67,$/;"	e	enum:openvpn::CompressLZOAsym::__anon34
LZO_STUB	compress/compress.hpp	/^      LZO_STUB,$/;"	e	enum:openvpn::CompressContext::Type
LZO_SWAP	compress/compress.hpp	/^      LZO_SWAP,$/;"	e	enum:openvpn::CompressContext::Type
LastError	win/winerr.hpp	/^      LastError()$/;"	f	struct:openvpn::Win::LastError
LastError	win/winerr.hpp	/^    struct LastError : public Error$/;"	s	namespace:openvpn::Win
Layer	tun/layer.hpp	/^    Layer() : type_(NONE) {}$/;"	f	class:openvpn::Layer
Layer	tun/layer.hpp	/^    explicit Layer(const Type t) : type_(t) {}$/;"	f	class:openvpn::Layer
Layer	tun/layer.hpp	/^  class Layer$/;"	c	namespace:openvpn
Lex	common/options.hpp	/^    typedef StandardLex Lex;$/;"	t	class:openvpn::OptionList
LexComment	common/options.hpp	/^      LexComment() : in_quote_(false), in_comment(false), backslash(false), ch(-1) {}$/;"	f	class:openvpn::OptionList::LexComment
LexComment	common/options.hpp	/^    class LexComment$/;"	c	class:openvpn::OptionList
Limits	common/options.hpp	/^      Limits(const std::string& error_message,$/;"	f	class:openvpn::OptionList::Limits
Limits	common/options.hpp	/^    class Limits$/;"	c	class:openvpn::OptionList
Link	common/link.hpp	/^    Link() {}$/;"	f	class:openvpn::Link
Link	common/link.hpp	/^    Link(SEND* send_arg) : send(send_arg) {}$/;"	f	class:openvpn::Link
Link	common/link.hpp	/^    Link(const typename SEND::Ptr& send_arg) : send(send_arg) {}$/;"	f	class:openvpn::Link
Link	common/link.hpp	/^  class Link : public RECV$/;"	c	namespace:openvpn
Link	transport/tcplink.hpp	/^      Link(ReadHandler read_handler_arg,$/;"	f	class:openvpn::TCPTransport::Link
Link	transport/tcplink.hpp	/^    class Link : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::TCPTransport
Link	transport/udplink.hpp	/^      Link(ReadHandler read_handler_arg,$/;"	f	class:openvpn::UDPTransport::Link
Link	transport/udplink.hpp	/^    class Link : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::UDPTransport
LinkImpl	transport/client/httpcli.hpp	/^      typedef TCPTransport::Link<asio::ip::tcp, Client*, false> LinkImpl;$/;"	t	class:openvpn::HTTPProxyTransport::Client
LinkImpl	transport/client/tcpcli.hpp	/^      typedef Link<asio::ip::tcp, Client*, false> LinkImpl;$/;"	t	class:openvpn::TCPTransport::Client
LinkImpl	transport/client/udpcli.hpp	/^      typedef Link<Client*> LinkImpl;$/;"	t	class:openvpn::UDPTransport::Client
List	common/hostlist.hpp	/^      List() {}$/;"	f	class:openvpn::HostList::List
List	common/hostlist.hpp	/^      List(const OptionList& opt,$/;"	f	class:openvpn::HostList::List
List	common/hostlist.hpp	/^    class List : public std::vector<Host>$/;"	c	namespace:openvpn::HostList
List	server/listenlist.hpp	/^      List() {}$/;"	f	class:openvpn::Listen::List
List	server/listenlist.hpp	/^      List(Item&& item)$/;"	f	class:openvpn::Listen::List
List	server/listenlist.hpp	/^      List(const Item& item)$/;"	f	class:openvpn::Listen::List
List	server/listenlist.hpp	/^      List(const OptionList& opt,$/;"	f	class:openvpn::Listen::List
List	server/listenlist.hpp	/^    class List : public std::vector<Item>$/;"	c	namespace:openvpn::Listen
ListHead	common/rc.hpp	/^    class ListHead$/;"	c	class:openvpn::thread_safe_refcount
ListHead	common/rc.hpp	/^    class ListHead$/;"	c	class:openvpn::thread_unsafe_refcount
Listen	server/listenlist.hpp	/^  namespace Listen {$/;"	n	namespace:openvpn
LoadCommonType	ssl/proto.hpp	/^      enum LoadCommonType {$/;"	g	class:openvpn::ProtoContext::Config
LoadFlags	ssl/sslapi.hpp	/^    enum LoadFlags {$/;"	g	class:openvpn::SSLConfigAPI
LoadMode	server/listenlist.hpp	/^      enum LoadMode {$/;"	g	class:openvpn::Listen::List
Log	log/logsimple.hpp	/^  namespace Log {$/;"	n	namespace:openvpn
Log	log/logthread.hpp	/^  namespace Log {$/;"	n	namespace:openvpn
LogBase	log/logbase.hpp	/^  struct LogBase$/;"	s	namespace:openvpn
LogBaseSimple	log/logbasesimple.hpp	/^    LogBaseSimple()$/;"	f	class:openvpn::LogBaseSimple
LogBaseSimple	log/logbasesimple.hpp	/^  class LogBaseSimple : public LogBase$/;"	c	namespace:openvpn
LogPeriod	log/logperiod.hpp	/^    LogPeriod()$/;"	f	class:openvpn::LogPeriod
LogPeriod	log/logperiod.hpp	/^    LogPeriod(const LogPeriod& other, const int index)$/;"	f	class:openvpn::LogPeriod
LogPeriod	log/logperiod.hpp	/^    LogPeriod(const Period period, const time_t base)$/;"	f	class:openvpn::LogPeriod
LogPeriod	log/logperiod.hpp	/^  class LogPeriod$/;"	c	namespace:openvpn
MACAddr	addr/macaddr.hpp	/^    MACAddr()$/;"	f	class:openvpn::MACAddr
MACAddr	addr/macaddr.hpp	/^    MACAddr(const unsigned char *addr)$/;"	f	class:openvpn::MACAddr
MACAddr	addr/macaddr.hpp	/^  class MACAddr {$/;"	c	namespace:openvpn
MATCH	http/htmlskip.hpp	/^	MATCH,$/;"	e	enum:openvpn::HTTP::HTMLSkip::Status
MAX_CIPHERTEXT_IN	applecrypto/ssl/sslctx.hpp	/^      MAX_CIPHERTEXT_IN = 64$/;"	e	enum:openvpn::AppleSSLContext::__anon13
MAX_CIPHERTEXT_IN	openssl/ssl/sslctx.hpp	/^      MAX_CIPHERTEXT_IN = 64 \/\/ maximum number of queued input ciphertext packets$/;"	e	enum:openvpn::OpenSSLContext::__anon61
MAX_CIPHERTEXT_IN	polarssl/ssl/sslctx.hpp	/^      MAX_CIPHERTEXT_IN = 64 \/\/ maximum number of queued input ciphertext packets$/;"	e	enum:openvpn::PolarSSLContext::__anon74
MAX_DIGEST_SIZE	applecrypto/crypto/digest.hpp	/^	MAX_DIGEST_SIZE = CC_SHA512_DIGEST_LENGTH \/\/ largest known is SHA512$/;"	e	enum:openvpn::AppleCrypto::DigestContext::__anon11
MAX_DIGEST_SIZE	openssl/crypto/digest.hpp	/^	MAX_DIGEST_SIZE = EVP_MAX_MD_SIZE$/;"	e	enum:openvpn::OpenSSLCrypto::DigestContext::__anon59
MAX_DIGEST_SIZE	polarssl/crypto/digest.hpp	/^	MAX_DIGEST_SIZE = POLARSSL_MD_MAX_SIZE$/;"	e	enum:openvpn::PolarSSLCrypto::DigestContext::__anon71
MAX_DIRECTIVE_SIZE	client/cliconstants.hpp	/^      MAX_DIRECTIVE_SIZE=64,   \/\/ maximum number of chars in an OpenVPN directive$/;"	e	enum:openvpn::ProfileParseLimits::__anon15
MAX_ERRORS	openssl/util/error.hpp	/^      MAX_ERRORS = 8$/;"	e	enum:openvpn::OpenSSLException::__anon62
MAX_FN_LIST_SIZE	options/merge.hpp	/^      MAX_FN_LIST_SIZE=16,$/;"	e	enum:openvpn::ProfileMerge::__anon65
MAX_HMAC_KEY_SIZE	applecrypto/crypto/hmac.hpp	/^	MAX_HMAC_KEY_SIZE = 128,$/;"	e	enum:openvpn::AppleCrypto::HMACContext::__anon12
MAX_HMAC_SIZE	applecrypto/crypto/hmac.hpp	/^	MAX_HMAC_SIZE = DigestContext::MAX_DIGEST_SIZE,$/;"	e	enum:openvpn::AppleCrypto::HMACContext::__anon12
MAX_HMAC_SIZE	openssl/crypto/hmac.hpp	/^	MAX_HMAC_SIZE = EVP_MAX_MD_SIZE$/;"	e	enum:openvpn::OpenSSLCrypto::HMACContext::__anon60
MAX_HMAC_SIZE	polarssl/crypto/hmac.hpp	/^	MAX_HMAC_SIZE = POLARSSL_MD_MAX_SIZE$/;"	e	enum:openvpn::PolarSSLCrypto::HMACContext::__anon72
MAX_IV_LENGTH	applecrypto/crypto/cipher.hpp	/^	MAX_IV_LENGTH = 16,$/;"	e	enum:openvpn::AppleCrypto::CipherContext::__anon8
MAX_IV_LENGTH	openssl/crypto/cipher.hpp	/^	MAX_IV_LENGTH = EVP_MAX_IV_LENGTH,$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContext::__anon56
MAX_IV_LENGTH	polarssl/crypto/cipher.hpp	/^	MAX_IV_LENGTH = POLARSSL_MAX_IV_LENGTH,$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContext::__anon68
MAX_LINE_SIZE	client/cliconstants.hpp	/^      MAX_LINE_SIZE=512,       \/\/ maximum size of an OpenVPN configuration file line$/;"	e	enum:openvpn::ProfileParseLimits::__anon15
MAX_PROFILE_SIZE	client/cliconstants.hpp	/^      MAX_PROFILE_SIZE=262144, \/\/ maximum size of an OpenVPN configuration file$/;"	e	enum:openvpn::ProfileParseLimits::__anon15
MAX_PUSH_SIZE	client/cliconstants.hpp	/^      MAX_PUSH_SIZE=262144,    \/\/ maximum size of aggregate data that can be pushed to a client$/;"	e	enum:openvpn::ProfileParseLimits::__anon15
MAX_ROUTE_METRIC	tun/client/tunprop.hpp	/^    static constexpr int MAX_ROUTE_METRIC = 1000000;$/;"	m	class:openvpn::TunProp
MD2	pki/pkcs1.hpp	/^	const unsigned char MD2[] = { 0x30, 0x20, 0x30, 0x0c, 0x06, 0x08,$/;"	m	namespace:openvpn::PKCS1::DigestPrefix::__anon66
MD4	crypto/cryptoalgs.hpp	/^      MD4,$/;"	e	enum:openvpn::CryptoAlgs::Type
MD5	crypto/cryptoalgs.hpp	/^      MD5,$/;"	e	enum:openvpn::CryptoAlgs::Type
MD5	pki/pkcs1.hpp	/^	const unsigned char MD5[] = { 0x30, 0x20, 0x30, 0x0c, 0x06, 0x08,$/;"	m	namespace:openvpn::PKCS1::DigestPrefix::__anon66
MERGE_EXCEPTION	options/merge.hpp	/^      MERGE_EXCEPTION,$/;"	e	enum:openvpn::ProfileMerge::Status
MERGE_MULTIPLE_REF_FAIL	options/merge.hpp	/^      MERGE_MULTIPLE_REF_FAIL,$/;"	e	enum:openvpn::ProfileMerge::Status
MERGE_OVPN_EXT_FAIL	options/merge.hpp	/^      MERGE_OVPN_EXT_FAIL,$/;"	e	enum:openvpn::ProfileMerge::Status
MERGE_OVPN_FILE_FAIL	options/merge.hpp	/^      MERGE_OVPN_FILE_FAIL,$/;"	e	enum:openvpn::ProfileMerge::Status
MERGE_REF_FAIL	options/merge.hpp	/^      MERGE_REF_FAIL,$/;"	e	enum:openvpn::ProfileMerge::Status
MERGE_SUCCESS	options/merge.hpp	/^      MERGE_SUCCESS,$/;"	e	enum:openvpn::ProfileMerge::Status
MERGE_UNDEFINED	options/merge.hpp	/^      MERGE_UNDEFINED,$/;"	e	enum:openvpn::ProfileMerge::Status
MODE_ALL	common/redir.hpp	/^    static constexpr mode_t MODE_ALL = 0777;$/;"	m	class:openvpn::RedirectStd
MODE_MASK	crypto/cryptoalgs.hpp	/^      MODE_MASK=0x03,$/;"	e	enum:openvpn::CryptoAlgs::Mode
MODE_UNDEF	applecrypto/crypto/cipher.hpp	/^	MODE_UNDEF = -1,$/;"	e	enum:openvpn::AppleCrypto::CipherContext::__anon7
MODE_UNDEF	crypto/cryptoalgs.hpp	/^      MODE_UNDEF=0,$/;"	e	enum:openvpn::CryptoAlgs::Mode
MODE_UNDEF	openssl/crypto/cipher.hpp	/^	MODE_UNDEF = -1,$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContext::__anon55
MODE_UNDEF	openssl/crypto/ciphergcm.hpp	/^	MODE_UNDEF = -1,$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContextGCM::__anon57
MODE_UNDEF	polarssl/crypto/cipher.hpp	/^	MODE_UNDEF = POLARSSL_OPERATION_NONE,$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContext::__anon67
MODE_UNDEF	polarssl/crypto/ciphergcm.hpp	/^	MODE_UNDEF = POLARSSL_OPERATION_NONE,$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContextGCM::__anon69
MODE_USER	common/redir.hpp	/^    static constexpr mode_t MODE_USER = S_IRUSR | S_IWUSR;$/;"	m	class:openvpn::RedirectStd
MODE_USER_GROUP	common/redir.hpp	/^    static constexpr mode_t MODE_USER_GROUP = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;$/;"	m	class:openvpn::RedirectStd
MSSCtrlParms	ssl/mssparms.hpp	/^    MSSCtrlParms(const OptionList& opt)$/;"	f	struct:openvpn::MSSCtrlParms
MSSCtrlParms	ssl/mssparms.hpp	/^  struct MSSCtrlParms$/;"	s	namespace:openvpn
MSSParms	ssl/mssparms.hpp	/^    MSSParms() : mssfix(0),$/;"	f	struct:openvpn::MSSParms
MSSParms	ssl/mssparms.hpp	/^  struct MSSParms$/;"	s	namespace:openvpn
MTRand	random/mtrandapi.hpp	/^    MTRand()$/;"	f	class:openvpn::MTRand
MTRand	random/mtrandapi.hpp	/^    MTRand(RandomAPI& seed)$/;"	f	class:openvpn::MTRand
MTRand	random/mtrandapi.hpp	/^  class MTRand : public RandomAPI$/;"	c	namespace:openvpn
MT_IFACE	tun/win/client/tunsetup.hpp	/^	MT_IFACE,$/;"	e	enum:openvpn::TunWin::Setup::MetricType
MT_NETSH	tun/win/client/tunsetup.hpp	/^	MT_NETSH,$/;"	e	enum:openvpn::TunWin::Setup::MetricType
MT_ROUTE	tun/win/client/tunsetup.hpp	/^	MT_ROUTE,$/;"	e	enum:openvpn::TunWin::Setup::MetricType
MULTILINE	common/options.hpp	/^      MULTILINE = 0x8000000,$/;"	e	enum:openvpn::Option::__anon21
Mac	apple/macver.hpp	/^  namespace Mac {$/;"	n	namespace:openvpn
MacDNS	tun/mac/macdns.hpp	/^    MacDNS(const std::string& sname_arg)$/;"	f	class:openvpn::MacDNS
MacDNS	tun/mac/macdns.hpp	/^  class MacDNS : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
MacDNSWatchdog	tun/mac/macdns_watchdog.hpp	/^    MacDNSWatchdog()$/;"	f	class:openvpn::MacDNSWatchdog
MacDNSWatchdog	tun/mac/macdns_watchdog.hpp	/^  class MacDNSWatchdog : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
MacGWInfo	tun/mac/macgw.hpp	/^    MacGWInfo()$/;"	f	struct:openvpn::MacGWInfo
MacGWInfo	tun/mac/macgw.hpp	/^  struct MacGWInfo$/;"	s	namespace:openvpn
MacGatewayInfoV4	tun/mac/gwv4.hpp	/^    MacGatewayInfoV4()$/;"	f	class:openvpn::MacGatewayInfoV4
MacGatewayInfoV4	tun/mac/gwv4.hpp	/^  class MacGatewayInfoV4$/;"	c	namespace:openvpn
MacLifeCycle	apple/maclife.hpp	/^    MacLifeCycle()$/;"	f	class:openvpn::MacLifeCycle
MacLifeCycle	apple/maclife.hpp	/^  class MacLifeCycle : public ClientLifeCycle, MacSleep, ReachabilityTracker$/;"	c	namespace:openvpn
MacSleep	apple/macsleep.hpp	/^    MacSleep()$/;"	f	class:openvpn::MacSleep
MacSleep	apple/macsleep.hpp	/^  class MacSleep$/;"	c	namespace:openvpn
ManClientInstanceFactory	server/manage.hpp	/^  struct ManClientInstanceFactory : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
ManClientInstanceRecv	server/manage.hpp	/^  struct ManClientInstanceRecv : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
ManClientInstanceSend	server/manage.hpp	/^  struct ManClientInstanceSend : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
ManLink	server/servproto.hpp	/^    typedef Link<ManClientInstanceSend, ManClientInstanceRecv> ManLink;$/;"	t	class:openvpn::ServerProto
MemQ	openssl/bio/bio_memq_dgram.hpp	/^      MemQ()$/;"	f	class:openvpn::bmq_dgram::MemQ
MemQ	openssl/bio/bio_memq_dgram.hpp	/^    class MemQ : public MemQDgram {$/;"	c	namespace:openvpn::bmq_dgram
MemQ	openssl/bio/bio_memq_stream.hpp	/^      MemQ() {}$/;"	f	class:openvpn::bmq_stream::MemQ
MemQ	openssl/bio/bio_memq_stream.hpp	/^    class MemQ : public MemQStream {$/;"	c	namespace:openvpn::bmq_stream
MemQBase	buffer/memq.hpp	/^    MemQBase() : length(0) {}$/;"	f	class:openvpn::MemQBase
MemQBase	buffer/memq.hpp	/^  class MemQBase$/;"	c	namespace:openvpn
MemQDgram	frame/memq_dgram.hpp	/^    MemQDgram() {}$/;"	f	class:openvpn::MemQDgram
MemQDgram	frame/memq_dgram.hpp	/^    explicit MemQDgram(const Frame::Ptr& frame) : frame_(frame) {}$/;"	f	class:openvpn::MemQDgram
MemQDgram	frame/memq_dgram.hpp	/^  class MemQDgram : public MemQBase {$/;"	c	namespace:openvpn
MemQStream	frame/memq_stream.hpp	/^    MemQStream() {}$/;"	f	class:openvpn::MemQStream
MemQStream	frame/memq_stream.hpp	/^    explicit MemQStream(const Frame::Ptr& frame) : frame_(frame) {}$/;"	f	class:openvpn::MemQStream
MemQStream	frame/memq_stream.hpp	/^  class MemQStream : public MemQBase {$/;"	c	namespace:openvpn
Message	reliable/relrecv.hpp	/^    class Message : public ReliableMessageBase<PACKET>$/;"	c	class:openvpn::ReliableRecvTemplate
Message	reliable/relsend.hpp	/^    class Message : public ReliableMessageBase<PACKET>$/;"	c	class:openvpn::ReliableSendTemplate
MessageWindow	common/msgwin.hpp	/^    MessageWindow()$/;"	f	class:openvpn::MessageWindow
MessageWindow	common/msgwin.hpp	/^    MessageWindow(const id_t starting_head_id, const id_t span)$/;"	f	class:openvpn::MessageWindow
MessageWindow	common/msgwin.hpp	/^  class MessageWindow$/;"	c	namespace:openvpn
Method	http/method.hpp	/^    namespace Method {$/;"	n	namespace:openvpn::HTTP
Methods	common/function.hpp	/^    struct Methods$/;"	s	class:openvpn::Function
MetricType	tun/win/client/tunsetup.hpp	/^      enum MetricType {$/;"	g	class:openvpn::TunWin::Setup
Mode	common/mode.hpp	/^    Mode() : type_(CLIENT) {}$/;"	f	class:openvpn::Mode
Mode	common/mode.hpp	/^    explicit Mode(const Type t) : type_(t) {}$/;"	f	class:openvpn::Mode
Mode	common/mode.hpp	/^  class Mode$/;"	c	namespace:openvpn
Mode	crypto/cryptoalgs.hpp	/^    enum Mode {$/;"	g	namespace:openvpn::CryptoAlgs
Mode	ssl/datalimit.hpp	/^    enum Mode {$/;"	g	class:openvpn::DataLimit
N	auth/authcert.hpp	/^	  N$/;"	e	enum:openvpn::AuthCert::Fail::Type
N	common/function.hpp	/^    static constexpr size_t N = 3; \/\/ max size of functor in machine words$/;"	m	class:openvpn::Function
NETMASK_DEFINED	tun/mac/gwv4.hpp	/^      NETMASK_DEFINED  = (1<<1), \/* set if gateway.netmask defined *\/$/;"	e	enum:openvpn::MacGatewayInfoV4::__anon92
NETWORK_CONNECTIONS	tun/win/tunutil.hpp	/^	const char NETWORK_CONNECTIONS[] = NETWORK_CONNECTIONS_KEY; \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::TunWin::Util::__anon94
NETWORK_EOF_ERROR	error/error.hpp	/^      NETWORK_EOF_ERROR,   \/\/ EOF received on TCP network socket$/;"	e	enum:openvpn::Error::Type
NETWORK_RECV_ERROR	error/error.hpp	/^      NETWORK_RECV_ERROR,  \/\/ errors receiving on network socket$/;"	e	enum:openvpn::Error::Type
NETWORK_SEND_ERROR	error/error.hpp	/^      NETWORK_SEND_ERROR,  \/\/ errors sending on network socket$/;"	e	enum:openvpn::Error::Type
NETWORK_UNAVAILABLE	error/error.hpp	/^      NETWORK_UNAVAILABLE, \/\/ network unavailable$/;"	e	enum:openvpn::Error::Type
NET_SEND_ACK	ssl/protostack.hpp	/^      NET_SEND_ACK,$/;"	e	enum:openvpn::ProtoStackBase::NetSendType
NET_SEND_RAW	ssl/protostack.hpp	/^      NET_SEND_RAW,$/;"	e	enum:openvpn::ProtoStackBase::NetSendType
NET_SEND_RETRANSMIT	ssl/protostack.hpp	/^      NET_SEND_RETRANSMIT,$/;"	e	enum:openvpn::ProtoStackBase::NetSendType
NET_SEND_SSL	ssl/protostack.hpp	/^      NET_SEND_SSL,$/;"	e	enum:openvpn::ProtoStackBase::NetSendType
NEW_SECONDARY	crypto/cryptodc.hpp	/^      NEW_SECONDARY,$/;"	e	enum:openvpn::CryptoDCInstance::RekeyType
NO	tun/ipv6_setting.hpp	/^      NO,$/;"	e	enum:openvpn::IPv6Setting::Type
NOMATCH	http/htmlskip.hpp	/^	NOMATCH,$/;"	e	enum:openvpn::HTTP::HTMLSkip::Status
NONE	compress/compress.hpp	/^      NONE,$/;"	e	enum:openvpn::CompressContext::Type
NONE	crypto/cryptoalgs.hpp	/^      NONE=0,$/;"	e	enum:openvpn::CryptoAlgs::Type
NONE	ssl/nscert.hpp	/^      NONE,$/;"	e	enum:openvpn::NSCert::Type
NONE	transport/protocol.hpp	/^      NONE,$/;"	e	enum:openvpn::Protocol::Type
NONE	tun/layer.hpp	/^      NONE,$/;"	e	enum:openvpn::Layer::Type
NONFATAL_ERROR_START	client/clievent.hpp	/^      NONFATAL_ERROR_START = TRANSPORT_ERROR, \/\/ start of nonfatal errors that automatically reconnect$/;"	e	enum:openvpn::ClientEvent::__anon16
NORMAL	crypto/static_key.hpp	/^      NORMAL = 0,$/;"	e	enum:openvpn::OpenVPNStaticKey::__anon42
NO_COMPRESS	compress/compress.hpp	/^      NO_COMPRESS      = 0xFA,$/;"	e	enum:openvpn::Compress::__anon30
NO_COMPRESS_SWAP	compress/compress.hpp	/^      NO_COMPRESS_SWAP = 0xFB, \/\/ for better alignment handling, replace this byte with last byte of packet$/;"	e	enum:openvpn::Compress::__anon30
NO_HMAC_ALG	applecrypto/crypto/digest.hpp	/^	NO_HMAC_ALG = -1$/;"	e	enum:openvpn::AppleCrypto::DigestInfo::__anon10
NO_SUFFIX	transport/protocol.hpp	/^      NO_SUFFIX,$/;"	e	enum:openvpn::Protocol::AllowSuffix
NO_VERIFY_PEER	ssl/sslconsts.hpp	/^      NO_VERIFY_PEER=(1<<1),$/;"	e	enum:openvpn::SSLConst::__anon84
NRPT	tun/win/nrpt.hpp	/^    class NRPT$/;"	c	namespace:openvpn::TunWin
NSCert	ssl/nscert.hpp	/^  namespace NSCert {$/;"	n	namespace:openvpn
NTLM	proxy/ntlm.hpp	/^    class NTLM$/;"	c	namespace:openvpn::HTTPProxy
N_ALIGN_CONTEXTS	frame/frame.hpp	/^      N_ALIGN_CONTEXTS$/;"	e	enum:openvpn::Frame::__anon44
N_ERRORS	error/error.hpp	/^      N_ERRORS,$/;"	e	enum:openvpn::Error::Type
N_KEV_EXPIRE	error/error.hpp	/^      N_KEV_EXPIRE,$/;"	e	enum:openvpn::Error::Type
N_KEY_LIMIT_RENEG	error/error.hpp	/^      N_KEY_LIMIT_RENEG,   \/\/ Number of renegotiations triggered by per-key limits such as data or packet limits$/;"	e	enum:openvpn::Error::Type
N_PAUSE	error/error.hpp	/^      N_PAUSE,             \/\/ Number of transitions to Pause state$/;"	e	enum:openvpn::Error::Type
N_RECONNECT	error/error.hpp	/^      N_RECONNECT,         \/\/ Number of reconnections$/;"	e	enum:openvpn::Error::Type
N_STATS	log/sessionstats.hpp	/^      N_STATS,$/;"	e	enum:openvpn::SessionStats::Stats
N_TYPES	client/clievent.hpp	/^      N_TYPES$/;"	e	enum:openvpn::ClientEvent::Type
N_TYPES	pki/x509track.hpp	/^      N_TYPES,$/;"	e	enum:openvpn::X509Track::Type
NamedPipe	common/asiopolysock.hpp	/^      NamedPipe(asio::windows::stream_handle&& handle_arg,$/;"	f	struct:openvpn::AsioPolySock::NamedPipe
NamedPipe	common/asiopolysock.hpp	/^    struct NamedPipe : public Base$/;"	s	namespace:openvpn::AsioPolySock
NamedPipe	transport/protocol.hpp	/^      NamedPipe,    \/\/ named pipe (Windows only)$/;"	e	enum:openvpn::Protocol::Type
NetSendType	ssl/protostack.hpp	/^    enum NetSendType {$/;"	g	class:openvpn::ProtoStackBase
Netblock	server/vpnservnetblock.hpp	/^      Netblock() : prefix_len(0) {}$/;"	f	struct:openvpn::VPNServerNetblock::Netblock
Netblock	server/vpnservnetblock.hpp	/^      Netblock(const IP::Route& route)$/;"	f	struct:openvpn::VPNServerNetblock::Netblock
Netblock	server/vpnservnetblock.hpp	/^    struct Netblock$/;"	s	class:openvpn::VPNServerNetblock
Nominal	server/listenlist.hpp	/^	Nominal,$/;"	e	enum:openvpn::Listen::List::LoadMode
Nonce	crypto/crypto_aead.hpp	/^	Nonce()$/;"	f	class:openvpn::AEAD::Crypto::Nonce
Nonce	crypto/crypto_aead.hpp	/^	Nonce(const Nonce& ref, Buffer& buf, const unsigned char *op32)$/;"	f	class:openvpn::AEAD::Crypto::Nonce
Nonce	crypto/crypto_aead.hpp	/^	Nonce(const Nonce& ref, PacketIDSend& pid_send, const PacketID::time_t now,$/;"	f	class:openvpn::AEAD::Crypto::Nonce
Nonce	crypto/crypto_aead.hpp	/^      class Nonce {$/;"	c	class:openvpn::AEAD::Crypto
None	ssl/datalimit.hpp	/^      None=0,$/;"	e	enum:openvpn::DataLimit::State
NotFound	http/status.hpp	/^	NotFound=404,$/;"	e	enum:openvpn::HTTP::Status::__anon45
NotReachable	applecrypto/util/reach.hpp	/^      NotReachable,$/;"	e	enum:openvpn::ReachabilityInterface::Status
Notify	common/actionthread.hpp	/^    struct Notify$/;"	s	class:openvpn::ActionThread
NotifyBase	common/rc.hpp	/^    class NotifyBase$/;"	c	class:openvpn::RCWeak
NotifyCallback	client/clilife.hpp	/^      struct NotifyCallback {$/;"	s	class:openvpn::ClientLifeCycle
NotifyCallback	client/cliproto.hpp	/^    struct NotifyCallback {$/;"	s	namespace:openvpn::ClientProto
NotifyCallback	client/remotelist.hpp	/^      struct NotifyCallback$/;"	s	class:openvpn::RemoteList::PreResolve
NotifyItem	common/rc.hpp	/^    class NotifyItem : public NotifyBase$/;"	c	class:openvpn::RCWeak
NotifyListHead	common/rc.hpp	/^    class NotifyListHead$/;"	c	class:openvpn::RCWeak
NullLex	common/lex.hpp	/^    NullLex() : ch(-1) {}$/;"	f	class:openvpn::NullLex
NullLex	common/lex.hpp	/^  class NullLex$/;"	c	namespace:openvpn
NullLimit	common/split.hpp	/^    struct NullLimit$/;"	s	namespace:openvpn::Split
O	pki/x509track.hpp	/^      O,$/;"	e	enum:openvpn::X509Track::Type
OFFMASK	ip/ip.hpp	/^      OFFMASK=0x1fff,$/;"	e	enum:openvpn::IPHeader::__anon50
OK	auth/authcert.hpp	/^	  OK=0, \/\/ OK MUST be 0$/;"	e	enum:openvpn::AuthCert::Fail::Type
OK	http/status.hpp	/^	OK=200,$/;"	e	enum:openvpn::HTTP::Status::__anon45
OPCODE_SHIFT	ssl/proto.hpp	/^      OPCODE_SHIFT =            3,$/;"	e	enum:openvpn::ProtoContext::__anon80
OPENVPN_ADDR_ADDRLIST_H	addr/addrlist.hpp	/^#define OPENVPN_ADDR_ADDRLIST_H$/;"	d
OPENVPN_ADDR_ADDRPAIR_H	addr/addrpair.hpp	/^#define OPENVPN_ADDR_ADDRPAIR_H$/;"	d
OPENVPN_ADDR_IPERR_H	addr/iperr.hpp	/^#define OPENVPN_ADDR_IPERR_H$/;"	d
OPENVPN_ADDR_IPV4_H	addr/ipv4.hpp	/^#define OPENVPN_ADDR_IPV4_H$/;"	d
OPENVPN_ADDR_IPV6_H	addr/ipv6.hpp	/^#define OPENVPN_ADDR_IPV6_H$/;"	d
OPENVPN_ADDR_IP_H	addr/ip.hpp	/^#define OPENVPN_ADDR_IP_H$/;"	d
OPENVPN_ADDR_MACADDR_H	addr/macaddr.hpp	/^#define OPENVPN_ADDR_MACADDR_H$/;"	d
OPENVPN_ADDR_POOL_H	addr/pool.hpp	/^#define OPENVPN_ADDR_POOL_H$/;"	d
OPENVPN_ADDR_RANGE_H	addr/range.hpp	/^#define OPENVPN_ADDR_RANGE_H$/;"	d
OPENVPN_ADDR_REGEX_H	addr/regex.hpp	/^#define OPENVPN_ADDR_REGEX_H$/;"	d
OPENVPN_ADDR_ROUTEINV_H	addr/routeinv.hpp	/^#define OPENVPN_ADDR_ROUTEINV_H$/;"	d
OPENVPN_ADDR_ROUTE_H	addr/route.hpp	/^#define OPENVPN_ADDR_ROUTE_H$/;"	d
OPENVPN_ADVANCE	tun/mac/gwv4.hpp	/^#   define OPENVPN_ADVANCE(/;"	d
OPENVPN_ADVANCE	tun/mac/gwv4.hpp	/^#   undef OPENVPN_ADVANCE$/;"	d
OPENVPN_APPLECRYPTO_CF_CFHELPER_H	applecrypto/cf/cfhelper.hpp	/^#define OPENVPN_APPLECRYPTO_CF_CFHELPER_H$/;"	d
OPENVPN_APPLECRYPTO_CF_CFSEC_H	applecrypto/cf/cfsec.hpp	/^#define OPENVPN_APPLECRYPTO_CF_CFSEC_H$/;"	d
OPENVPN_APPLECRYPTO_CF_CFTIMER_H	applecrypto/cf/cftimer.hpp	/^#define OPENVPN_APPLECRYPTO_CF_CFTIMER_H$/;"	d
OPENVPN_APPLECRYPTO_CF_CF_H	applecrypto/cf/cf.hpp	/^#define OPENVPN_APPLECRYPTO_CF_CF_H$/;"	d
OPENVPN_APPLECRYPTO_CF_ERROR_H	applecrypto/cf/error.hpp	/^#define OPENVPN_APPLECRYPTO_CF_ERROR_H$/;"	d
OPENVPN_APPLECRYPTO_CRYPTO_API_H	applecrypto/crypto/api.hpp	/^#define OPENVPN_APPLECRYPTO_CRYPTO_API_H$/;"	d
OPENVPN_APPLECRYPTO_CRYPTO_CIPHER_H	applecrypto/crypto/cipher.hpp	/^#define OPENVPN_APPLECRYPTO_CRYPTO_CIPHER_H$/;"	d
OPENVPN_APPLECRYPTO_CRYPTO_DIGEST_H	applecrypto/crypto/digest.hpp	/^#define OPENVPN_APPLECRYPTO_CRYPTO_DIGEST_H$/;"	d
OPENVPN_APPLECRYPTO_CRYPTO_HMAC_H	applecrypto/crypto/hmac.hpp	/^#define OPENVPN_APPLECRYPTO_CRYPTO_HMAC_H$/;"	d
OPENVPN_APPLECRYPTO_SSL_SSLCTX_H	applecrypto/ssl/sslctx.hpp	/^#define OPENVPN_APPLECRYPTO_SSL_SSLCTX_H$/;"	d
OPENVPN_APPLECRYPTO_UTIL_IOSACTIVEIFACE_H	applecrypto/util/iosactiveiface.hpp	/^#define OPENVPN_APPLECRYPTO_UTIL_IOSACTIVEIFACE_H$/;"	d
OPENVPN_APPLECRYPTO_UTIL_RAND_H	applecrypto/util/rand.hpp	/^#define OPENVPN_APPLECRYPTO_UTIL_RAND_H$/;"	d
OPENVPN_APPLECRYPTO_UTIL_REACHABLE_H	applecrypto/util/reachable.hpp	/^#define OPENVPN_APPLECRYPTO_UTIL_REACHABLE_H$/;"	d
OPENVPN_APPLECRYPTO_UTIL_REACH_H	applecrypto/util/reach.hpp	/^#define OPENVPN_APPLECRYPTO_UTIL_REACH_H$/;"	d
OPENVPN_APPLE_MACLIFE_H	apple/maclife.hpp	/^#define OPENVPN_APPLE_MACLIFE_H$/;"	d
OPENVPN_APPLE_MACSLEEP_H	apple/macsleep.hpp	/^#define OPENVPN_APPLE_MACSLEEP_H$/;"	d
OPENVPN_APPLE_MACVER_H	apple/macver.hpp	/^#define OPENVPN_APPLE_MACVER_H$/;"	d
OPENVPN_APPLE_RUNLOOP_H	apple/runloop.hpp	/^#define OPENVPN_APPLE_RUNLOOP_H$/;"	d
OPENVPN_APPLE_SCDYNSTORE_H	apple/scdynstore.hpp	/^#define OPENVPN_APPLE_SCDYNSTORE_H$/;"	d
OPENVPN_APPLE_VER_H	apple/ver.hpp	/^#define OPENVPN_APPLE_VER_H$/;"	d
OPENVPN_ARCH_ARM	common/arch.hpp	/^# define OPENVPN_ARCH_ARM$/;"	d
OPENVPN_ARCH_ARM64	common/arch.hpp	/^# define OPENVPN_ARCH_ARM64$/;"	d
OPENVPN_ARCH_i386	common/arch.hpp	/^# define OPENVPN_ARCH_i386$/;"	d
OPENVPN_ARCH_x86_64	common/arch.hpp	/^# define OPENVPN_ARCH_x86_64$/;"	d
OPENVPN_AUTH_AUTHCERT_H	auth/authcert.hpp	/^#define OPENVPN_AUTH_AUTHCERT_H$/;"	d
OPENVPN_AUTH_AUTHCREDS	auth/authcreds.hpp	/^#define OPENVPN_AUTH_AUTHCREDS$/;"	d
OPENVPN_AUTH_CR_H	auth/cr.hpp	/^#define OPENVPN_AUTH_CR_H$/;"	d
OPENVPN_AUTH_VALIDATE_CREDS_H	auth/validatecreds.hpp	/^#define OPENVPN_AUTH_VALIDATE_CREDS_H$/;"	d
OPENVPN_BIG_ENDIAN	common/endian.hpp	/^#define OPENVPN_BIG_ENDIAN$/;"	d
OPENVPN_BS64_DATA_LIMIT	crypto/bs64_data_limit.hpp	/^#define OPENVPN_BS64_DATA_LIMIT /;"	d
OPENVPN_BUFFER_ASIOBUF_H	buffer/asiobuf.hpp	/^#define OPENVPN_BUFFER_ASIOBUF_H$/;"	d
OPENVPN_BUFFER_BUFCLAMP_H	buffer/bufclamp.hpp	/^#define OPENVPN_BUFFER_BUFCLAMP_H$/;"	d
OPENVPN_BUFFER_BUFCOMPLETE_H	buffer/bufcomplete.hpp	/^#define OPENVPN_BUFFER_BUFCOMPLETE_H$/;"	d
OPENVPN_BUFFER_BUFCOMPOSED_H	buffer/bufcomposed.hpp	/^#define OPENVPN_BUFFER_BUFCOMPOSED_H$/;"	d
OPENVPN_BUFFER_BUFFER_H	buffer/buffer.hpp	/^#define OPENVPN_BUFFER_BUFFER_H$/;"	d
OPENVPN_BUFFER_BUFHEX_H	buffer/bufhex.hpp	/^#define OPENVPN_BUFFER_BUFHEX_H$/;"	d
OPENVPN_BUFFER_BUFLIMIT_H	buffer/buflimit.hpp	/^#define OPENVPN_BUFFER_BUFLIMIT_H$/;"	d
OPENVPN_BUFFER_BUFLIST_H	buffer/buflist.hpp	/^#define OPENVPN_BUFFER_BUFLIST_H$/;"	d
OPENVPN_BUFFER_BUFSTREAM_H	buffer/bufstream.hpp	/^#define OPENVPN_BUFFER_BUFSTREAM_H$/;"	d
OPENVPN_BUFFER_BUFSTR_H	buffer/bufstr.hpp	/^#define OPENVPN_BUFFER_BUFSTR_H$/;"	d
OPENVPN_BUFFER_MEMQ_H	buffer/memq.hpp	/^#define OPENVPN_BUFFER_MEMQ_H$/;"	d
OPENVPN_BUFFER_SAFESTR_H	buffer/safestr.hpp	/^#define OPENVPN_BUFFER_SAFESTR_H$/;"	d
OPENVPN_BUFFER_THROW	buffer/buffer.hpp	/^#define OPENVPN_BUFFER_THROW(/;"	d
OPENVPN_BUFFER_ZLIB_H	buffer/zlib.hpp	/^#define OPENVPN_BUFFER_ZLIB_H$/;"	d
OPENVPN_CF_WRAP	applecrypto/cf/cf.hpp	/^#define OPENVPN_CF_WRAP(/;"	d
OPENVPN_CLIENT_CLICONNECT_H	client/cliconnect.hpp	/^#define OPENVPN_CLIENT_CLICONNECT_H$/;"	d
OPENVPN_CLIENT_CLICONSTANTS_H	client/cliconstants.hpp	/^#define OPENVPN_CLIENT_CLICONSTANTS_H$/;"	d
OPENVPN_CLIENT_CLICREDS_H	client/clicreds.hpp	/^#define OPENVPN_CLIENT_CLICREDS_H$/;"	d
OPENVPN_CLIENT_CLIEMUEXR_H	client/cliemuexr.hpp	/^#define OPENVPN_CLIENT_CLIEMUEXR_H$/;"	d
OPENVPN_CLIENT_CLIEVENT_H	client/clievent.hpp	/^#define OPENVPN_CLIENT_CLIEVENT_H$/;"	d
OPENVPN_CLIENT_CLIHALT_H	client/clihalt.hpp	/^#define OPENVPN_CLIENT_CLIHALT_H$/;"	d
OPENVPN_CLIENT_CLILIFE_H	client/clilife.hpp	/^#define OPENVPN_CLIENT_CLILIFE_H$/;"	d
OPENVPN_CLIENT_CLIOPTHELPER_H	client/cliopthelper.hpp	/^#define OPENVPN_CLIENT_CLIOPTHELPER_H$/;"	d
OPENVPN_CLIENT_CLIOPT_H	client/cliopt.hpp	/^#define OPENVPN_CLIENT_CLIOPT_H$/;"	d
OPENVPN_CLIENT_CLIPROTO_H	client/cliproto.hpp	/^#define OPENVPN_CLIENT_CLIPROTO_H$/;"	d
OPENVPN_CLIENT_IPVERFLAGS_H	client/ipverflags.hpp	/^#define OPENVPN_CLIENT_IPVERFLAGS_H$/;"	d
OPENVPN_CLIENT_OPTFILT_H	client/optfilt.hpp	/^#define OPENVPN_CLIENT_OPTFILT_H$/;"	d
OPENVPN_CLIENT_REMOTELIST_H	client/remotelist.hpp	/^#define OPENVPN_CLIENT_REMOTELIST_H$/;"	d
OPENVPN_CLIENT_RGOPT_H	client/rgopt.hpp	/^#define OPENVPN_CLIENT_RGOPT_H$/;"	d
OPENVPN_COMMON_ABORT_H	common/abort.hpp	/^#define OPENVPN_COMMON_ABORT_H$/;"	d
OPENVPN_COMMON_ACTIONTHREAD_H	common/actionthread.hpp	/^#define OPENVPN_COMMON_ACTIONTHREAD_H$/;"	d
OPENVPN_COMMON_ACTION_H	common/action.hpp	/^#define OPENVPN_COMMON_ACTION_H$/;"	d
OPENVPN_COMMON_ARCH_H	common/arch.hpp	/^#define OPENVPN_COMMON_ARCH_H$/;"	d
OPENVPN_COMMON_ARGV_H	common/argv.hpp	/^#define OPENVPN_COMMON_ARGV_H$/;"	d
OPENVPN_COMMON_ARRAYSIZE_H	common/arraysize.hpp	/^#define OPENVPN_COMMON_ARRAYSIZE_H$/;"	d
OPENVPN_COMMON_ASIOBOUNDSOCK_H	common/asioboundsock.hpp	/^#define OPENVPN_COMMON_ASIOBOUNDSOCK_H$/;"	d
OPENVPN_COMMON_ASIOCONTEXT_H	common/asiocontext.hpp	/^#define OPENVPN_COMMON_ASIOCONTEXT_H$/;"	d
OPENVPN_COMMON_ASIOERR_H	common/asioerr.hpp	/^#define OPENVPN_COMMON_ASIOERR_H$/;"	d
OPENVPN_COMMON_ASIOPOLYSOCK_H	common/asiopolysock.hpp	/^#define OPENVPN_COMMON_ASIOPOLYSOCK_H$/;"	d
OPENVPN_COMMON_ASIOSIGNAL_H	common/asiosignal.hpp	/^#define OPENVPN_COMMON_ASIOSIGNAL_H$/;"	d
OPENVPN_COMMON_ASIOSTOP_H	common/asiostop.hpp	/^#define OPENVPN_COMMON_ASIOSTOP_H$/;"	d
OPENVPN_COMMON_ASYNCSLEEP_H	common/asyncsleep.hpp	/^#define OPENVPN_COMMON_ASYNCSLEEP_H$/;"	d
OPENVPN_COMMON_AUTORESET_H	common/autoreset.hpp	/^#define OPENVPN_COMMON_AUTORESET_H$/;"	d
OPENVPN_COMMON_BASE64_H	common/base64.hpp	/^#define OPENVPN_COMMON_BASE64_H$/;"	d
OPENVPN_COMMON_BINPREFIX_H	common/binprefix.hpp	/^#define OPENVPN_COMMON_BINPREFIX_H$/;"	d
OPENVPN_COMMON_CIRC_LIST_H	common/circ_list.hpp	/^#define OPENVPN_COMMON_CIRC_LIST_H$/;"	d
OPENVPN_COMMON_CLEANUP_H	common/cleanup.hpp	/^#define OPENVPN_COMMON_CLEANUP_H$/;"	d
OPENVPN_COMMON_CORE_H	common/core.hpp	/^#define OPENVPN_COMMON_CORE_H$/;"	d
OPENVPN_COMMON_COUNT_H	common/count.hpp	/^#define OPENVPN_COMMON_COUNT_H$/;"	d
OPENVPN_COMMON_DAEMON_H	common/daemon.hpp	/^#define OPENVPN_COMMON_DAEMON_H$/;"	d
OPENVPN_COMMON_DEMANGLE_H	common/demangle.hpp	/^#define OPENVPN_COMMON_DEMANGLE_H$/;"	d
OPENVPN_COMMON_DESTRUCT_H	common/destruct.hpp	/^#define OPENVPN_COMMON_DESTRUCT_H$/;"	d
OPENVPN_COMMON_ENDIAN_H	common/endian.hpp	/^#define OPENVPN_COMMON_ENDIAN_H$/;"	d
OPENVPN_COMMON_ENUMDIR_H	common/enumdir.hpp	/^#define OPENVPN_COMMON_ENUMDIR_H$/;"	d
OPENVPN_COMMON_EXCEPTION_H	common/exception.hpp	/^#define OPENVPN_COMMON_EXCEPTION_H$/;"	d
OPENVPN_COMMON_EXTERN_H	common/extern.hpp	/^#define OPENVPN_COMMON_EXTERN_H$/;"	d
OPENVPN_COMMON_FFS_H	common/ffs.hpp	/^#define OPENVPN_COMMON_FFS_H$/;"	d
OPENVPN_COMMON_FILEATOMIC_H	common/fileatomic.hpp	/^#define OPENVPN_COMMON_FILEATOMIC_H$/;"	d
OPENVPN_COMMON_FILE_H	common/file.hpp	/^#define OPENVPN_COMMON_FILE_H$/;"	d
OPENVPN_COMMON_FORMAT_H	common/format.hpp	/^#define OPENVPN_COMMON_FORMAT_H$/;"	d
OPENVPN_COMMON_FUNCTION_H	common/function.hpp	/^#define OPENVPN_COMMON_FUNCTION_H$/;"	d
OPENVPN_COMMON_GETOPT_H	common/getopt.hpp	/^#define OPENVPN_COMMON_GETOPT_H$/;"	d
OPENVPN_COMMON_GETPW_H	common/getpw.hpp	/^#define OPENVPN_COMMON_GETPW_H$/;"	d
OPENVPN_COMMON_GLOB_H	common/glob.hpp	/^#define OPENVPN_COMMON_GLOB_H$/;"	d
OPENVPN_COMMON_HASH_H	common/hash.hpp	/^#define OPENVPN_COMMON_HASH_H$/;"	d
OPENVPN_COMMON_HEXSTR_H	common/hexstr.hpp	/^#define OPENVPN_COMMON_HEXSTR_H$/;"	d
OPENVPN_COMMON_HOSTLIST_H	common/hostlist.hpp	/^#define OPENVPN_COMMON_HOSTLIST_H$/;"	d
OPENVPN_COMMON_HOSTPORT_H	common/hostport.hpp	/^#define OPENVPN_COMMON_HOSTPORT_H$/;"	d
OPENVPN_COMMON_INOTIFY_H	common/inotify.hpp	/^#define OPENVPN_COMMON_INOTIFY_H$/;"	d
OPENVPN_COMMON_LEX_H	common/lex.hpp	/^#define OPENVPN_COMMON_LEX_H$/;"	d
OPENVPN_COMMON_LIKELY_H	common/likely.hpp	/^#define OPENVPN_COMMON_LIKELY_H$/;"	d
OPENVPN_COMMON_LINK_H	common/link.hpp	/^#define OPENVPN_COMMON_LINK_H$/;"	d
OPENVPN_COMMON_LOGROTATE_H	common/logrotate.hpp	/^#define OPENVPN_COMMON_LOGROTATE_H$/;"	d
OPENVPN_COMMON_MEMNEQ_H	common/memneq.hpp	/^#define OPENVPN_COMMON_MEMNEQ_H$/;"	d
OPENVPN_COMMON_MODE_H	common/mode.hpp	/^#define OPENVPN_COMMON_MODE_H$/;"	d
OPENVPN_COMMON_MSGWIN_H	common/msgwin.hpp	/^#define OPENVPN_COMMON_MSGWIN_H$/;"	d
OPENVPN_COMMON_NUMBER_H	common/number.hpp	/^#define OPENVPN_COMMON_NUMBER_H$/;"	d
OPENVPN_COMMON_OLONG_H	common/olong.hpp	/^#define OPENVPN_COMMON_OLONG_H$/;"	d
OPENVPN_COMMON_OPTIONS_H	common/options.hpp	/^#define OPENVPN_COMMON_OPTIONS_H$/;"	d
OPENVPN_COMMON_OSTREAM_H	common/ostream.hpp	/^#define OPENVPN_COMMON_OSTREAM_H$/;"	d
OPENVPN_COMMON_PATH_H	common/path.hpp	/^#define OPENVPN_COMMON_PATH_H$/;"	d
OPENVPN_COMMON_PEERCRED_H	common/peercred.hpp	/^#define OPENVPN_COMMON_PEERCRED_H$/;"	d
OPENVPN_COMMON_PERSISTFILE_H	common/persistfile.hpp	/^#define OPENVPN_COMMON_PERSISTFILE_H$/;"	d
OPENVPN_COMMON_PLATFORM_H	common/platform.hpp	/^#define OPENVPN_COMMON_PLATFORM_H$/;"	d
OPENVPN_COMMON_PLATFORM_NAME_H	common/platform_name.hpp	/^#define OPENVPN_COMMON_PLATFORM_NAME_H$/;"	d
OPENVPN_COMMON_PLATFORM_STRING_H	common/platform_string.hpp	/^#define OPENVPN_COMMON_PLATFORM_STRING_H$/;"	d
OPENVPN_COMMON_PROCESS_H	common/process.hpp	/^#define OPENVPN_COMMON_PROCESS_H$/;"	d
OPENVPN_COMMON_PTHREADCOND_H	common/pthreadcond.hpp	/^#define OPENVPN_COMMON_PTHREADCOND_H$/;"	d
OPENVPN_COMMON_RC_H	common/rc.hpp	/^#define OPENVPN_COMMON_RC_H$/;"	d
OPENVPN_COMMON_REDIR_H	common/redir.hpp	/^#define OPENVPN_COMMON_REDIR_H$/;"	d
OPENVPN_COMMON_RUNCONTEXT_H	common/runcontext.hpp	/^#define OPENVPN_COMMON_RUNCONTEXT_H$/;"	d
OPENVPN_COMMON_SCOPED_ASIO_STREAM_H	common/scoped_asio_stream.hpp	/^#define OPENVPN_COMMON_SCOPED_ASIO_STREAM_H$/;"	d
OPENVPN_COMMON_SCOPED_FD_H	common/scoped_fd.hpp	/^#define OPENVPN_COMMON_SCOPED_FD_H$/;"	d
OPENVPN_COMMON_SIGNAL_H	common/signal.hpp	/^#define OPENVPN_COMMON_SIGNAL_H$/;"	d
OPENVPN_COMMON_SIZE_H	common/size.hpp	/^#define OPENVPN_COMMON_SIZE_H$/;"	d
OPENVPN_COMMON_SLEEP_H	common/sleep.hpp	/^#define OPENVPN_COMMON_SLEEP_H$/;"	d
OPENVPN_COMMON_SOCKOPT_H	common/sockopt.hpp	/^#define OPENVPN_COMMON_SOCKOPT_H$/;"	d
OPENVPN_COMMON_SOCKTYPES_H	common/socktypes.hpp	/^#define OPENVPN_COMMON_SOCKTYPES_H$/;"	d
OPENVPN_COMMON_SPLITLINES_H	common/splitlines.hpp	/^#define OPENVPN_COMMON_SPLITLINES_H$/;"	d
OPENVPN_COMMON_SPLIT_H	common/split.hpp	/^#define OPENVPN_COMMON_SPLIT_H$/;"	d
OPENVPN_COMMON_STAT_H	common/stat.hpp	/^#define OPENVPN_COMMON_STAT_H$/;"	d
OPENVPN_COMMON_STOP_H	common/stop.hpp	/^#define OPENVPN_COMMON_STOP_H$/;"	d
OPENVPN_COMMON_STRINGIZE_H	common/stringize.hpp	/^#define OPENVPN_COMMON_STRINGIZE_H$/;"	d
OPENVPN_COMMON_STRING_H	common/string.hpp	/^#define OPENVPN_COMMON_STRING_H$/;"	d
OPENVPN_COMMON_TEMPFILE_H	common/tempfile.hpp	/^#define OPENVPN_COMMON_TEMPFILE_H$/;"	d
OPENVPN_COMMON_UMASK_H	common/umask.hpp	/^#define OPENVPN_COMMON_UMASK_H$/;"	d
OPENVPN_COMMON_UNICODE_H	common/unicode.hpp	/^#define OPENVPN_COMMON_UNICODE_H$/;"	d
OPENVPN_COMMON_UNICODE_IMPL_H	common/unicode-impl.hpp	/^#define OPENVPN_COMMON_UNICODE_IMPL_H$/;"	d
OPENVPN_COMMON_UNIQUEPTR_H	common/uniqueptr.hpp	/^#define OPENVPN_COMMON_UNIQUEPTR_H$/;"	d
OPENVPN_COMMON_USECOUNT_H	common/usecount.hpp	/^#define OPENVPN_COMMON_USECOUNT_H$/;"	d
OPENVPN_COMMON_USERGROUP_H	common/usergroup.hpp	/^#define OPENVPN_COMMON_USERGROUP_H$/;"	d
OPENVPN_COMMON_USERPASS_H	common/userpass.hpp	/^#define OPENVPN_COMMON_USERPASS_H$/;"	d
OPENVPN_COMMON_VERSION_H	common/version.hpp	/^#define OPENVPN_COMMON_VERSION_H$/;"	d
OPENVPN_COMMON_WAITBARRIER_H	common/waitbarrier.hpp	/^#define OPENVPN_COMMON_WAITBARRIER_H$/;"	d
OPENVPN_COMMON_WRITE_H	common/write.hpp	/^#define OPENVPN_COMMON_WRITE_H$/;"	d
OPENVPN_COMMON_WSTRING_H	common/wstring.hpp	/^#define OPENVPN_COMMON_WSTRING_H$/;"	d
OPENVPN_COMPILER_FENCE	common/memneq.hpp	/^#define OPENVPN_COMPILER_FENCE /;"	d
OPENVPN_COMPRESS_COMPNULL_H	compress/compnull.hpp	/^#define OPENVPN_COMPRESS_COMPNULL_H$/;"	d
OPENVPN_COMPRESS_COMPRESS_H	compress/compress.hpp	/^#define OPENVPN_COMPRESS_COMPRESS_H$/;"	d
OPENVPN_COMPRESS_COMPSTUB_H	compress/compstub.hpp	/^#define OPENVPN_COMPRESS_COMPSTUB_H$/;"	d
OPENVPN_COMPRESS_LZ4_H	compress/lz4.hpp	/^#define OPENVPN_COMPRESS_LZ4_H$/;"	d
OPENVPN_COMPRESS_LZOASYM_H	compress/lzoasym.hpp	/^#define OPENVPN_COMPRESS_LZOASYM_H$/;"	d
OPENVPN_COMPRESS_LZOASYM_IMPL_H	compress/lzoasym_impl.hpp	/^#define OPENVPN_COMPRESS_LZOASYM_IMPL_H$/;"	d
OPENVPN_COMPRESS_LZOSELECT_H	compress/lzoselect.hpp	/^#define OPENVPN_COMPRESS_LZOSELECT_H$/;"	d
OPENVPN_COMPRESS_LZO_H	compress/lzo.hpp	/^#define OPENVPN_COMPRESS_LZO_H$/;"	d
OPENVPN_COMPRESS_SNAPPY_H	compress/snappy.hpp	/^#define OPENVPN_COMPRESS_SNAPPY_H$/;"	d
OPENVPN_CRYPTO_CIPHER_H	crypto/cipher.hpp	/^#define OPENVPN_CRYPTO_CIPHER_H$/;"	d
OPENVPN_CRYPTO_CRYPTOALGS_H	crypto/cryptoalgs.hpp	/^#define OPENVPN_CRYPTO_CRYPTOALGS_H$/;"	d
OPENVPN_CRYPTO_CRYPTODCSEL_H	crypto/cryptodcsel.hpp	/^#define OPENVPN_CRYPTO_CRYPTODCSEL_H$/;"	d
OPENVPN_CRYPTO_CRYPTODC_H	crypto/cryptodc.hpp	/^#define OPENVPN_CRYPTO_CRYPTODC_H$/;"	d
OPENVPN_CRYPTO_CRYPTO_AEAD_H	crypto/crypto_aead.hpp	/^#define OPENVPN_CRYPTO_CRYPTO_AEAD_H$/;"	d
OPENVPN_CRYPTO_CRYPTO_CHM_H	crypto/crypto_chm.hpp	/^#define OPENVPN_CRYPTO_CRYPTO_CHM_H$/;"	d
OPENVPN_CRYPTO_DATALIMIT_H	crypto/bs64_data_limit.hpp	/^#define OPENVPN_CRYPTO_DATALIMIT_H$/;"	d
OPENVPN_CRYPTO_DECRYPT_CHM_H	crypto/decrypt_chm.hpp	/^#define OPENVPN_CRYPTO_DECRYPT_CHM_H$/;"	d
OPENVPN_CRYPTO_DIGESTAPI_H	crypto/digestapi.hpp	/^#define OPENVPN_CRYPTO_DIGESTAPI_H$/;"	d
OPENVPN_CRYPTO_ENCRYPT_CHM_H	crypto/encrypt_chm.hpp	/^#define OPENVPN_CRYPTO_ENCRYPT_CHM_H$/;"	d
OPENVPN_CRYPTO_HASHSTR_H	crypto/hashstr.hpp	/^#define OPENVPN_CRYPTO_HASHSTR_H$/;"	d
OPENVPN_CRYPTO_OVPNHMAC_H	crypto/ovpnhmac.hpp	/^#define OPENVPN_CRYPTO_OVPNHMAC_H$/;"	d
OPENVPN_CRYPTO_PACKET_ID_H	crypto/packet_id.hpp	/^#define OPENVPN_CRYPTO_PACKET_ID_H$/;"	d
OPENVPN_CRYPTO_SELFTEST_H	crypto/selftest.hpp	/^#define OPENVPN_CRYPTO_SELFTEST_H$/;"	d
OPENVPN_CRYPTO_STATIC_KEY_H	crypto/static_key.hpp	/^#define OPENVPN_CRYPTO_STATIC_KEY_H$/;"	d
OPENVPN_CRYPTO_TOKENENCRYPT_H	openssl/util/tokenencrypt.hpp	/^#define OPENVPN_CRYPTO_TOKENENCRYPT_H$/;"	d
OPENVPN_DIGEST_ALG_CLASS	applecrypto/crypto/digest.hpp	/^#define OPENVPN_DIGEST_ALG_CLASS(/;"	d
OPENVPN_DIGEST_ALG_CLASS	applecrypto/crypto/digest.hpp	/^#undef OPENVPN_DIGEST_ALG_CLASS$/;"	d
OPENVPN_DIGEST_ALG_DECLARE	applecrypto/crypto/digest.hpp	/^#define OPENVPN_DIGEST_ALG_DECLARE(/;"	d
OPENVPN_DIGEST_ALG_DECLARE	applecrypto/crypto/digest.hpp	/^#undef OPENVPN_DIGEST_ALG_DECLARE$/;"	d
OPENVPN_DIGEST_CONTEXT	applecrypto/crypto/digest.hpp	/^#define OPENVPN_DIGEST_CONTEXT(/;"	d
OPENVPN_DIGEST_CONTEXT	applecrypto/crypto/digest.hpp	/^#undef OPENVPN_DIGEST_CONTEXT$/;"	d
OPENVPN_DIGEST_INFO_DECLARE	applecrypto/crypto/digest.hpp	/^#define OPENVPN_DIGEST_INFO_DECLARE(/;"	d
OPENVPN_DIGEST_INFO_DECLARE	applecrypto/crypto/digest.hpp	/^#undef OPENVPN_DIGEST_INFO_DECLARE$/;"	d
OPENVPN_DIGEST_INFO_DECLARE_NO_HMAC	applecrypto/crypto/digest.hpp	/^#define OPENVPN_DIGEST_INFO_DECLARE_NO_HMAC(/;"	d
OPENVPN_DURATION_REL	time/time.hpp	/^#     define OPENVPN_DURATION_REL(/;"	d
OPENVPN_DURATION_REL	time/time.hpp	/^#     undef OPENVPN_DURATION_REL$/;"	d
OPENVPN_ERROR_ERROR_H	error/error.hpp	/^#define OPENVPN_ERROR_ERROR_H$/;"	d
OPENVPN_ERROR_EXCODE_H	error/excode.hpp	/^#define OPENVPN_ERROR_EXCODE_H$/;"	d
OPENVPN_EXCEPTION	common/exception.hpp	/^# define OPENVPN_EXCEPTION(/;"	d
OPENVPN_EXCEPTION_INHERIT	common/exception.hpp	/^# define OPENVPN_EXCEPTION_INHERIT(/;"	d
OPENVPN_EXTERN	common/extern.hpp	/^#define OPENVPN_EXTERN$/;"	d
OPENVPN_FILE_LINE	common/exception.hpp	/^# define OPENVPN_FILE_LINE /;"	d
OPENVPN_FILE_LINE	common/exception.hpp	/^# define OPENVPN_FILE_LINE$/;"	d
OPENVPN_FMT	common/format.hpp	/^# define OPENVPN_FMT(/;"	d
OPENVPN_FRAME_FRAME_H	frame/frame.hpp	/^#define OPENVPN_FRAME_FRAME_H$/;"	d
OPENVPN_FRAME_FRAME_INIT_H	frame/frame_init.hpp	/^#define OPENVPN_FRAME_FRAME_INIT_H$/;"	d
OPENVPN_FRAME_MEMQ_DGRAM_H	frame/memq_dgram.hpp	/^#define OPENVPN_FRAME_MEMQ_DGRAM_H$/;"	d
OPENVPN_FRAME_MEMQ_STREAM_H	frame/memq_stream.hpp	/^#define OPENVPN_FRAME_MEMQ_STREAM_H$/;"	d
OPENVPN_GZIP_VERBOSE	buffer/zlib.hpp	/^#define OPENVPN_GZIP_VERBOSE /;"	d
OPENVPN_HASH_METHOD	common/hash.hpp	/^#define OPENVPN_HASH_METHOD(/;"	d
OPENVPN_HAVE_EFFICIENT_UNALIGNED_ACCESS	common/memneq.hpp	/^#define OPENVPN_HAVE_EFFICIENT_UNALIGNED_ACCESS$/;"	d
OPENVPN_HTTP_EXCEPT_H	http/webexcept.hpp	/^#define OPENVPN_HTTP_EXCEPT_H$/;"	d
OPENVPN_HTTP_HEADER_H	http/header.hpp	/^#define OPENVPN_HTTP_HEADER_H$/;"	d
OPENVPN_HTTP_HTMLSKIP_H	http/htmlskip.hpp	/^#define OPENVPN_HTTP_HTMLSKIP_H$/;"	d
OPENVPN_HTTP_METHOD_H	http/method.hpp	/^#define OPENVPN_HTTP_METHOD_H$/;"	d
OPENVPN_HTTP_PARSEUTIL_H	http/parseutil.hpp	/^#define OPENVPN_HTTP_PARSEUTIL_H$/;"	d
OPENVPN_HTTP_REPLY_H	http/reply.hpp	/^#define OPENVPN_HTTP_REPLY_H$/;"	d
OPENVPN_HTTP_REQUEST_H	http/request.hpp	/^#define OPENVPN_HTTP_REQUEST_H$/;"	d
OPENVPN_HTTP_STATUS_H	http/status.hpp	/^#define OPENVPN_HTTP_STATUS_H$/;"	d
OPENVPN_HTTP_URLENCODE_H	http/urlencode.hpp	/^#define OPENVPN_HTTP_URLENCODE_H$/;"	d
OPENVPN_HTTP_URLPARM_H	http/urlparm.hpp	/^#define OPENVPN_HTTP_URLPARM_H$/;"	d
OPENVPN_HTTP_URLPARSE_H	http/urlparse.hpp	/^#define OPENVPN_HTTP_URLPARSE_H$/;"	d
OPENVPN_INCR_VOID_PTR	common/memneq.hpp	/^#define OPENVPN_INCR_VOID_PTR(/;"	d
OPENVPN_INIT_CRYPTOINIT_H	init/cryptoinit.hpp	/^#define OPENVPN_INIT_CRYPTOINIT_H$/;"	d
OPENVPN_INIT_ENGINEINIT_H	init/engineinit.hpp	/^#define OPENVPN_INIT_ENGINEINIT_H$/;"	d
OPENVPN_INIT_INITPROCESS_H	init/initprocess.hpp	/^#define OPENVPN_INIT_INITPROCESS_H$/;"	d
OPENVPN_IPV6_OPERATOR_REL	addr/ipv6.hpp	/^#define OPENVPN_IPV6_OPERATOR_REL(/;"	d
OPENVPN_IPV6_OPERATOR_REL	addr/ipv6.hpp	/^#undef OPENVPN_IPV6_OPERATOR_REL$/;"	d
OPENVPN_IP_DHCP_H	ip/dhcp.hpp	/^#define OPENVPN_IP_DHCP_H$/;"	d
OPENVPN_IP_ETH_H	ip/eth.hpp	/^#define OPENVPN_IP_ETH_H$/;"	d
OPENVPN_IP_ICMP_H	ip/icmp.hpp	/^#define OPENVPN_IP_ICMP_H$/;"	d
OPENVPN_IP_IP_H	ip/ip.hpp	/^#define OPENVPN_IP_IP_H$/;"	d
OPENVPN_IP_OPERATOR_BINOP	addr/ip.hpp	/^#define OPENVPN_IP_OPERATOR_BINOP(/;"	d
OPENVPN_IP_OPERATOR_BINOP	addr/ip.hpp	/^#undef OPENVPN_IP_OPERATOR_BINOP$/;"	d
OPENVPN_IP_OPERATOR_REL	addr/ip.hpp	/^#define OPENVPN_IP_OPERATOR_REL(/;"	d
OPENVPN_IP_OPERATOR_REL	addr/ip.hpp	/^#undef OPENVPN_IP_OPERATOR_REL$/;"	d
OPENVPN_IP_UDP_H	ip/udp.hpp	/^#define OPENVPN_IP_UDP_H$/;"	d
OPENVPN_LEGAL_COPYRIGHT_H	legal/copyright.hpp	/^#define OPENVPN_LEGAL_COPYRIGHT_H$/;"	d
OPENVPN_LINUX_CORE_H	linux/core.hpp	/^#define OPENVPN_LINUX_CORE_H$/;"	d
OPENVPN_LINUX_DAEMON_ALIVE_H	linux/daemon_alive.hpp	/^#define OPENVPN_LINUX_DAEMON_ALIVE_H$/;"	d
OPENVPN_LITTLE_ENDIAN	common/endian.hpp	/^#define OPENVPN_LITTLE_ENDIAN /;"	d
OPENVPN_LITTLE_ENDIAN	common/endian.hpp	/^#define OPENVPN_LITTLE_ENDIAN$/;"	d
OPENVPN_LOG	log/lognull.hpp	/^#define OPENVPN_LOG(/;"	d
OPENVPN_LOG	log/logsimple.hpp	/^#define OPENVPN_LOG(/;"	d
OPENVPN_LOG	log/logthread.hpp	/^# define OPENVPN_LOG(/;"	d
OPENVPN_LOG_CLASS	log/logbase.hpp	/^#define OPENVPN_LOG_CLASS /;"	d
OPENVPN_LOG_CLIPROTO	client/cliproto.hpp	/^#define OPENVPN_LOG_CLIPROTO(/;"	d
OPENVPN_LOG_COMPRESS	compress/compress.hpp	/^#define OPENVPN_LOG_COMPRESS(/;"	d
OPENVPN_LOG_COMPRESS	compress/compress.hpp	/^#undef OPENVPN_LOG_COMPRESS$/;"	d
OPENVPN_LOG_COMPRESS_VERBOSE	compress/compress.hpp	/^#define OPENVPN_LOG_COMPRESS_VERBOSE(/;"	d
OPENVPN_LOG_COMPRESS_VERBOSE	compress/compress.hpp	/^#undef OPENVPN_LOG_COMPRESS_VERBOSE$/;"	d
OPENVPN_LOG_INFO	log/logbase.hpp	/^#define OPENVPN_LOG_INFO(/;"	d
OPENVPN_LOG_LOGBASESIMPLE_H	log/logbasesimple.hpp	/^#define OPENVPN_LOG_LOGBASESIMPLE_H$/;"	d
OPENVPN_LOG_LOGBASE_H	log/logbase.hpp	/^#define OPENVPN_LOG_LOGBASE_H$/;"	d
OPENVPN_LOG_LOGNULL_H	log/lognull.hpp	/^#define OPENVPN_LOG_LOGNULL_H$/;"	d
OPENVPN_LOG_LOGPERIOD_H	log/logperiod.hpp	/^#define OPENVPN_LOG_LOGPERIOD_H$/;"	d
OPENVPN_LOG_LOGSIMPLE_H	log/logsimple.hpp	/^#define OPENVPN_LOG_LOGSIMPLE_H$/;"	d
OPENVPN_LOG_LOGTHREAD_H	log/logthread.hpp	/^#define OPENVPN_LOG_LOGTHREAD_H$/;"	d
OPENVPN_LOG_NTNL	log/lognull.hpp	/^#define OPENVPN_LOG_NTNL(/;"	d
OPENVPN_LOG_NTNL	log/logsimple.hpp	/^#define OPENVPN_LOG_NTNL(/;"	d
OPENVPN_LOG_NTNL	log/logthread.hpp	/^#define OPENVPN_LOG_NTNL(/;"	d
OPENVPN_LOG_PROTO	ssl/proto.hpp	/^#define OPENVPN_LOG_PROTO(/;"	d
OPENVPN_LOG_PROTO_VERBOSE	ssl/proto.hpp	/^#define OPENVPN_LOG_PROTO_VERBOSE(/;"	d
OPENVPN_LOG_REMOTELIST	client/remotelist.hpp	/^#define OPENVPN_LOG_REMOTELIST(/;"	d
OPENVPN_LOG_SERVPROTO	server/servproto.hpp	/^#define OPENVPN_LOG_SERVPROTO(/;"	d
OPENVPN_LOG_SESSIONSTATS_H	log/sessionstats.hpp	/^#define OPENVPN_LOG_SESSIONSTATS_H$/;"	d
OPENVPN_LOG_STREAM	log/logsimple.hpp	/^#define OPENVPN_LOG_STREAM /;"	d
OPENVPN_LOG_STRING	log/lognull.hpp	/^#define OPENVPN_LOG_STRING(/;"	d
OPENVPN_LOG_STRING	log/logsimple.hpp	/^#define OPENVPN_LOG_STRING(/;"	d
OPENVPN_LOG_STRING	log/logthread.hpp	/^# define OPENVPN_LOG_STRING(/;"	d
OPENVPN_LOG_STRING_PROTO	ssl/proto.hpp	/^#define OPENVPN_LOG_STRING_PROTO(/;"	d
OPENVPN_LOG_TCPLINK_ERROR	transport/tcplink.hpp	/^#define OPENVPN_LOG_TCPLINK_ERROR(/;"	d
OPENVPN_LOG_TCPLINK_VERBOSE	transport/tcplink.hpp	/^#define OPENVPN_LOG_TCPLINK_VERBOSE(/;"	d
OPENVPN_LOG_TUN	tun/tunlog.hpp	/^#define OPENVPN_LOG_TUN(/;"	d
OPENVPN_LOG_TUN_ERROR	tun/tunlog.hpp	/^#define OPENVPN_LOG_TUN_ERROR(/;"	d
OPENVPN_LOG_TUN_VERBOSE	tun/tunlog.hpp	/^#define OPENVPN_LOG_TUN_VERBOSE(/;"	d
OPENVPN_LOG_UDPLINK_ERROR	transport/udplink.hpp	/^#define OPENVPN_LOG_UDPLINK_ERROR(/;"	d
OPENVPN_LOG_UDPLINK_VERBOSE	transport/udplink.hpp	/^#define OPENVPN_LOG_UDPLINK_VERBOSE(/;"	d
OPENVPN_NETCONF_ENUMIFACE_H	netconf/enumiface.hpp	/^#define OPENVPN_NETCONF_ENUMIFACE_H$/;"	d
OPENVPN_NETCONF_HWADDR_H	netconf/hwaddr.hpp	/^#define OPENVPN_NETCONF_HWADDR_H$/;"	d
OPENVPN_NETCONF_LINUX_ROUTE_H	netconf/linux/route.hpp	/^#define OPENVPN_NETCONF_LINUX_ROUTE_H$/;"	d
OPENVPN_NEXTADDR	tun/mac/gwv4.hpp	/^#   define OPENVPN_NEXTADDR(/;"	d
OPENVPN_NEXTADDR	tun/mac/gwv4.hpp	/^#   undef OPENVPN_NEXTADDR$/;"	d
OPENVPN_OPENSSL_BIO_BIO_MEMQ_DGRAM_H	openssl/bio/bio_memq_dgram.hpp	/^#define OPENVPN_OPENSSL_BIO_BIO_MEMQ_DGRAM_H$/;"	d
OPENVPN_OPENSSL_BIO_BIO_MEMQ_STREAM_H	openssl/bio/bio_memq_stream.hpp	/^#define OPENVPN_OPENSSL_BIO_BIO_MEMQ_STREAM_H$/;"	d
OPENVPN_OPENSSL_CRYPTO_API_H	openssl/crypto/api.hpp	/^#define OPENVPN_OPENSSL_CRYPTO_API_H$/;"	d
OPENVPN_OPENSSL_CRYPTO_CIPHERGCM_H	openssl/crypto/ciphergcm.hpp	/^#define OPENVPN_OPENSSL_CRYPTO_CIPHERGCM_H$/;"	d
OPENVPN_OPENSSL_CRYPTO_CIPHER_H	openssl/crypto/cipher.hpp	/^#define OPENVPN_OPENSSL_CRYPTO_CIPHER_H$/;"	d
OPENVPN_OPENSSL_CRYPTO_DIGEST_H	openssl/crypto/digest.hpp	/^#define OPENVPN_OPENSSL_CRYPTO_DIGEST_H$/;"	d
OPENVPN_OPENSSL_CRYPTO_HMAC_H	openssl/crypto/hmac.hpp	/^#define OPENVPN_OPENSSL_CRYPTO_HMAC_H$/;"	d
OPENVPN_OPENSSL_PKI_CRL_H	openssl/pki/crl.hpp	/^#define OPENVPN_OPENSSL_PKI_CRL_H$/;"	d
OPENVPN_OPENSSL_PKI_DH_H	openssl/pki/dh.hpp	/^#define OPENVPN_OPENSSL_PKI_DH_H$/;"	d
OPENVPN_OPENSSL_PKI_PKEY_H	openssl/pki/pkey.hpp	/^#define OPENVPN_OPENSSL_PKI_PKEY_H$/;"	d
OPENVPN_OPENSSL_PKI_X509STORE_H	openssl/pki/x509store.hpp	/^#define OPENVPN_OPENSSL_PKI_X509STORE_H$/;"	d
OPENVPN_OPENSSL_PKI_X509_H	openssl/pki/x509.hpp	/^#define OPENVPN_OPENSSL_PKI_X509_H$/;"	d
OPENVPN_OPENSSL_SIGN_PKCS7VERIFY_H	openssl/sign/pkcs7verify.hpp	/^#define OPENVPN_OPENSSL_SIGN_PKCS7VERIFY_H$/;"	d
OPENVPN_OPENSSL_SIGN_VERIFY_H	openssl/sign/verify.hpp	/^#define OPENVPN_OPENSSL_SIGN_VERIFY_H$/;"	d
OPENVPN_OPENSSL_SSL_SSLCTX_H	openssl/ssl/sslctx.hpp	/^#define OPENVPN_OPENSSL_SSL_SSLCTX_H$/;"	d
OPENVPN_OPENSSL_UTIL_ENGINE_H	openssl/util/engine.hpp	/^#define OPENVPN_OPENSSL_UTIL_ENGINE_H$/;"	d
OPENVPN_OPENSSL_UTIL_ERROR_H	openssl/util/error.hpp	/^#define OPENVPN_OPENSSL_UTIL_ERROR_H$/;"	d
OPENVPN_OPENSSL_UTIL_INIT_H	openssl/util/init.hpp	/^#define OPENVPN_OPENSSL_UTIL_INIT_H$/;"	d
OPENVPN_OPENSSL_UTIL_RAND_H	openssl/util/rand.hpp	/^#define OPENVPN_OPENSSL_UTIL_RAND_H$/;"	d
OPENVPN_OPTIONS_CONTINUATION_H	options/continuation.hpp	/^#define OPENVPN_OPTIONS_CONTINUATION_H$/;"	d
OPENVPN_OPTIONS_MERGE_H	options/merge.hpp	/^#define OPENVPN_OPTIONS_MERGE_H$/;"	d
OPENVPN_OPTIONS_SANITIZE_H	options/sanitize.hpp	/^#define OPENVPN_OPTIONS_SANITIZE_H$/;"	d
OPENVPN_OPTIONS_SERVPUSH_H	options/servpush.hpp	/^#define OPENVPN_OPTIONS_SERVPUSH_H$/;"	d
OPENVPN_OSTREAM	common/ostream.hpp	/^#define OPENVPN_OSTREAM(/;"	d
OPENVPN_PKI_CCLIST_H	pki/cclist.hpp	/^#define OPENVPN_PKI_CCLIST_H$/;"	d
OPENVPN_PKI_EPKIBASE_H	pki/epkibase.hpp	/^#define OPENVPN_PKI_EPKIBASE_H$/;"	d
OPENVPN_PKI_PKCS1_H	pki/pkcs1.hpp	/^#define OPENVPN_PKI_PKCS1_H$/;"	d
OPENVPN_PKI_X509TRACK_H	pki/x509track.hpp	/^#define OPENVPN_PKI_X509TRACK_H$/;"	d
OPENVPN_PLATFORM_ANDROID	common/platform.hpp	/^# define OPENVPN_PLATFORM_ANDROID$/;"	d
OPENVPN_PLATFORM_IPHONE	common/platform.hpp	/^#  define OPENVPN_PLATFORM_IPHONE$/;"	d
OPENVPN_PLATFORM_IPHONE_DEVICE	common/platform.hpp	/^#  define OPENVPN_PLATFORM_IPHONE_DEVICE$/;"	d
OPENVPN_PLATFORM_IPHONE_SIMULATOR	common/platform.hpp	/^#  define OPENVPN_PLATFORM_IPHONE_SIMULATOR$/;"	d
OPENVPN_PLATFORM_LINUX	common/platform.hpp	/^# define OPENVPN_PLATFORM_LINUX$/;"	d
OPENVPN_PLATFORM_MAC	common/platform.hpp	/^#  define OPENVPN_PLATFORM_MAC$/;"	d
OPENVPN_PLATFORM_TYPE_APPLE	common/platform.hpp	/^# define OPENVPN_PLATFORM_TYPE_APPLE$/;"	d
OPENVPN_PLATFORM_TYPE_UNIX	common/platform.hpp	/^#define OPENVPN_PLATFORM_TYPE_UNIX$/;"	d
OPENVPN_PLATFORM_WIN	common/platform.hpp	/^# define OPENVPN_PLATFORM_WIN$/;"	d
OPENVPN_POLARSSL_CRYPTO_API_H	polarssl/crypto/api.hpp	/^#define OPENVPN_POLARSSL_CRYPTO_API_H$/;"	d
OPENVPN_POLARSSL_CRYPTO_CIPHERGCM_H	polarssl/crypto/ciphergcm.hpp	/^#define OPENVPN_POLARSSL_CRYPTO_CIPHERGCM_H$/;"	d
OPENVPN_POLARSSL_CRYPTO_CIPHER_H	polarssl/crypto/cipher.hpp	/^#define OPENVPN_POLARSSL_CRYPTO_CIPHER_H$/;"	d
OPENVPN_POLARSSL_CRYPTO_DIGEST_H	polarssl/crypto/digest.hpp	/^#define OPENVPN_POLARSSL_CRYPTO_DIGEST_H$/;"	d
OPENVPN_POLARSSL_CRYPTO_HMAC_H	polarssl/crypto/hmac.hpp	/^#define OPENVPN_POLARSSL_CRYPTO_HMAC_H$/;"	d
OPENVPN_POLARSSL_PKI_DH_H	polarssl/pki/dh.hpp	/^#define OPENVPN_POLARSSL_PKI_DH_H$/;"	d
OPENVPN_POLARSSL_PKI_PKCTX_H	polarssl/pki/pkctx.hpp	/^#define OPENVPN_POLARSSL_PKI_PKCTX_H$/;"	d
OPENVPN_POLARSSL_PKI_X509CERT_H	polarssl/pki/x509cert.hpp	/^#define OPENVPN_POLARSSL_PKI_X509CERT_H$/;"	d
OPENVPN_POLARSSL_PKI_X509CRL_H	polarssl/pki/x509crl.hpp	/^#define OPENVPN_POLARSSL_PKI_X509CRL_H$/;"	d
OPENVPN_POLARSSL_SSL_SSLCTX_H	polarssl/ssl/sslctx.hpp	/^#define OPENVPN_POLARSSL_SSL_SSLCTX_H$/;"	d
OPENVPN_POLARSSL_UTIL_ERROR_H	polarssl/util/error.hpp	/^#define OPENVPN_POLARSSL_UTIL_ERROR_H$/;"	d
OPENVPN_POLARSSL_UTIL_RANDAPI_H	random/randapi.hpp	/^#define OPENVPN_POLARSSL_UTIL_RANDAPI_H$/;"	d
OPENVPN_POLARSSL_UTIL_RAND_H	polarssl/util/rand.hpp	/^#define OPENVPN_POLARSSL_UTIL_RAND_H$/;"	d
OPENVPN_POLARSSL_UTIL_SELFTEST_H	polarssl/util/selftest.hpp	/^#define OPENVPN_POLARSSL_UTIL_SELFTEST_H$/;"	d
OPENVPN_PROXY_HTTPDIGEST_H	proxy/httpdigest.hpp	/^#define OPENVPN_PROXY_HTTPDIGEST_H$/;"	d
OPENVPN_PROXY_NTLM_H	proxy/ntlm.hpp	/^#define OPENVPN_PROXY_NTLM_H$/;"	d
OPENVPN_PROXY_PROXYAUTH_H	proxy/proxyauth.hpp	/^#define OPENVPN_PROXY_PROXYAUTH_H$/;"	d
OPENVPN_RANDOM_DEVURAND_H	random/devurand.hpp	/^#define OPENVPN_RANDOM_DEVURAND_H$/;"	d
OPENVPN_RANDOM_MTRANDAPI_H	random/mtrandapi.hpp	/^#define OPENVPN_RANDOM_MTRANDAPI_H$/;"	d
OPENVPN_RANDOM_RANDBYTESTORE_H	random/randbytestore.hpp	/^#define OPENVPN_RANDOM_RANDBYTESTORE_H$/;"	d
OPENVPN_RELIABLE_RELACK_H	reliable/relack.hpp	/^#define OPENVPN_RELIABLE_RELACK_H$/;"	d
OPENVPN_RELIABLE_RELCOMMON_H	reliable/relcommon.hpp	/^#define OPENVPN_RELIABLE_RELCOMMON_H$/;"	d
OPENVPN_RELIABLE_RELRECV_H	reliable/relrecv.hpp	/^#define OPENVPN_RELIABLE_RELRECV_H$/;"	d
OPENVPN_RELIABLE_RELSEND_H	reliable/relsend.hpp	/^#define OPENVPN_RELIABLE_RELSEND_H$/;"	d
OPENVPN_ROUNDUP	tun/mac/gwv4.hpp	/^#   define OPENVPN_ROUNDUP(/;"	d
OPENVPN_ROUNDUP	tun/mac/gwv4.hpp	/^#   undef OPENVPN_ROUNDUP$/;"	d
OPENVPN_SERVER_LISTENLIST_H	server/listenlist.hpp	/^#define OPENVPN_SERVER_LISTENLIST_H$/;"	d
OPENVPN_SERVER_MANAGE_H	server/manage.hpp	/^#define OPENVPN_SERVER_MANAGE_H$/;"	d
OPENVPN_SERVER_PEERADDR_H	server/peeraddr.hpp	/^#define OPENVPN_SERVER_PEERADDR_H$/;"	d
OPENVPN_SERVER_PEERSTATS_H	server/peerstats.hpp	/^#define OPENVPN_SERVER_PEERSTATS_H$/;"	d
OPENVPN_SERVER_SERVHALT_H	server/servhalt.hpp	/^#define OPENVPN_SERVER_SERVHALT_H$/;"	d
OPENVPN_SERVER_SERVPROTO_H	server/servproto.hpp	/^#define OPENVPN_SERVER_SERVPROTO_H$/;"	d
OPENVPN_SERVER_VPNSERVNETBLOCK_H	server/vpnservnetblock.hpp	/^#define OPENVPN_SERVER_VPNSERVNETBLOCK_H$/;"	d
OPENVPN_SERVER_VPNSERVPOOL_H	server/vpnservpool.hpp	/^#define OPENVPN_SERVER_VPNSERVPOOL_H$/;"	d
OPENVPN_SIMPLE_EXCEPTION	common/exception.hpp	/^# define OPENVPN_SIMPLE_EXCEPTION(/;"	d
OPENVPN_SIMPLE_EXCEPTION_INHERIT	common/exception.hpp	/^# define OPENVPN_SIMPLE_EXCEPTION_INHERIT(/;"	d
OPENVPN_SSL_DATALIMIT_H	ssl/datalimit.hpp	/^#define OPENVPN_SSL_DATALIMIT_H$/;"	d
OPENVPN_SSL_IS_OPENVPN_PROTOCOL_H	ssl/is_openvpn_protocol.hpp	/^#define OPENVPN_SSL_IS_OPENVPN_PROTOCOL_H$/;"	d
OPENVPN_SSL_KUPARSE_H	ssl/kuparse.hpp	/^#define OPENVPN_SSL_KUPARSE_H$/;"	d
OPENVPN_SSL_MSSPARMS_H	ssl/mssparms.hpp	/^#define OPENVPN_SSL_MSSPARMS_H$/;"	d
OPENVPN_SSL_NSCERT_H	ssl/nscert.hpp	/^#define OPENVPN_SSL_NSCERT_H$/;"	d
OPENVPN_SSL_PEERINFO_H	ssl/peerinfo.hpp	/^#define OPENVPN_SSL_PEERINFO_H$/;"	d
OPENVPN_SSL_PROTOSTACK_H	ssl/protostack.hpp	/^#define OPENVPN_SSL_PROTOSTACK_H$/;"	d
OPENVPN_SSL_PROTO_CONTEXT_OPTIONS_H	ssl/proto_context_options.hpp	/^#define OPENVPN_SSL_PROTO_CONTEXT_OPTIONS_H$/;"	d
OPENVPN_SSL_PROTO_H	ssl/proto.hpp	/^#define OPENVPN_SSL_PROTO_H$/;"	d
OPENVPN_SSL_PSID_H	ssl/psid.hpp	/^#define OPENVPN_SSL_PSID_H$/;"	d
OPENVPN_SSL_SSLAPI_H	ssl/sslapi.hpp	/^#define OPENVPN_SSL_SSLAPI_H$/;"	d
OPENVPN_SSL_SSLCHOOSE_H	ssl/sslchoose.hpp	/^#define OPENVPN_SSL_SSLCHOOSE_H$/;"	d
OPENVPN_SSL_SSLCONSTS_H	ssl/sslconsts.hpp	/^#define OPENVPN_SSL_SSLCONSTS_H$/;"	d
OPENVPN_SSL_TLSPRF_H	ssl/tlsprf.hpp	/^#define OPENVPN_SSL_TLSPRF_H$/;"	d
OPENVPN_SSL_TLSVER_H	ssl/tlsver.hpp	/^#define OPENVPN_SSL_TLSVER_H$/;"	d
OPENVPN_SSL_TLS_REMOTE_H	ssl/tls_remote.hpp	/^#define OPENVPN_SSL_TLS_REMOTE_H$/;"	d
OPENVPN_STRINGIZE	common/stringize.hpp	/^#define OPENVPN_STRINGIZE(/;"	d
OPENVPN_STRINGIZE2	common/stringize.hpp	/^#define OPENVPN_STRINGIZE2(/;"	d
OPENVPN_THROW	common/exception.hpp	/^# define OPENVPN_THROW(/;"	d
OPENVPN_THROW_EXCEPTION	common/exception.hpp	/^# define OPENVPN_THROW_EXCEPTION(/;"	d
OPENVPN_THROW_WEB	http/webexcept.hpp	/^# define OPENVPN_THROW_WEB(/;"	d
OPENVPN_TIME_ASIOTIMER_H	time/asiotimer.hpp	/^#define OPENVPN_TIME_ASIOTIMER_H$/;"	d
OPENVPN_TIME_COARSETIME_H	time/coarsetime.hpp	/^#define OPENVPN_TIME_COARSETIME_H$/;"	d
OPENVPN_TIME_DURHELPER_H	time/durhelper.hpp	/^#define OPENVPN_TIME_DURHELPER_H$/;"	d
OPENVPN_TIME_REL	time/time.hpp	/^#   define OPENVPN_TIME_REL(/;"	d
OPENVPN_TIME_REL	time/time.hpp	/^#   undef OPENVPN_TIME_REL$/;"	d
OPENVPN_TIME_TIMESTR_H	time/timestr.hpp	/^#define OPENVPN_TIME_TIMESTR_H$/;"	d
OPENVPN_TIME_TIME_H	time/time.hpp	/^#define OPENVPN_TIME_TIME_H$/;"	d
OPENVPN_TRANSPORT_ALTPROXY_H	transport/altproxy.hpp	/^#define OPENVPN_TRANSPORT_ALTPROXY_H$/;"	d
OPENVPN_TRANSPORT_CLIENT_HTTPCLI_H	transport/client/httpcli.hpp	/^#define OPENVPN_TRANSPORT_CLIENT_HTTPCLI_H$/;"	d
OPENVPN_TRANSPORT_CLIENT_TCPCLI_H	transport/client/tcpcli.hpp	/^#define OPENVPN_TRANSPORT_CLIENT_TCPCLI_H$/;"	d
OPENVPN_TRANSPORT_CLIENT_TRANSBASE_H	transport/client/transbase.hpp	/^#define OPENVPN_TRANSPORT_CLIENT_TRANSBASE_H$/;"	d
OPENVPN_TRANSPORT_CLIENT_UDPCLI_H	transport/client/udpcli.hpp	/^#define OPENVPN_TRANSPORT_CLIENT_UDPCLI_H$/;"	d
OPENVPN_TRANSPORT_DCO_H	transport/dco.hpp	/^#define OPENVPN_TRANSPORT_DCO_H$/;"	d
OPENVPN_TRANSPORT_GREMLIN_H	transport/gremlin.hpp	/^#define OPENVPN_TRANSPORT_GREMLIN_H$/;"	d
OPENVPN_TRANSPORT_MUTATE_H	transport/mutate.hpp	/^#define OPENVPN_TRANSPORT_MUTATE_H$/;"	d
OPENVPN_TRANSPORT_PKTSTREAM_H	transport/pktstream.hpp	/^#define OPENVPN_TRANSPORT_PKTSTREAM_H$/;"	d
OPENVPN_TRANSPORT_PROTOCOL_H	transport/protocol.hpp	/^#define OPENVPN_TRANSPORT_PROTOCOL_H$/;"	d
OPENVPN_TRANSPORT_RECONNECT_NOTIFY_H	transport/reconnect_notify.hpp	/^#define OPENVPN_TRANSPORT_RECONNECT_NOTIFY_H$/;"	d
OPENVPN_TRANSPORT_SERVER_TRANSBASE_H	transport/server/transbase.hpp	/^#define OPENVPN_TRANSPORT_SERVER_TRANSBASE_H$/;"	d
OPENVPN_TRANSPORT_SOCKET_PROTECT_H	transport/socket_protect.hpp	/^#define OPENVPN_TRANSPORT_SOCKET_PROTECT_H$/;"	d
OPENVPN_TRANSPORT_TCPLINK_H	transport/tcplink.hpp	/^#define OPENVPN_TRANSPORT_TCPLINK_H$/;"	d
OPENVPN_TRANSPORT_UDPLINK_H	transport/udplink.hpp	/^#define OPENVPN_TRANSPORT_UDPLINK_H$/;"	d
OPENVPN_TUN_BUILDER_BASE_H	tun/builder/base.hpp	/^#define OPENVPN_TUN_BUILDER_BASE_H$/;"	d
OPENVPN_TUN_BUILDER_CAPTURE_H	tun/builder/capture.hpp	/^#define OPENVPN_TUN_BUILDER_CAPTURE_H$/;"	d
OPENVPN_TUN_BUILDER_CLIENT_H	tun/builder/client.hpp	/^#define OPENVPN_TUN_BUILDER_CLIENT_H$/;"	d
OPENVPN_TUN_BUILDER_RGWFLAGS_H	tun/builder/rgwflags.hpp	/^#define OPENVPN_TUN_BUILDER_RGWFLAGS_H$/;"	d
OPENVPN_TUN_BUILDER_SETUP_H	tun/builder/setup.hpp	/^#define OPENVPN_TUN_BUILDER_SETUP_H$/;"	d
OPENVPN_TUN_CLIENT_DHCP_CAPTURE_H	tun/client/dhcp_capture.hpp	/^#define OPENVPN_TUN_CLIENT_DHCP_CAPTURE_H$/;"	d
OPENVPN_TUN_CLIENT_EMUEXR_H	tun/client/emuexr.hpp	/^#define OPENVPN_TUN_CLIENT_EMUEXR_H$/;"	d
OPENVPN_TUN_CLIENT_TUNBASE_H	tun/client/tunbase.hpp	/^#define OPENVPN_TUN_CLIENT_TUNBASE_H$/;"	d
OPENVPN_TUN_CLIENT_TUNNULL_H	tun/client/tunnull.hpp	/^#define OPENVPN_TUN_CLIENT_TUNNULL_H$/;"	d
OPENVPN_TUN_CLIENT_TUNPROP_H	tun/client/tunprop.hpp	/^#define OPENVPN_TUN_CLIENT_TUNPROP_H$/;"	d
OPENVPN_TUN_IPv6_SETTING_H	tun/ipv6_setting.hpp	/^#define OPENVPN_TUN_IPv6_SETTING_H$/;"	d
OPENVPN_TUN_LAYER_H	tun/layer.hpp	/^#define OPENVPN_TUN_LAYER_H$/;"	d
OPENVPN_TUN_LINUX_CLIENT_TUNCLI_H	tun/linux/client/tuncli.hpp	/^#define OPENVPN_TUN_LINUX_CLIENT_TUNCLI_H$/;"	d
OPENVPN_TUN_LINUX_TUN_H	tun/linux/tun.hpp	/^#define OPENVPN_TUN_LINUX_TUN_H$/;"	d
OPENVPN_TUN_MAC_CLIENT_TUNCLI_H	tun/mac/client/tuncli.hpp	/^#define OPENVPN_TUN_MAC_CLIENT_TUNCLI_H$/;"	d
OPENVPN_TUN_MAC_CLIENT_TUNSETUP_H	tun/mac/client/tunsetup.hpp	/^#define OPENVPN_TUN_MAC_CLIENT_TUNSETUP_H$/;"	d
OPENVPN_TUN_MAC_GWV4_H	tun/mac/gwv4.hpp	/^#define OPENVPN_TUN_MAC_GWV4_H$/;"	d
OPENVPN_TUN_MAC_MACDNS_H	tun/mac/macdns.hpp	/^#define OPENVPN_TUN_MAC_MACDNS_H$/;"	d
OPENVPN_TUN_MAC_MACDNS_WATCHDOG_H	tun/mac/macdns_watchdog.hpp	/^#define OPENVPN_TUN_MAC_MACDNS_WATCHDOG_H$/;"	d
OPENVPN_TUN_MAC_MACGW_H	tun/mac/macgw.hpp	/^#define OPENVPN_TUN_MAC_MACGW_H$/;"	d
OPENVPN_TUN_MAC_TUNUTIL_H	tun/mac/tunutil.hpp	/^#define OPENVPN_TUN_MAC_TUNUTIL_H$/;"	d
OPENVPN_TUN_MAC_UTUN_H	tun/mac/utun.hpp	/^#define OPENVPN_TUN_MAC_UTUN_H$/;"	d
OPENVPN_TUN_PERSIST_TUNPERSIST_H	tun/persist/tunpersist.hpp	/^#define OPENVPN_TUN_PERSIST_TUNPERSIST_H$/;"	d
OPENVPN_TUN_PERSIST_TUNWRAPASIO_H	tun/persist/tunwrapasio.hpp	/^#define OPENVPN_TUN_PERSIST_TUNWRAPASIO_H$/;"	d
OPENVPN_TUN_PERSIST_TUNWRAP_H	tun/persist/tunwrap.hpp	/^#define OPENVPN_TUN_PERSIST_TUNWRAP_H$/;"	d
OPENVPN_TUN_SERVER_TUNBASE_H	tun/server/tunbase.hpp	/^#define OPENVPN_TUN_SERVER_TUNBASE_H$/;"	d
OPENVPN_TUN_TUNIO_H	tun/tunio.hpp	/^#define OPENVPN_TUN_TUNIO_H$/;"	d
OPENVPN_TUN_TUNLOG_H	tun/tunlog.hpp	/^#define OPENVPN_TUN_TUNLOG_H$/;"	d
OPENVPN_TUN_TUNMTU_H	tun/tunmtu.hpp	/^#define OPENVPN_TUN_TUNMTU_H$/;"	d
OPENVPN_TUN_TUNSPEC_H	tun/tunspec.hpp	/^#define OPENVPN_TUN_TUNSPEC_H$/;"	d
OPENVPN_TUN_WIN_CLIENT_SETUPBASE_H	tun/win/client/setupbase.hpp	/^#define OPENVPN_TUN_WIN_CLIENT_SETUPBASE_H$/;"	d
OPENVPN_TUN_WIN_CLIENT_TUNCLI_H	tun/win/client/tuncli.hpp	/^#define OPENVPN_TUN_WIN_CLIENT_TUNCLI_H$/;"	d
OPENVPN_TUN_WIN_CLIENT_TUNSETUP_H	tun/win/client/tunsetup.hpp	/^#define OPENVPN_TUN_WIN_CLIENT_TUNSETUP_H$/;"	d
OPENVPN_TUN_WIN_NRPT_H	tun/win/nrpt.hpp	/^#define OPENVPN_TUN_WIN_NRPT_H$/;"	d
OPENVPN_TUN_WIN_TUNUTIL_H	tun/win/tunutil.hpp	/^#define OPENVPN_TUN_WIN_TUNUTIL_H$/;"	d
OPENVPN_TUN_WIN_WFP_H	tun/win/wfp.hpp	/^#define OPENVPN_TUN_WIN_WFP_H$/;"	d
OPENVPN_UNTAGGED_EXCEPTION	common/exception.hpp	/^# define OPENVPN_UNTAGGED_EXCEPTION(/;"	d
OPENVPN_UNTAGGED_EXCEPTION_INHERIT	common/exception.hpp	/^# define OPENVPN_UNTAGGED_EXCEPTION_INHERIT(/;"	d
OPENVPN_UNUSED_OPTIONS	client/cliopt.hpp	/^#define OPENVPN_UNUSED_OPTIONS /;"	d
OPENVPN_VERSION	common/version.hpp	/^#define OPENVPN_VERSION /;"	d
OPENVPN_WIN_CALL_H	win/call.hpp	/^#define OPENVPN_WIN_CALL_H$/;"	d
OPENVPN_WIN_CMD_H	win/cmd.hpp	/^#define OPENVPN_WIN_CMD_H$/;"	d
OPENVPN_WIN_CONSOLE_H	win/console.hpp	/^#define OPENVPN_WIN_CONSOLE_H$/;"	d
OPENVPN_WIN_HANDLE_H	win/handle.hpp	/^#define OPENVPN_WIN_HANDLE_H$/;"	d
OPENVPN_WIN_MODNAME_H	win/modname.hpp	/^#define OPENVPN_WIN_MODNAME_H$/;"	d
OPENVPN_WIN_REG_H	win/reg.hpp	/^#define OPENVPN_WIN_REG_H$/;"	d
OPENVPN_WIN_SCOPED_HANDLE_H	win/scoped_handle.hpp	/^#define OPENVPN_WIN_SCOPED_HANDLE_H$/;"	d
OPENVPN_WIN_SLEEP_H	win/sleep.hpp	/^#define OPENVPN_WIN_SLEEP_H$/;"	d
OPENVPN_WIN_UNICODE_H	win/unicode.hpp	/^#define OPENVPN_WIN_UNICODE_H$/;"	d
OPENVPN_WIN_WINERR_H	win/winerr.hpp	/^#define OPENVPN_WIN_WINERR_H$/;"	d
OPT_OPTIONAL	common/userpass.hpp	/^      OPT_OPTIONAL = (1<<1),        \/\/ if option is not present, USERNAME_REQUIRED and PASSWORD_REQUIRED are ignored$/;"	e	enum:openvpn::UserPass::Flags
OPT_OVERHEAD	client/cliconstants.hpp	/^      OPT_OVERHEAD=64,         \/\/ bytes overhead of one option\/directive, for accounting purposes$/;"	e	enum:openvpn::ProfileParseLimits::__anon15
OPT_RENDER_FLAGS	tun/client/tunprop.hpp	/^      OPT_RENDER_FLAGS = Option::RENDER_TRUNC_64 | Option::RENDER_BRACKET$/;"	e	enum:openvpn::TunProp::__anon89
OPT_REQUIRED	common/userpass.hpp	/^      OPT_REQUIRED = (1<<0),        \/\/ option must be present$/;"	e	enum:openvpn::UserPass::Flags
OP_PEER_ID_UNDEF	ssl/proto.hpp	/^      OP_PEER_ID_UNDEF = 0x00FFFFFF, \/\/ indicates that Peer ID is undefined$/;"	e	enum:openvpn::ProtoContext::__anon80
OP_SIZE_V2	ssl/proto.hpp	/^      OP_SIZE_V2 = 4,                \/\/ size of initial packet opcode$/;"	e	enum:openvpn::ProtoContext::__anon80
OSI_LAYER_2	tun/layer.hpp	/^      OSI_LAYER_2,$/;"	e	enum:openvpn::Layer::Type
OSI_LAYER_3	tun/layer.hpp	/^      OSI_LAYER_3,$/;"	e	enum:openvpn::Layer::Type
OSX_10_10	apple/macver.hpp	/^	OSX_10_10=14,$/;"	e	enum:openvpn::Mac::Version::__anon6
OSX_10_11	apple/macver.hpp	/^	OSX_10_11=15,$/;"	e	enum:openvpn::Mac::Version::__anon6
OSX_10_6	apple/macver.hpp	/^	OSX_10_6=10,$/;"	e	enum:openvpn::Mac::Version::__anon6
OSX_10_7	apple/macver.hpp	/^	OSX_10_7=11,$/;"	e	enum:openvpn::Mac::Version::__anon6
OSX_10_8	apple/macver.hpp	/^	OSX_10_8=12,$/;"	e	enum:openvpn::Mac::Version::__anon6
OSX_10_9	apple/macver.hpp	/^	OSX_10_9=13,$/;"	e	enum:openvpn::Mac::Version::__anon6
OTHER	auth/authcert.hpp	/^	  OTHER,$/;"	e	enum:openvpn::AuthCert::Fail::Type
OTHER	http/method.hpp	/^	OTHER,$/;"	e	enum:openvpn::HTTP::Method::Type
OU	pki/x509track.hpp	/^      OU,$/;"	e	enum:openvpn::X509Track::Type
OVPN_COMPv2_LZ4	compress/compress.hpp	/^      OVPN_COMPv2_LZ4=1,$/;"	e	enum:openvpn::Compress::__anon31
OVPN_COMPv2_NONE	compress/compress.hpp	/^      OVPN_COMPv2_NONE=0,$/;"	e	enum:openvpn::Compress::__anon31
OWN	applecrypto/cf/cf.hpp	/^      OWN,$/;"	e	enum:openvpn::CF::Own
O_BANG	http/htmlskip.hpp	/^	O_BANG,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_DOCTYPE_C	http/htmlskip.hpp	/^	O_DOCTYPE_C,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_DOCTYPE_D	http/htmlskip.hpp	/^	O_DOCTYPE_D,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_DOCTYPE_O	http/htmlskip.hpp	/^	O_DOCTYPE_O,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_DOCTYPE_P	http/htmlskip.hpp	/^	O_DOCTYPE_P,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_DOCTYPE_SPACE	http/htmlskip.hpp	/^	O_DOCTYPE_SPACE,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_DOCTYPE_T	http/htmlskip.hpp	/^	O_DOCTYPE_T,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_DOCTYPE_Y	http/htmlskip.hpp	/^	O_DOCTYPE_Y,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_HTML_H	http/htmlskip.hpp	/^	O_HTML_H,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_HTML_M	http/htmlskip.hpp	/^	O_HTML_M,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_HTML_T	http/htmlskip.hpp	/^	O_HTML_T,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
O_OPEN	http/htmlskip.hpp	/^	O_OPEN,$/;"	e	enum:openvpn::HTTP::HTMLSkip::State
OpenSSLContext	openssl/ssl/sslctx.hpp	/^    OpenSSLContext(Config* config_arg)$/;"	f	class:openvpn::OpenSSLContext
OpenSSLContext	openssl/ssl/sslctx.hpp	/^  class OpenSSLContext : public SSLFactoryAPI$/;"	c	namespace:openvpn
OpenSSLCrypto	openssl/crypto/cipher.hpp	/^  namespace OpenSSLCrypto {$/;"	n	namespace:openvpn
OpenSSLCrypto	openssl/crypto/ciphergcm.hpp	/^  namespace OpenSSLCrypto {$/;"	n	namespace:openvpn
OpenSSLCrypto	openssl/crypto/digest.hpp	/^  namespace OpenSSLCrypto {$/;"	n	namespace:openvpn
OpenSSLCrypto	openssl/crypto/hmac.hpp	/^  namespace OpenSSLCrypto {$/;"	n	namespace:openvpn
OpenSSLCryptoAPI	openssl/crypto/api.hpp	/^  struct OpenSSLCryptoAPI {$/;"	s	namespace:openvpn
OpenSSLException	openssl/util/error.hpp	/^    OpenSSLException()$/;"	f	class:openvpn::OpenSSLException
OpenSSLException	openssl/util/error.hpp	/^    explicit OpenSSLException(const int ssl_error)$/;"	f	class:openvpn::OpenSSLException
OpenSSLException	openssl/util/error.hpp	/^    explicit OpenSSLException(const std::string error_text)$/;"	f	class:openvpn::OpenSSLException
OpenSSLException	openssl/util/error.hpp	/^    explicit OpenSSLException(const std::string error_text, const int ssl_error)$/;"	f	class:openvpn::OpenSSLException
OpenSSLException	openssl/util/error.hpp	/^  class OpenSSLException : public ExceptionCode$/;"	c	namespace:openvpn
OpenSSLPKI	openssl/pki/crl.hpp	/^  namespace OpenSSLPKI {$/;"	n	namespace:openvpn
OpenSSLPKI	openssl/pki/dh.hpp	/^  namespace OpenSSLPKI {$/;"	n	namespace:openvpn
OpenSSLPKI	openssl/pki/pkey.hpp	/^  namespace OpenSSLPKI {$/;"	n	namespace:openvpn
OpenSSLPKI	openssl/pki/x509.hpp	/^  namespace OpenSSLPKI {$/;"	n	namespace:openvpn
OpenSSLPKI	openssl/pki/x509store.hpp	/^  namespace OpenSSLPKI {$/;"	n	namespace:openvpn
OpenSSLRandom	openssl/util/rand.hpp	/^    OpenSSLRandom(const bool prng)$/;"	f	class:openvpn::OpenSSLRandom
OpenSSLRandom	openssl/util/rand.hpp	/^  class OpenSSLRandom : public RandomAPI$/;"	c	namespace:openvpn
OpenSSLSign	openssl/sign/pkcs7verify.hpp	/^  namespace OpenSSLSign {$/;"	n	namespace:openvpn
OpenSSLSign	openssl/sign/verify.hpp	/^  namespace OpenSSLSign {$/;"	n	namespace:openvpn
OpenVPNStaticKey	crypto/static_key.hpp	/^  class OpenVPNStaticKey$/;"	c	namespace:openvpn
Option	common/options.hpp	/^    Option()$/;"	f	class:openvpn::Option
Option	common/options.hpp	/^    Option(T first, Args... args)$/;"	f	class:openvpn::Option
Option	common/options.hpp	/^  class Option$/;"	c	namespace:openvpn
OptionList	common/options.hpp	/^  class OptionList : public std::vector<Option>, public RCCopyable<thread_unsafe_refcount>$/;"	c	namespace:openvpn
OptionListContinuation	options/continuation.hpp	/^    OptionListContinuation(const PushOptionsBase::Ptr& push_base_arg)$/;"	f	class:openvpn::OptionListContinuation
OptionListContinuation	options/continuation.hpp	/^  class OptionListContinuation : public OptionList$/;"	c	namespace:openvpn
Options	transport/client/httpcli.hpp	/^      Options() : allow_cleartext_auth(false) {}$/;"	f	class:openvpn::HTTPProxyTransport::Options
Options	transport/client/httpcli.hpp	/^    class Options : public RC<thread_safe_refcount>$/;"	c	namespace:openvpn::HTTPProxyTransport
Output	common/format.hpp	/^      Output(const size_t reserve)$/;"	f	class:openvpn::print_formatted_detail::Output
Output	common/format.hpp	/^    class Output {};$/;"	c	namespace:openvpn::print_formatted_detail
Output	common/format.hpp	/^    class Output<std::ostringstream>$/;"	c	namespace:openvpn::print_formatted_detail
Output	common/format.hpp	/^    class Output<std::string>$/;"	c	namespace:openvpn::print_formatted_detail
OvpnHMAC	crypto/ovpnhmac.hpp	/^    OvpnHMAC() {}$/;"	f	class:openvpn::OvpnHMAC
OvpnHMAC	crypto/ovpnhmac.hpp	/^    OvpnHMAC(const CryptoAlgs::Type digest, const StaticKey& key)$/;"	f	class:openvpn::OvpnHMAC
OvpnHMAC	crypto/ovpnhmac.hpp	/^  class OvpnHMAC$/;"	c	namespace:openvpn
OvpnHMACContext	crypto/ovpnhmac.hpp	/^  class OvpnHMACContext : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
OvpnHMACFactory	crypto/ovpnhmac.hpp	/^  class OvpnHMACFactory : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
OvpnHMACInstance	crypto/ovpnhmac.hpp	/^  class OvpnHMACInstance : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
Own	applecrypto/cf/cf.hpp	/^    enum Own {$/;"	g	namespace:openvpn::CF
PACKETS_IN	log/sessionstats.hpp	/^      PACKETS_IN,          \/\/ network packets in$/;"	e	enum:openvpn::SessionStats::Stats
PACKETS_OUT	log/sessionstats.hpp	/^      PACKETS_OUT,         \/\/ network packets out$/;"	e	enum:openvpn::SessionStats::Stats
PARTIAL	applecrypto/crypto/hmac.hpp	/^	PARTIAL,$/;"	e	enum:openvpn::AppleCrypto::HMACContext::State
PASSWORD_REQUIRED	common/userpass.hpp	/^      PASSWORD_REQUIRED = (1<<3),   \/\/ password must be present$/;"	e	enum:openvpn::UserPass::Flags
PAUSE	client/clievent.hpp	/^      PAUSE,$/;"	e	enum:openvpn::ClientEvent::Type
PEER_CLOSE_NOTIFY	ssl/sslconsts.hpp	/^      PEER_CLOSE_NOTIFY = -2,$/;"	e	enum:openvpn::SSLConst::__anon83
PEM_PASSWORD_FAIL	error/error.hpp	/^      PEM_PASSWORD_FAIL,   \/\/ incorrect or missing PEM private key decryption password$/;"	e	enum:openvpn::Error::Type
PENDING	http/htmlskip.hpp	/^	PENDING,$/;"	e	enum:openvpn::HTTP::HTMLSkip::Status
PKCS1	pki/pkcs1.hpp	/^  namespace PKCS1 {$/;"	n	namespace:openvpn
PKContext	polarssl/pki/pkctx.hpp	/^      PKContext() : ctx(nullptr) {}$/;"	f	class:openvpn::PolarSSLPKI::PKContext
PKContext	polarssl/pki/pkctx.hpp	/^      PKContext(const std::string& key_txt, const std::string& title, const std::string& priv_key_pwd)$/;"	f	class:openvpn::PolarSSLPKI::PKContext
PKContext	polarssl/pki/pkctx.hpp	/^    class PKContext : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::PolarSSLPKI
PKTID_BACKTRACK	error/error.hpp	/^      PKTID_BACKTRACK,$/;"	e	enum:openvpn::Error::Type
PKTID_EXPIRE	error/error.hpp	/^      PKTID_EXPIRE,$/;"	e	enum:openvpn::Error::Type
PKTID_INVALID	error/error.hpp	/^      PKTID_INVALID,$/;"	e	enum:openvpn::Error::Type
PKTID_REPLAY	error/error.hpp	/^      PKTID_REPLAY,$/;"	e	enum:openvpn::Error::Type
PKTID_TIME_BACKTRACK	error/error.hpp	/^      PKTID_TIME_BACKTRACK,$/;"	e	enum:openvpn::Error::Type
PKey	openssl/pki/pkey.hpp	/^      PKey() : pkey_(nullptr) {}$/;"	f	class:openvpn::OpenSSLPKI::PKey
PKey	openssl/pki/pkey.hpp	/^      PKey(const PKey& other)$/;"	f	class:openvpn::OpenSSLPKI::PKey
PKey	openssl/pki/pkey.hpp	/^      PKey(const std::string& pkey_txt, const std::string& title)$/;"	f	class:openvpn::OpenSSLPKI::PKey
PKey	openssl/pki/pkey.hpp	/^    class PKey$/;"	c	namespace:openvpn::OpenSSLPKI
POST	http/method.hpp	/^	POST,$/;"	e	enum:openvpn::HTTP::Method::Type
PRE	applecrypto/crypto/hmac.hpp	/^	PRE=0,$/;"	e	enum:openvpn::AppleCrypto::HMACContext::State
PRF	ssl/tlsprf.hpp	/^    static void PRF (unsigned char *label,$/;"	f	class:openvpn::TLSPRF
PRIMARY_EXPIRE	error/error.hpp	/^      PRIMARY_EXPIRE,      \/\/ primary key context expired$/;"	e	enum:openvpn::Error::Type
PROMOTE_SECONDARY_TO_PRIMARY	crypto/cryptodc.hpp	/^      PROMOTE_SECONDARY_TO_PRIMARY,$/;"	e	enum:openvpn::CryptoDCInstance::RekeyType
PROXY_ERROR	client/clievent.hpp	/^      PROXY_ERROR,$/;"	e	enum:openvpn::ClientEvent::Type
PROXY_ERROR	error/error.hpp	/^      PROXY_ERROR,         \/\/ HTTP proxy error$/;"	e	enum:openvpn::Error::Type
PROXY_NEED_CREDS	client/clievent.hpp	/^      PROXY_NEED_CREDS,$/;"	e	enum:openvpn::ClientEvent::Type
PROXY_NEED_CREDS	error/error.hpp	/^      PROXY_NEED_CREDS,    \/\/ HTTP proxy needs credentials$/;"	e	enum:openvpn::Error::Type
PThreadBarrier	common/pthreadcond.hpp	/^    PThreadBarrier(Stop* stop_arg, const int initial_limit = -1)$/;"	f	class:openvpn::PThreadBarrier
PThreadBarrier	common/pthreadcond.hpp	/^    PThreadBarrier(const int initial_limit = -1)$/;"	f	class:openvpn::PThreadBarrier
PThreadBarrier	common/pthreadcond.hpp	/^  class PThreadBarrier$/;"	c	namespace:openvpn
Packet	ssl/proto.hpp	/^      Packet()$/;"	f	class:openvpn::ProtoContext::Packet
Packet	ssl/proto.hpp	/^      Packet(BufferPtr&& buf_arg, const unsigned int opcode_arg = CONTROL_V1)$/;"	f	class:openvpn::ProtoContext::Packet
Packet	ssl/proto.hpp	/^    class Packet$/;"	c	class:openvpn::ProtoContext
PacketFrom	transport/tcplink.hpp	/^    struct PacketFrom$/;"	s	namespace:openvpn::TCPTransport
PacketFrom	transport/udplink.hpp	/^    struct PacketFrom$/;"	s	namespace:openvpn::UDPTransport
PacketFrom	tun/builder/client.hpp	/^    struct PacketFrom$/;"	s	namespace:openvpn::TunBuilderClient
PacketFrom	tun/linux/tun.hpp	/^    struct PacketFrom$/;"	s	namespace:openvpn::TunLinux
PacketFrom	tun/mac/client/tuncli.hpp	/^    struct PacketFrom$/;"	s	namespace:openvpn::TunMac
PacketFrom	tun/win/client/tuncli.hpp	/^    struct PacketFrom$/;"	s	namespace:openvpn::TunWin
PacketID	crypto/packet_id.hpp	/^  struct PacketID$/;"	s	namespace:openvpn
PacketIDConstruct	crypto/packet_id.hpp	/^    PacketIDConstruct(const PacketID::time_t v_time = PacketID::time_t(0), const PacketID::id_t v_id = PacketID::id_t(0))$/;"	f	struct:openvpn::PacketIDConstruct
PacketIDConstruct	crypto/packet_id.hpp	/^  struct PacketIDConstruct : public PacketID$/;"	s	namespace:openvpn
PacketIDReceive	crypto/packet_id.hpp	/^  typedef PacketIDReceiveType<8, 30> PacketIDReceive;$/;"	t	namespace:openvpn
PacketIDReceiveType	crypto/packet_id.hpp	/^    PacketIDReceiveType()$/;"	f	class:openvpn::PacketIDReceiveType
PacketIDReceiveType	crypto/packet_id.hpp	/^  class PacketIDReceiveType$/;"	c	namespace:openvpn
PacketIDSend	crypto/packet_id.hpp	/^    PacketIDSend()$/;"	f	class:openvpn::PacketIDSend
PacketIDSend	crypto/packet_id.hpp	/^  class PacketIDSend$/;"	c	namespace:openvpn
PacketStream	transport/pktstream.hpp	/^    PacketStream() : declared_size_defined(false) {}$/;"	f	class:openvpn::PacketStream
PacketStream	transport/pktstream.hpp	/^  class PacketStream$/;"	c	namespace:openvpn
PacketType	client/cliproto.hpp	/^      typedef Base::PacketType PacketType;$/;"	t	class:openvpn::ClientProto::Session
PacketType	server/servproto.hpp	/^      typedef Base::PacketType PacketType;$/;"	t	class:openvpn::ServerProto::Session
PacketType	ssl/proto.hpp	/^      PacketType(const Buffer& buf, class ProtoContext& proto)$/;"	f	class:openvpn::ProtoContext::PacketType
PacketType	ssl/proto.hpp	/^    class PacketType$/;"	c	class:openvpn::ProtoContext
Parameters	ssl/datalimit.hpp	/^    struct Parameters$/;"	s	class:openvpn::DataLimit
Parm	http/urlparm.hpp	/^      Parm() {}$/;"	f	struct:openvpn::URL::Parm
Parm	http/urlparm.hpp	/^      Parm(const std::string& name_arg, const std::string& value_arg)$/;"	f	struct:openvpn::URL::Parm
Parm	http/urlparm.hpp	/^    struct Parm$/;"	s	namespace:openvpn::URL
ParmList	http/urlparm.hpp	/^      ParmList(const std::string& uri)$/;"	f	class:openvpn::URL::ParmList
ParmList	http/urlparm.hpp	/^    class ParmList : public std::vector<Parm>$/;"	c	namespace:openvpn::URL
Parse	http/urlparse.hpp	/^      Parse() {}$/;"	f	class:openvpn::URL::Parse
Parse	http/urlparse.hpp	/^      Parse(const std::string& url, const bool set_default_port=false)$/;"	f	class:openvpn::URL::Parse
Parse	http/urlparse.hpp	/^    class Parse$/;"	c	namespace:openvpn::URL
ParseClientConfig	client/cliopthelper.hpp	/^    ParseClientConfig()$/;"	f	class:openvpn::ParseClientConfig
ParseClientConfig	client/cliopthelper.hpp	/^    ParseClientConfig(const OptionList& options)$/;"	f	class:openvpn::ParseClientConfig
ParseClientConfig	client/cliopthelper.hpp	/^  class ParseClientConfig {$/;"	c	namespace:openvpn
ParseTunSpec	tun/tunspec.hpp	/^    ParseTunSpec(const std::string& tun_spec)$/;"	f	struct:openvpn::ParseTunSpec
ParseTunSpec	tun/tunspec.hpp	/^  struct ParseTunSpec$/;"	s	namespace:openvpn
Parser	http/reply.hpp	/^      typedef ReplyParser Parser;$/;"	t	struct:openvpn::HTTP::ReplyType
Parser	http/request.hpp	/^      typedef RequestParser Parser;$/;"	t	struct:openvpn::HTTP::RequestType
Pause	client/clievent.hpp	/^      Pause(std::string reason) : ReasonBase(PAUSE, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::Pause
Pause	client/clievent.hpp	/^    struct Pause : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
PeerAddr	server/peeraddr.hpp	/^    PeerAddr()$/;"	f	struct:openvpn::PeerAddr
PeerAddr	server/peeraddr.hpp	/^  struct PeerAddr : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
PeerInfo	ssl/peerinfo.hpp	/^  namespace PeerInfo {$/;"	n	namespace:openvpn
PeerStats	server/peerstats.hpp	/^    PeerStats()$/;"	f	struct:openvpn::PeerStats
PeerStats	server/peerstats.hpp	/^  struct PeerStats$/;"	s	namespace:openvpn
PerThread	server/vpnservnetblock.hpp	/^    class PerThread$/;"	c	class:openvpn::VPNServerNetblock
Period	log/logperiod.hpp	/^    enum Period {$/;"	g	class:openvpn::LogPeriod
PersistentFile	common/persistfile.hpp	/^    PersistentFile(const std::string& fn_arg)$/;"	f	class:openvpn::PersistentFile
PersistentFile	common/persistfile.hpp	/^  class PersistentFile$/;"	c	namespace:openvpn
PolarSSLContext	polarssl/ssl/sslctx.hpp	/^    PolarSSLContext(Config* config_arg)$/;"	f	class:openvpn::PolarSSLContext
PolarSSLContext	polarssl/ssl/sslctx.hpp	/^  class PolarSSLContext : public SSLFactoryAPI$/;"	c	namespace:openvpn
PolarSSLCrypto	polarssl/crypto/cipher.hpp	/^  namespace PolarSSLCrypto {$/;"	n	namespace:openvpn
PolarSSLCrypto	polarssl/crypto/ciphergcm.hpp	/^  namespace PolarSSLCrypto {$/;"	n	namespace:openvpn
PolarSSLCrypto	polarssl/crypto/digest.hpp	/^  namespace PolarSSLCrypto {$/;"	n	namespace:openvpn
PolarSSLCrypto	polarssl/crypto/hmac.hpp	/^  namespace PolarSSLCrypto {$/;"	n	namespace:openvpn
PolarSSLCryptoAPI	polarssl/crypto/api.hpp	/^  struct PolarSSLCryptoAPI {$/;"	s	namespace:openvpn
PolarSSLException	polarssl/util/error.hpp	/^    PolarSSLException()$/;"	f	class:openvpn::PolarSSLException
PolarSSLException	polarssl/util/error.hpp	/^    explicit PolarSSLException(const std::string& error_text)$/;"	f	class:openvpn::PolarSSLException
PolarSSLException	polarssl/util/error.hpp	/^    explicit PolarSSLException(const std::string& error_text, const Error::Type code, const bool fatal)$/;"	f	class:openvpn::PolarSSLException
PolarSSLException	polarssl/util/error.hpp	/^    explicit PolarSSLException(const std::string& error_text, const int polarssl_errnum)$/;"	f	class:openvpn::PolarSSLException
PolarSSLException	polarssl/util/error.hpp	/^  class PolarSSLException : public ExceptionCode$/;"	c	namespace:openvpn
PolarSSLPKI	polarssl/pki/dh.hpp	/^  namespace PolarSSLPKI {$/;"	n	namespace:openvpn
PolarSSLPKI	polarssl/pki/pkctx.hpp	/^  namespace PolarSSLPKI {$/;"	n	namespace:openvpn
PolarSSLPKI	polarssl/pki/x509cert.hpp	/^  namespace PolarSSLPKI {$/;"	n	namespace:openvpn
PolarSSLPKI	polarssl/pki/x509crl.hpp	/^  namespace PolarSSLPKI {$/;"	n	namespace:openvpn
PolarSSLRandom	polarssl/util/rand.hpp	/^    PolarSSLRandom(const bool prng)$/;"	f	class:openvpn::PolarSSLRandom
PolarSSLRandom	polarssl/util/rand.hpp	/^  class PolarSSLRandom : public RandomAPI$/;"	c	namespace:openvpn
Pool	addr/pool.hpp	/^    typedef PoolType<IP::Addr> Pool;$/;"	t	namespace:openvpn::IP
Pool	server/vpnservpool.hpp	/^      Pool(const OptionList& opt)$/;"	f	class:openvpn::VPNServerPool::Pool
Pool	server/vpnservpool.hpp	/^    class Pool : public VPNServerNetblock$/;"	c	namespace:openvpn::VPNServerPool
PoolType	addr/pool.hpp	/^      PoolType() {}$/;"	f	class:openvpn::IP::PoolType
PoolType	addr/pool.hpp	/^    class PoolType$/;"	c	namespace:openvpn::IP
PreResolve	client/remotelist.hpp	/^      PreResolve(asio::io_context& io_context_arg,$/;"	f	class:openvpn::RemoteList::PreResolve
PreResolve	client/remotelist.hpp	/^    class PreResolve : public RC<thread_unsafe_refcount>$/;"	c	class:openvpn::RemoteList
PreconditionFailed	http/status.hpp	/^	PreconditionFailed=412,$/;"	e	enum:openvpn::HTTP::Status::__anon45
PrintFormatted	common/format.hpp	/^    PrintFormatted(const std::string& fmt_arg, const size_t reserve)$/;"	f	class:openvpn::PrintFormatted
PrintFormatted	common/format.hpp	/^  class PrintFormatted$/;"	c	namespace:openvpn
ProfileMerge	options/merge.hpp	/^    ProfileMerge() : status_(MERGE_UNDEFINED) {}$/;"	f	class:openvpn::ProfileMerge
ProfileMerge	options/merge.hpp	/^    ProfileMerge(const std::string& profile_path,$/;"	f	class:openvpn::ProfileMerge
ProfileMerge	options/merge.hpp	/^  class ProfileMerge$/;"	c	namespace:openvpn
ProfileMergeFromString	options/merge.hpp	/^    ProfileMergeFromString(const std::string& profile_content,$/;"	f	class:openvpn::ProfileMergeFromString
ProfileMergeFromString	options/merge.hpp	/^  class ProfileMergeFromString : public ProfileMerge$/;"	c	namespace:openvpn
ProfileParseLimits	client/cliconstants.hpp	/^  namespace ProfileParseLimits {$/;"	n	namespace:openvpn
ProtoConfig	client/cliproto.hpp	/^      typedef Base::Config ProtoConfig;$/;"	t	class:openvpn::ClientProto::Session
ProtoConfig	server/servproto.hpp	/^      typedef Base::Config ProtoConfig;$/;"	t	class:openvpn::ServerProto::Factory
ProtoContext	ssl/proto.hpp	/^    ProtoContext(const Config::Ptr& config_arg,             \/\/ configuration$/;"	f	class:openvpn::ProtoContext
ProtoContext	ssl/proto.hpp	/^  class ProtoContext$/;"	c	namespace:openvpn
ProtoContextOptions	ssl/proto_context_options.hpp	/^    ProtoContextOptions() : compression_mode(COMPRESS_NO) {}$/;"	f	struct:openvpn::ProtoContextOptions
ProtoContextOptions	ssl/proto_context_options.hpp	/^  struct ProtoContextOptions : public RC<thread_safe_refcount>$/;"	s	namespace:openvpn
ProtoSessionID	ssl/psid.hpp	/^    ProtoSessionID()$/;"	f	class:openvpn::ProtoSessionID
ProtoSessionID	ssl/psid.hpp	/^    ProtoSessionID(const unsigned char *data)$/;"	f	class:openvpn::ProtoSessionID
ProtoSessionID	ssl/psid.hpp	/^    explicit ProtoSessionID(Buffer& buf)$/;"	f	class:openvpn::ProtoSessionID
ProtoSessionID	ssl/psid.hpp	/^  class ProtoSessionID$/;"	c	namespace:openvpn
ProtoStackBase	ssl/protostack.hpp	/^    ProtoStackBase(SSLFactoryAPI& ssl_factory, \/\/ SSL factory object that can be used to generate new SSL sessions$/;"	f	class:openvpn::ProtoStackBase
ProtoStackBase	ssl/protostack.hpp	/^  class ProtoStackBase$/;"	c	namespace:openvpn
Protocol	transport/protocol.hpp	/^    Protocol() : type_(NONE) {}$/;"	f	class:openvpn::Protocol
Protocol	transport/protocol.hpp	/^    explicit Protocol(const Type t) : type_(t) {}$/;"	f	class:openvpn::Protocol
Protocol	transport/protocol.hpp	/^  class Protocol$/;"	c	namespace:openvpn
ProxyAuthenticate	proxy/proxyauth.hpp	/^      ProxyAuthenticate() {}$/;"	f	class:openvpn::HTTPProxy::ProxyAuthenticate
ProxyAuthenticate	proxy/proxyauth.hpp	/^      ProxyAuthenticate(const std::string& line)$/;"	f	class:openvpn::HTTPProxy::ProxyAuthenticate
ProxyAuthenticate	proxy/proxyauth.hpp	/^    class ProxyAuthenticate : public RC<thread_unsafe_refcount> {$/;"	c	namespace:openvpn::HTTPProxy
ProxyAuthenticationRequired	http/status.hpp	/^	ProxyAuthenticationRequired=407,$/;"	e	enum:openvpn::HTTP::Status::__anon45
ProxyAutoConfigURL	tun/builder/capture.hpp	/^    class ProxyAutoConfigURL$/;"	c	class:openvpn::TunBuilderCapture
ProxyBypass	tun/builder/capture.hpp	/^    class ProxyBypass$/;"	c	class:openvpn::TunBuilderCapture
ProxyError	client/clievent.hpp	/^      ProxyError(std::string reason) : ReasonBase(PROXY_ERROR, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::ProxyError
ProxyError	client/clievent.hpp	/^    struct ProxyError : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
ProxyError	http/status.hpp	/^	ProxyError=502,$/;"	e	enum:openvpn::HTTP::Status::__anon45
ProxyHostPort	tun/builder/capture.hpp	/^    class ProxyHostPort$/;"	c	class:openvpn::TunBuilderCapture
ProxyNeedCreds	client/clievent.hpp	/^      ProxyNeedCreds(std::string reason) : ReasonBase(PROXY_NEED_CREDS, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::ProxyNeedCreds
ProxyNeedCreds	client/clievent.hpp	/^    struct ProxyNeedCreds : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
ProxyResponseLimit	transport/client/httpcli.hpp	/^	ProxyResponseLimit() : BufferLimit(1024, 65536) {}$/;"	f	struct:openvpn::HTTPProxyTransport::Client::ProxyResponseLimit
ProxyResponseLimit	transport/client/httpcli.hpp	/^      struct ProxyResponseLimit : public BufferLimit<size_t>$/;"	s	class:openvpn::HTTPProxyTransport::Client
Ptr	addr/addrlist.hpp	/^      typedef RCPtr<AddrList> Ptr;$/;"	t	class:openvpn::IP::AddrList
Ptr	applecrypto/ssl/sslctx.hpp	/^      typedef RCPtr<Config> Ptr;$/;"	t	class:openvpn::AppleSSLContext::Config
Ptr	applecrypto/ssl/sslctx.hpp	/^      typedef RCPtr<SSL> Ptr;$/;"	t	class:openvpn::AppleSSLContext::SSL
Ptr	applecrypto/ssl/sslctx.hpp	/^    typedef RCPtr<AppleSSLContext> Ptr;$/;"	t	class:openvpn::AppleSSLContext
Ptr	applecrypto/util/rand.hpp	/^    typedef RCPtr<AppleRandom> Ptr;$/;"	t	class:openvpn::AppleRandom
Ptr	auth/authcert.hpp	/^      typedef RCPtr<AuthCert> Ptr;$/;"	t	struct:openvpn::AuthCert
Ptr	auth/authcreds.hpp	/^      typedef RCPtr<AuthCreds> Ptr;$/;"	t	class:openvpn::AuthCreds
Ptr	auth/cr.hpp	/^    typedef RCPtr<ChallengeResponse> Ptr;$/;"	t	class:openvpn::ChallengeResponse
Ptr	client/cliconnect.hpp	/^    typedef RCPtr<ClientConnect> Ptr;$/;"	t	class:openvpn::ClientConnect
Ptr	client/clicreds.hpp	/^    typedef RCPtr<ClientCreds> Ptr;$/;"	t	class:openvpn::ClientCreds
Ptr	client/cliemuexr.hpp	/^    typedef RCPtr<EmulateExcludeRouteFactoryImpl> Ptr;$/;"	t	class:openvpn::EmulateExcludeRouteFactoryImpl
Ptr	client/cliemuexr.hpp	/^    typedef RCPtr<EmulateExcludeRouteImpl> Ptr;$/;"	t	class:openvpn::EmulateExcludeRouteImpl
Ptr	client/clievent.hpp	/^      typedef RCPtr<Base> Ptr;$/;"	t	class:openvpn::ClientEvent::Base
Ptr	client/clievent.hpp	/^      typedef RCPtr<Connected> Ptr;$/;"	t	struct:openvpn::ClientEvent::Connected
Ptr	client/clievent.hpp	/^      typedef RCPtr<Queue> Ptr;$/;"	t	class:openvpn::ClientEvent::Queue
Ptr	client/clilife.hpp	/^      typedef RCPtr<ClientLifeCycle> Ptr;$/;"	t	class:openvpn::ClientLifeCycle
Ptr	client/cliopt.hpp	/^    typedef RCPtr<ClientOptions> Ptr;$/;"	t	class:openvpn::ClientOptions
Ptr	client/cliproto.hpp	/^	typedef RCPtr<Config> Ptr;$/;"	t	struct:openvpn::ClientProto::Session::Config
Ptr	client/cliproto.hpp	/^      typedef RCPtr<Session> Ptr;$/;"	t	class:openvpn::ClientProto::Session
Ptr	client/remotelist.hpp	/^      typedef RCPtr<ConnBlock> Ptr;$/;"	t	struct:openvpn::RemoteList::ConnBlock
Ptr	client/remotelist.hpp	/^      typedef RCPtr<ConnBlockFactory> Ptr;$/;"	t	struct:openvpn::RemoteList::ConnBlockFactory
Ptr	client/remotelist.hpp	/^      typedef RCPtr<Item> Ptr;$/;"	t	struct:openvpn::RemoteList::Item
Ptr	client/remotelist.hpp	/^      typedef RCPtr<PreResolve> Ptr;$/;"	t	class:openvpn::RemoteList::PreResolve
Ptr	client/remotelist.hpp	/^      typedef RCPtr<ResolvedAddr> Ptr;$/;"	t	struct:openvpn::RemoteList::ResolvedAddr
Ptr	client/remotelist.hpp	/^      typedef RCPtr<ResolvedAddrList> Ptr;$/;"	t	struct:openvpn::RemoteList::ResolvedAddrList
Ptr	client/remotelist.hpp	/^    typedef RCPtr<RemoteList> Ptr;$/;"	t	class:openvpn::RemoteList
Ptr	common/action.hpp	/^    typedef RCPtr<Action> Ptr;$/;"	t	struct:openvpn::Action
Ptr	common/action.hpp	/^    typedef RCPtr<ActionList> Ptr;$/;"	t	class:openvpn::ActionList
Ptr	common/action.hpp	/^    typedef RCPtr<ActionListFactory> Ptr;$/;"	t	struct:openvpn::ActionListFactory
Ptr	common/actionthread.hpp	/^    typedef RCPtr<ActionThread> Ptr;$/;"	t	class:openvpn::ActionThread
Ptr	common/asiopolysock.hpp	/^      typedef RCPtr<Base> Ptr;$/;"	t	class:openvpn::AsioPolySock::Base
Ptr	common/asiopolysock.hpp	/^      typedef RCPtr<NamedPipe> Ptr;$/;"	t	struct:openvpn::AsioPolySock::NamedPipe
Ptr	common/asiopolysock.hpp	/^      typedef RCPtr<TCP> Ptr;$/;"	t	struct:openvpn::AsioPolySock::TCP
Ptr	common/asiopolysock.hpp	/^      typedef RCPtr<Unix> Ptr;$/;"	t	struct:openvpn::AsioPolySock::Unix
Ptr	common/asiosignal.hpp	/^    typedef RCPtr<ASIOSignals> Ptr;$/;"	t	class:openvpn::ASIOSignals
Ptr	common/destruct.hpp	/^    typedef RCPtr<DestructorBase> Ptr;$/;"	t	struct:openvpn::DestructorBase
Ptr	common/options.hpp	/^      typedef RCPtr<FilterBase> Ptr;$/;"	t	struct:openvpn::OptionList::FilterBase
Ptr	common/options.hpp	/^      typedef RCPtr<KeyValue> Ptr;$/;"	t	class:openvpn::OptionList::KeyValue
Ptr	common/options.hpp	/^    typedef RCPtr<OptionList> Ptr;$/;"	t	class:openvpn::OptionList
Ptr	common/process.hpp	/^    typedef RCPtr<Command> Ptr;$/;"	t	struct:openvpn::Command
Ptr	common/rc.hpp	/^      typedef RCPtr<Controller> Ptr;$/;"	t	struct:openvpn::RCWeak::Controller
Ptr	common/rc.hpp	/^    typedef RCPtr<RC> Ptr;$/;"	t	class:openvpn::RC
Ptr	common/rc.hpp	/^    typedef RCPtr<RCWeak> Ptr;$/;"	t
Ptr	common/runcontext.hpp	/^    typedef RCPtr<RunContext> Ptr;$/;"	t	class:openvpn::RunContext
Ptr	common/runcontext.hpp	/^    typedef RCPtr<ServerThreadType> Ptr;$/;"	t	struct:openvpn::ServerThreadType
Ptr	compress/compress.hpp	/^    typedef RCPtr<Compress> Ptr;$/;"	t	class:openvpn::Compress
Ptr	crypto/crypto_aead.hpp	/^      typedef RCPtr<CryptoContext> Ptr;$/;"	t	class:openvpn::AEAD::CryptoContext
Ptr	crypto/crypto_chm.hpp	/^    typedef RCPtr<CryptoContextCHM> Ptr;$/;"	t	class:openvpn::CryptoContextCHM
Ptr	crypto/cryptodc.hpp	/^    typedef RCPtr<CryptoDCContext> Ptr;$/;"	t	class:openvpn::CryptoDCContext
Ptr	crypto/cryptodc.hpp	/^    typedef RCPtr<CryptoDCFactory> Ptr;$/;"	t	class:openvpn::CryptoDCFactory
Ptr	crypto/cryptodc.hpp	/^    typedef RCPtr<CryptoDCInstance> Ptr;$/;"	t	class:openvpn::CryptoDCInstance
Ptr	crypto/cryptodcsel.hpp	/^    typedef RCPtr<CryptoDCSelect> Ptr;$/;"	t	class:openvpn::CryptoDCSelect
Ptr	crypto/digestapi.hpp	/^    typedef RCPtr<DigestContext> Ptr;$/;"	t	class:openvpn::DigestContext
Ptr	crypto/digestapi.hpp	/^    typedef RCPtr<DigestFactory> Ptr;$/;"	t	class:openvpn::DigestFactory
Ptr	crypto/digestapi.hpp	/^    typedef RCPtr<DigestInstance> Ptr;$/;"	t	class:openvpn::DigestInstance
Ptr	crypto/digestapi.hpp	/^    typedef RCPtr<HMACInstance> Ptr;$/;"	t	class:openvpn::HMACInstance
Ptr	crypto/ovpnhmac.hpp	/^    typedef RCPtr<OvpnHMACContext> Ptr;$/;"	t	class:openvpn::OvpnHMACContext
Ptr	crypto/ovpnhmac.hpp	/^    typedef RCPtr<OvpnHMACFactory> Ptr;$/;"	t	class:openvpn::OvpnHMACFactory
Ptr	crypto/ovpnhmac.hpp	/^    typedef RCPtr<OvpnHMACInstance> Ptr;$/;"	t	class:openvpn::OvpnHMACInstance
Ptr	frame/frame.hpp	/^    typedef RCPtr<Frame> Ptr;$/;"	t	class:openvpn::Frame
Ptr	log/logbasesimple.hpp	/^    typedef RCPtr<LogBaseSimple> Ptr;$/;"	t	class:openvpn::LogBaseSimple
Ptr	log/sessionstats.hpp	/^      typedef RCPtr<DCOTransportSource> Ptr;$/;"	t	struct:openvpn::SessionStats::DCOTransportSource
Ptr	log/sessionstats.hpp	/^    typedef RCPtr<SessionStats> Ptr;$/;"	t	class:openvpn::SessionStats
Ptr	netconf/linux/route.hpp	/^    typedef RCPtr<RouteListLinux> Ptr;$/;"	t	class:openvpn::RouteListLinux
Ptr	openssl/ssl/sslctx.hpp	/^      typedef RCPtr<Config> Ptr;$/;"	t	class:openvpn::OpenSSLContext::Config
Ptr	openssl/ssl/sslctx.hpp	/^      typedef RCPtr<SSL> Ptr;$/;"	t	class:openvpn::OpenSSLContext::SSL
Ptr	openssl/ssl/sslctx.hpp	/^    typedef RCPtr<OpenSSLContext> Ptr;$/;"	t	class:openvpn::OpenSSLContext
Ptr	openssl/util/rand.hpp	/^    typedef RCPtr<OpenSSLRandom> Ptr;$/;"	t	class:openvpn::OpenSSLRandom
Ptr	options/continuation.hpp	/^    typedef RCPtr<PushOptionsBase> Ptr;$/;"	t	struct:openvpn::PushOptionsBase
Ptr	polarssl/pki/dh.hpp	/^      typedef RCPtr<DH> Ptr;$/;"	t	class:openvpn::PolarSSLPKI::DH
Ptr	polarssl/pki/pkctx.hpp	/^      typedef RCPtr<PKContext> Ptr;$/;"	t	class:openvpn::PolarSSLPKI::PKContext
Ptr	polarssl/pki/x509cert.hpp	/^      typedef RCPtr<X509Cert> Ptr;$/;"	t	class:openvpn::PolarSSLPKI::X509Cert
Ptr	polarssl/pki/x509crl.hpp	/^      typedef RCPtr<X509CRL> Ptr;$/;"	t	class:openvpn::PolarSSLPKI::X509CRL
Ptr	polarssl/ssl/sslctx.hpp	/^      typedef RCPtr<Config> Ptr;$/;"	t	class:openvpn::PolarSSLContext::Config
Ptr	polarssl/ssl/sslctx.hpp	/^      typedef RCPtr<SSL> Ptr;$/;"	t	class:openvpn::PolarSSLContext::SSL
Ptr	polarssl/ssl/sslctx.hpp	/^    typedef RCPtr<PolarSSLContext> Ptr;$/;"	t	class:openvpn::PolarSSLContext
Ptr	polarssl/util/rand.hpp	/^    typedef RCPtr<PolarSSLRandom> Ptr;$/;"	t	class:openvpn::PolarSSLRandom
Ptr	proxy/proxyauth.hpp	/^      typedef RCPtr<ProxyAuthenticate> Ptr;$/;"	t	class:openvpn::HTTPProxy::ProxyAuthenticate
Ptr	random/devurand.hpp	/^    typedef RCPtr<DevURand> Ptr;$/;"	t	class:openvpn::DevURand
Ptr	random/mtrandapi.hpp	/^    typedef RCPtr<MTRand> Ptr;$/;"	t	class:openvpn::MTRand
Ptr	random/randapi.hpp	/^    typedef RCPtr<RandomAPI> Ptr;$/;"	t	class:openvpn::RandomAPI
Ptr	server/manage.hpp	/^    typedef RCPtr<ManClientInstanceFactory> Ptr;$/;"	t	struct:openvpn::ManClientInstanceFactory
Ptr	server/manage.hpp	/^    typedef RCPtr<ManClientInstanceRecv> Ptr;$/;"	t	struct:openvpn::ManClientInstanceRecv
Ptr	server/manage.hpp	/^    typedef RCPtr<ManClientInstanceSend> Ptr;$/;"	t	struct:openvpn::ManClientInstanceSend
Ptr	server/peeraddr.hpp	/^    typedef RCPtr<PeerAddr> Ptr;$/;"	t	struct:openvpn::PeerAddr
Ptr	server/servproto.hpp	/^      typedef RCPtr<Factory> Ptr;$/;"	t	class:openvpn::ServerProto::Factory
Ptr	server/servproto.hpp	/^      typedef RCPtr<Session> Ptr;$/;"	t	class:openvpn::ServerProto::Session
Ptr	server/vpnservpool.hpp	/^      typedef RCPtr<IP46AutoRelease> Ptr;$/;"	t	class:openvpn::VPNServerPool::IP46AutoRelease
Ptr	ssl/peerinfo.hpp	/^      typedef RCPtr<Set> Ptr;$/;"	t	struct:openvpn::PeerInfo::Set
Ptr	ssl/proto.hpp	/^      typedef RCPtr<Config> Ptr;$/;"	t	class:openvpn::ProtoContext::Config
Ptr	ssl/proto.hpp	/^      typedef RCPtr<KeyContext> Ptr;$/;"	t	class:openvpn::ProtoContext::KeyContext
Ptr	ssl/proto.hpp	/^      typedef RCPtr<TLSAuthPreValidate> Ptr;$/;"	t	class:openvpn::ProtoContext::TLSAuthPreValidate
Ptr	ssl/proto_context_options.hpp	/^    typedef RCPtr<ProtoContextOptions> Ptr;$/;"	t	struct:openvpn::ProtoContextOptions
Ptr	ssl/sslapi.hpp	/^    typedef RCPtr<SSLAPI> Ptr;$/;"	t	class:openvpn::SSLAPI
Ptr	ssl/sslapi.hpp	/^    typedef RCPtr<SSLConfigAPI> Ptr;$/;"	t	class:openvpn::SSLConfigAPI
Ptr	ssl/sslapi.hpp	/^    typedef RCPtr<SSLFactoryAPI> Ptr;$/;"	t	class:openvpn::SSLFactoryAPI
Ptr	ssl/tlsprf.hpp	/^    typedef RCPtr<TLSPRFFactory> Ptr;$/;"	t	class:openvpn::TLSPRFFactory
Ptr	ssl/tlsprf.hpp	/^    typedef RCPtr<TLSPRFInstance> Ptr;$/;"	t	class:openvpn::TLSPRFInstance
Ptr	transport/altproxy.hpp	/^    typedef RCPtr<AltProxy> Ptr;$/;"	t	struct:openvpn::AltProxy
Ptr	transport/client/httpcli.hpp	/^	typedef RCPtr<CustomHeader> Ptr;$/;"	t	struct:openvpn::HTTPProxyTransport::Options::CustomHeader
Ptr	transport/client/httpcli.hpp	/^      typedef RCPtr<Client> Ptr;$/;"	t	class:openvpn::HTTPProxyTransport::Client
Ptr	transport/client/httpcli.hpp	/^      typedef RCPtr<ClientConfig> Ptr;$/;"	t	class:openvpn::HTTPProxyTransport::ClientConfig
Ptr	transport/client/httpcli.hpp	/^      typedef RCPtr<Options> Ptr;$/;"	t	class:openvpn::HTTPProxyTransport::Options
Ptr	transport/client/tcpcli.hpp	/^      typedef RCPtr<Client> Ptr;$/;"	t	class:openvpn::TCPTransport::Client
Ptr	transport/client/tcpcli.hpp	/^      typedef RCPtr<ClientConfig> Ptr;$/;"	t	class:openvpn::TCPTransport::ClientConfig
Ptr	transport/client/transbase.hpp	/^    typedef RCPtr<TransportClient> Ptr;$/;"	t	struct:openvpn::TransportClient
Ptr	transport/client/transbase.hpp	/^    typedef RCPtr<TransportClientFactory> Ptr;$/;"	t	struct:openvpn::TransportClientFactory
Ptr	transport/client/udpcli.hpp	/^      typedef RCPtr<Client> Ptr;$/;"	t	class:openvpn::UDPTransport::Client
Ptr	transport/client/udpcli.hpp	/^      typedef RCPtr<ClientConfig> Ptr;$/;"	t	class:openvpn::UDPTransport::ClientConfig
Ptr	transport/dco.hpp	/^    typedef RCPtr<DCO> Ptr;$/;"	t	struct:openvpn::DCO
Ptr	transport/gremlin.hpp	/^      typedef RCPtr<Config> Ptr;$/;"	t	class:openvpn::Gremlin::Config
Ptr	transport/gremlin.hpp	/^      typedef RCPtr<DelayedQueue> Ptr;$/;"	t	struct:openvpn::Gremlin::DelayedQueue
Ptr	transport/mutate.hpp	/^    typedef RCPtr<TransportMutateStream> Ptr;$/;"	t	class:openvpn::TransportMutateStream
Ptr	transport/server/transbase.hpp	/^    typedef RCPtr<TransportClientInstanceFactory> Ptr;$/;"	t	struct:openvpn::TransportClientInstanceFactory
Ptr	transport/server/transbase.hpp	/^    typedef RCPtr<TransportClientInstanceRecv> Ptr;$/;"	t	struct:openvpn::TransportClientInstanceRecv
Ptr	transport/server/transbase.hpp	/^    typedef RCPtr<TransportClientInstanceSend> Ptr;$/;"	t	struct:openvpn::TransportClientInstanceSend
Ptr	transport/server/transbase.hpp	/^    typedef RCPtr<TransportServer> Ptr;$/;"	t	struct:openvpn::TransportServer
Ptr	transport/server/transbase.hpp	/^    typedef RCPtr<TransportServerFactory> Ptr;$/;"	t	struct:openvpn::TransportServerFactory
Ptr	transport/tcplink.hpp	/^      typedef RCPtr<Link> Ptr;$/;"	t	class:openvpn::TCPTransport::Link
Ptr	transport/udplink.hpp	/^      typedef RCPtr<Link> Ptr;$/;"	t	class:openvpn::UDPTransport::Link
Ptr	tun/builder/capture.hpp	/^    typedef RCPtr<TunBuilderCapture> Ptr;$/;"	t	class:openvpn::TunBuilderCapture
Ptr	tun/builder/client.hpp	/^      typedef RCPtr<ClientConfig> Ptr;$/;"	t	class:openvpn::TunBuilderClient::ClientConfig
Ptr	tun/builder/client.hpp	/^      typedef RCPtr<Tun> Ptr;$/;"	t	class:openvpn::TunBuilderClient::Tun
Ptr	tun/builder/setup.hpp	/^      typedef RCPtr<Base> Ptr;$/;"	t	struct:openvpn::TunBuilderSetup::Base
Ptr	tun/builder/setup.hpp	/^      typedef RCPtr<Factory> Ptr;$/;"	t	struct:openvpn::TunBuilderSetup::Factory
Ptr	tun/client/emuexr.hpp	/^    typedef RCPtr<EmulateExcludeRoute> Ptr;$/;"	t	struct:openvpn::EmulateExcludeRoute
Ptr	tun/client/emuexr.hpp	/^    typedef RCPtr<EmulateExcludeRouteFactory> Ptr;$/;"	t	struct:openvpn::EmulateExcludeRouteFactory
Ptr	tun/client/tunbase.hpp	/^    typedef RCPtr<TunClient> Ptr;$/;"	t	struct:openvpn::TunClient
Ptr	tun/client/tunbase.hpp	/^    typedef RCPtr<TunClientFactory> Ptr;$/;"	t	struct:openvpn::TunClientFactory
Ptr	tun/client/tunnull.hpp	/^      typedef RCPtr<ClientConfig> Ptr;$/;"	t	class:openvpn::TunNull::ClientConfig
Ptr	tun/client/tunprop.hpp	/^      typedef RCPtr<State> Ptr;$/;"	t	struct:openvpn::TunProp::State
Ptr	tun/linux/client/tuncli.hpp	/^      typedef RCPtr<ClientConfig> Ptr;$/;"	t	class:openvpn::TunLinux::ClientConfig
Ptr	tun/linux/tun.hpp	/^      typedef RCPtr<Tun> Ptr;$/;"	t	class:openvpn::TunLinux::Tun
Ptr	tun/mac/client/tuncli.hpp	/^      typedef RCPtr<ClientConfig> Ptr;$/;"	t	class:openvpn::TunMac::ClientConfig
Ptr	tun/mac/client/tuncli.hpp	/^      typedef RCPtr<Tun> Ptr;$/;"	t	class:openvpn::TunMac::Tun
Ptr	tun/mac/client/tunsetup.hpp	/^      typedef RCPtr<Setup> Ptr;$/;"	t	class:openvpn::TunMac::Setup
Ptr	tun/mac/macdns.hpp	/^      typedef RCPtr<Config> Ptr;$/;"	t	class:openvpn::MacDNS::Config
Ptr	tun/mac/macdns.hpp	/^      typedef RCPtr<Info> Ptr;$/;"	t	class:openvpn::MacDNS::Info
Ptr	tun/mac/macdns.hpp	/^    typedef RCPtr<MacDNS> Ptr;$/;"	t	class:openvpn::MacDNS
Ptr	tun/mac/macdns_watchdog.hpp	/^      typedef RCPtr<DNSAction> Ptr;$/;"	t	class:openvpn::MacDNSWatchdog::DNSAction
Ptr	tun/mac/macdns_watchdog.hpp	/^    typedef RCPtr<MacDNSWatchdog> Ptr;$/;"	t	class:openvpn::MacDNSWatchdog
Ptr	tun/persist/tunpersist.hpp	/^    typedef RCPtr<TunPersistTemplate> Ptr;$/;"	t	class:openvpn::TunPersistTemplate
Ptr	tun/persist/tunwrap.hpp	/^    typedef RCPtr<TunWrapTemplate> Ptr;$/;"	t	class:openvpn::TunWrapTemplate
Ptr	tun/server/tunbase.hpp	/^    typedef RCPtr<TunClientInstanceFactory> Ptr;$/;"	t	struct:openvpn::TunClientInstanceFactory
Ptr	tun/server/tunbase.hpp	/^    typedef RCPtr<TunClientInstanceRecv> Ptr;$/;"	t	struct:openvpn::TunClientInstanceRecv
Ptr	tun/server/tunbase.hpp	/^    typedef RCPtr<TunClientInstanceSend> Ptr;$/;"	t	struct:openvpn::TunClientInstanceSend
Ptr	tun/tunio.hpp	/^    typedef RCPtr<TunIO> Ptr;$/;"	t	class:openvpn::TunIO
Ptr	tun/win/client/setupbase.hpp	/^      typedef RCPtr<SetupBase> Ptr;$/;"	t	struct:openvpn::TunWin::SetupBase
Ptr	tun/win/client/setupbase.hpp	/^      typedef RCPtr<SetupFactory> Ptr;$/;"	t	struct:openvpn::TunWin::SetupFactory
Ptr	tun/win/client/tuncli.hpp	/^      typedef RCPtr<Client> Ptr;$/;"	t	class:openvpn::TunWin::Client
Ptr	tun/win/client/tuncli.hpp	/^      typedef RCPtr<ClientConfig> Ptr;$/;"	t	class:openvpn::TunWin::ClientConfig
Ptr	tun/win/client/tuncli.hpp	/^      typedef RCPtr<Tun> Ptr;$/;"	t	class:openvpn::TunWin::Tun
Ptr	tun/win/client/tunsetup.hpp	/^      typedef RCPtr<Setup> Ptr;$/;"	t	class:openvpn::TunWin::Setup
Ptr	tun/win/wfp.hpp	/^      typedef RCPtr<WFP> Ptr;$/;"	t	class:openvpn::TunWin::WFP
Ptr	tun/win/wfp.hpp	/^      typedef RCPtr<WFPContext> Ptr;$/;"	t	class:openvpn::TunWin::WFPContext
Ptr	win/cmd.hpp	/^    typedef RCPtr<WinCmd> Ptr;$/;"	t	class:openvpn::WinCmd
Ptr	win/sleep.hpp	/^    typedef RCPtr<WinSleep> Ptr;$/;"	t	class:openvpn::WinSleep
PushOptionsBase	options/continuation.hpp	/^  struct PushOptionsBase : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
PushedOptionsFilter	client/optfilt.hpp	/^    PushedOptionsFilter(const bool route_nopull)$/;"	f	class:openvpn::PushedOptionsFilter
PushedOptionsFilter	client/optfilt.hpp	/^  class PushedOptionsFilter : public OptionList::FilterBase$/;"	c	namespace:openvpn
Queue	client/clievent.hpp	/^    class Queue : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::ClientEvent
Queue	transport/tcplink.hpp	/^      typedef std::deque<BufferPtr> Queue;$/;"	t	class:openvpn::TCPTransport::Link
RAW	server/servhalt.hpp	/^      RAW,              \/\/ pass raw message to client$/;"	e	enum:openvpn::HaltRestart::Type
RC	common/rc.hpp	/^  class RC$/;"	c	namespace:openvpn
RCCopyable	common/rc.hpp	/^  class RCCopyable$/;"	c	namespace:openvpn
RCPtr	common/rc.hpp	/^  class RCPtr$/;"	c	namespace:openvpn
RCWeak	common/rc.hpp	/^  class RCWeak$/;"	c	namespace:openvpn
RCWeakPtr	common/rc.hpp	/^  class RCWeakPtr$/;"	c	namespace:openvpn
READY	applecrypto/crypto/hmac.hpp	/^	READY$/;"	e	enum:openvpn::AppleCrypto::HMACContext::State
READ_BIO_MEMQ_DGRAM	frame/frame.hpp	/^      READ_BIO_MEMQ_DGRAM,$/;"	e	enum:openvpn::Frame::__anon44
READ_BIO_MEMQ_STREAM	frame/frame.hpp	/^      READ_BIO_MEMQ_STREAM,$/;"	e	enum:openvpn::Frame::__anon44
READ_HTTP	frame/frame.hpp	/^      READ_HTTP,$/;"	e	enum:openvpn::Frame::__anon44
READ_LINK_TCP	frame/frame.hpp	/^      READ_LINK_TCP,$/;"	e	enum:openvpn::Frame::__anon44
READ_LINK_UDP	frame/frame.hpp	/^      READ_LINK_UDP,$/;"	e	enum:openvpn::Frame::__anon44
READ_SSL_CLEARTEXT	frame/frame.hpp	/^      READ_SSL_CLEARTEXT,$/;"	e	enum:openvpn::Frame::__anon44
READ_TUN	frame/frame.hpp	/^      READ_TUN,$/;"	e	enum:openvpn::Frame::__anon44
RECONNECTING	client/clievent.hpp	/^      RECONNECTING,$/;"	e	enum:openvpn::ClientEvent::Type
RENDER_BRACKET	common/options.hpp	/^      RENDER_BRACKET  = (1<<3),  \/\/ quote options using []$/;"	e	enum:openvpn::Option::render_flags
RENDER_NUMBER	common/options.hpp	/^      RENDER_NUMBER   = (1<<2),  \/\/ number lines$/;"	e	enum:openvpn::Option::render_flags
RENDER_PASS_FMT	common/options.hpp	/^      RENDER_PASS_FMT = (1<<1),  \/\/ pass \\r\\n\\t$/;"	e	enum:openvpn::Option::render_flags
RENDER_TRUNC_64	common/options.hpp	/^      RENDER_TRUNC_64 = (1<<0),  \/\/ truncate option after 64 chars$/;"	e	enum:openvpn::Option::render_flags
RENDER_UNUSED	common/options.hpp	/^      RENDER_UNUSED   = (1<<4),  \/\/ only show unused options$/;"	e	enum:openvpn::Option::render_flags
REPLAY_ERROR	error/error.hpp	/^      REPLAY_ERROR,        \/\/ error from PacketIDReceive$/;"	e	enum:openvpn::Error::Type
REPLAY_INDEX	crypto/packet_id.hpp	/^    unsigned int REPLAY_INDEX(const int i) const$/;"	f	class:openvpn::PacketIDReceiveType
REPLAY_WINDOW_BYTES	crypto/packet_id.hpp	/^    static constexpr unsigned int REPLAY_WINDOW_BYTES = 1 << REPLAY_WINDOW_ORDER;$/;"	m	class:openvpn::PacketIDReceiveType
REPLAY_WINDOW_SIZE	crypto/packet_id.hpp	/^    static constexpr unsigned int REPLAY_WINDOW_SIZE = REPLAY_WINDOW_BYTES * 8;$/;"	m	class:openvpn::PacketIDReceiveType
REROUTE_GW_NO_DNS	error/error.hpp	/^      REROUTE_GW_NO_DNS,   \/\/ redirect-gateway specified without alt DNS servers$/;"	e	enum:openvpn::Error::Type
RESOLVE	client/clievent.hpp	/^      RESOLVE,$/;"	e	enum:openvpn::ClientEvent::Type
RESOLVE_ERROR	error/error.hpp	/^      RESOLVE_ERROR,       \/\/ DNS resolution error$/;"	e	enum:openvpn::Error::Type
RESTART	server/servhalt.hpp	/^      RESTART,          \/\/ restart, don't preserve session token$/;"	e	enum:openvpn::HaltRestart::Type
RESTART_PASSIVE	server/servhalt.hpp	/^      RESTART_PASSIVE,  \/\/ restart, preserve session token and local client instance object$/;"	e	enum:openvpn::HaltRestart::Type
RESTART_PSID	server/servhalt.hpp	/^      RESTART_PSID,     \/\/ restart, preserve session token$/;"	e	enum:openvpn::HaltRestart::Type
RESUME	client/clievent.hpp	/^      RESUME,$/;"	e	enum:openvpn::ClientEvent::Type
RGWFlags	tun/builder/rgwflags.hpp	/^  namespace RGWFlags {$/;"	n	namespace:openvpn
RG_AUTO_LOCAL	client/rgopt.hpp	/^      RG_AUTO_LOCAL  = (1<<3),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_BLOCK_LOCAL	client/rgopt.hpp	/^      RG_BLOCK_LOCAL = (1<<7),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_BYPASS_DHCP	client/rgopt.hpp	/^      RG_BYPASS_DHCP = (1<<5),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_BYPASS_DNS	client/rgopt.hpp	/^      RG_BYPASS_DNS  = (1<<6),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_DEF1	client/rgopt.hpp	/^      RG_DEF1        = (1<<4),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_DEFAULT	client/rgopt.hpp	/^      RG_DEFAULT     = (RG_IPv4),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_ENABLE	client/rgopt.hpp	/^      RG_ENABLE      = (1<<0),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_IPv4	client/rgopt.hpp	/^      RG_IPv4        = (1<<8),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_IPv6	client/rgopt.hpp	/^      RG_IPv6        = (1<<9),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_LOCAL	client/rgopt.hpp	/^      RG_LOCAL       = (1<<2),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RG_REROUTE_GW	client/rgopt.hpp	/^      RG_REROUTE_GW  = (1<<1),$/;"	e	enum:openvpn::RedirectGatewayFlags::Flags
RTAX_AUTHOR	netconf/ios/net-route.h	/^#define	RTAX_AUTHOR	/;"	d
RTAX_BRD	netconf/ios/net-route.h	/^#define	RTAX_BRD	/;"	d
RTAX_DST	netconf/ios/net-route.h	/^#define	RTAX_DST	/;"	d
RTAX_GATEWAY	netconf/ios/net-route.h	/^#define	RTAX_GATEWAY	/;"	d
RTAX_GENMASK	netconf/ios/net-route.h	/^#define	RTAX_GENMASK	/;"	d
RTAX_IFA	netconf/ios/net-route.h	/^#define	RTAX_IFA	/;"	d
RTAX_IFP	netconf/ios/net-route.h	/^#define	RTAX_IFP	/;"	d
RTAX_MAX	netconf/ios/net-route.h	/^#define	RTAX_MAX	/;"	d
RTAX_NETMASK	netconf/ios/net-route.h	/^#define	RTAX_NETMASK	/;"	d
RTA_AUTHOR	netconf/ios/net-route.h	/^#define	RTA_AUTHOR	/;"	d
RTA_BRD	netconf/ios/net-route.h	/^#define	RTA_BRD	/;"	d
RTA_DST	netconf/ios/net-route.h	/^#define	RTA_DST	/;"	d
RTA_GATEWAY	netconf/ios/net-route.h	/^#define	RTA_GATEWAY	/;"	d
RTA_GENMASK	netconf/ios/net-route.h	/^#define	RTA_GENMASK	/;"	d
RTA_IFA	netconf/ios/net-route.h	/^#define	RTA_IFA	/;"	d
RTA_IFP	netconf/ios/net-route.h	/^#define	RTA_IFP	/;"	d
RTA_NETMASK	netconf/ios/net-route.h	/^#define	RTA_NETMASK	/;"	d
RTF_BITS	netconf/ios/net-route.h	/^#define	RTF_BITS /;"	d
RTF_BLACKHOLE	netconf/ios/net-route.h	/^#define	RTF_BLACKHOLE	/;"	d
RTF_BROADCAST	netconf/ios/net-route.h	/^#define	RTF_BROADCAST	/;"	d
RTF_CLONING	netconf/ios/net-route.h	/^#define	RTF_CLONING	/;"	d
RTF_CONDEMNED	netconf/ios/net-route.h	/^#define	RTF_CONDEMNED	/;"	d
RTF_DELCLONE	netconf/ios/net-route.h	/^#define	RTF_DELCLONE	/;"	d
RTF_DONE	netconf/ios/net-route.h	/^#define	RTF_DONE	/;"	d
RTF_DYNAMIC	netconf/ios/net-route.h	/^#define	RTF_DYNAMIC	/;"	d
RTF_GATEWAY	netconf/ios/net-route.h	/^#define	RTF_GATEWAY	/;"	d
RTF_HOST	netconf/ios/net-route.h	/^#define	RTF_HOST	/;"	d
RTF_IFREF	netconf/ios/net-route.h	/^#define	RTF_IFREF	/;"	d
RTF_IFSCOPE	netconf/ios/net-route.h	/^#define	RTF_IFSCOPE	/;"	d
RTF_LLINFO	netconf/ios/net-route.h	/^#define	RTF_LLINFO	/;"	d
RTF_LOCAL	netconf/ios/net-route.h	/^#define	RTF_LOCAL	/;"	d
RTF_MODIFIED	netconf/ios/net-route.h	/^#define	RTF_MODIFIED	/;"	d
RTF_MULTICAST	netconf/ios/net-route.h	/^#define	RTF_MULTICAST	/;"	d
RTF_NOIFREF	netconf/ios/net-route.h	/^#define	RTF_NOIFREF	/;"	d
RTF_PINNED	netconf/ios/net-route.h	/^#define	RTF_PINNED	/;"	d
RTF_PRCLONING	netconf/ios/net-route.h	/^#define	RTF_PRCLONING	/;"	d
RTF_PROTO1	netconf/ios/net-route.h	/^#define	RTF_PROTO1	/;"	d
RTF_PROTO2	netconf/ios/net-route.h	/^#define	RTF_PROTO2	/;"	d
RTF_PROTO3	netconf/ios/net-route.h	/^#define	RTF_PROTO3	/;"	d
RTF_PROXY	netconf/ios/net-route.h	/^#define	RTF_PROXY	/;"	d
RTF_REJECT	netconf/ios/net-route.h	/^#define	RTF_REJECT	/;"	d
RTF_ROUTER	netconf/ios/net-route.h	/^#define	RTF_ROUTER	/;"	d
RTF_STATIC	netconf/ios/net-route.h	/^#define	RTF_STATIC	/;"	d
RTF_UP	netconf/ios/net-route.h	/^#define	RTF_UP	/;"	d
RTF_WASCLONED	netconf/ios/net-route.h	/^#define	RTF_WASCLONED	/;"	d
RTF_XRESOLVE	netconf/ios/net-route.h	/^#define	RTF_XRESOLVE	/;"	d
RTM_ADD	netconf/ios/net-route.h	/^#define	RTM_ADD	/;"	d
RTM_CHANGE	netconf/ios/net-route.h	/^#define	RTM_CHANGE	/;"	d
RTM_DELADDR	netconf/ios/net-route.h	/^#define	RTM_DELADDR	/;"	d
RTM_DELETE	netconf/ios/net-route.h	/^#define	RTM_DELETE	/;"	d
RTM_DELMADDR	netconf/ios/net-route.h	/^#define	RTM_DELMADDR	/;"	d
RTM_GET	netconf/ios/net-route.h	/^#define	RTM_GET	/;"	d
RTM_GET2	netconf/ios/net-route.h	/^#define	RTM_GET2	/;"	d
RTM_IFINFO	netconf/ios/net-route.h	/^#define	RTM_IFINFO	/;"	d
RTM_IFINFO2	netconf/ios/net-route.h	/^#define	RTM_IFINFO2	/;"	d
RTM_LOCK	netconf/ios/net-route.h	/^#define	RTM_LOCK	/;"	d
RTM_LOSING	netconf/ios/net-route.h	/^#define	RTM_LOSING	/;"	d
RTM_MISS	netconf/ios/net-route.h	/^#define	RTM_MISS	/;"	d
RTM_NEWADDR	netconf/ios/net-route.h	/^#define	RTM_NEWADDR	/;"	d
RTM_NEWMADDR	netconf/ios/net-route.h	/^#define	RTM_NEWMADDR	/;"	d
RTM_NEWMADDR2	netconf/ios/net-route.h	/^#define	RTM_NEWMADDR2	/;"	d
RTM_OLDADD	netconf/ios/net-route.h	/^#define	RTM_OLDADD	/;"	d
RTM_OLDDEL	netconf/ios/net-route.h	/^#define	RTM_OLDDEL	/;"	d
RTM_REDIRECT	netconf/ios/net-route.h	/^#define	RTM_REDIRECT	/;"	d
RTM_RESOLVE	netconf/ios/net-route.h	/^#define	RTM_RESOLVE	/;"	d
RTM_RTTUNIT	netconf/ios/net-route.h	/^#define	RTM_RTTUNIT	/;"	d
RTM_VERSION	netconf/ios/net-route.h	/^#define	RTM_VERSION	/;"	d
RTV_EXPIRE	netconf/ios/net-route.h	/^#define	RTV_EXPIRE	/;"	d
RTV_HOPCOUNT	netconf/ios/net-route.h	/^#define	RTV_HOPCOUNT	/;"	d
RTV_MTU	netconf/ios/net-route.h	/^#define	RTV_MTU	/;"	d
RTV_RPIPE	netconf/ios/net-route.h	/^#define	RTV_RPIPE	/;"	d
RTV_RTT	netconf/ios/net-route.h	/^#define	RTV_RTT	/;"	d
RTV_RTTVAR	netconf/ios/net-route.h	/^#define	RTV_RTTVAR	/;"	d
RTV_SPIPE	netconf/ios/net-route.h	/^#define	RTV_SPIPE	/;"	d
RTV_SSTHRESH	netconf/ios/net-route.h	/^#define	RTV_SSTHRESH	/;"	d
R_ADD_ALL	tun/linux/client/tuncli.hpp	/^      R_ADD_ALL=R_ADD_SYS|R_ADD_DCO,$/;"	e	enum:openvpn::TunLinux::__anon90
R_ADD_DCO	tun/linux/client/tuncli.hpp	/^      R_ADD_DCO=(1<<2),$/;"	e	enum:openvpn::TunLinux::__anon90
R_ADD_SYS	tun/linux/client/tuncli.hpp	/^      R_ADD_SYS=(1<<1),$/;"	e	enum:openvpn::TunLinux::__anon90
R_BLACKHOLE	tun/mac/client/tunsetup.hpp	/^	R_BLACKHOLE=(1<<5),$/;"	e	enum:openvpn::TunMac::Setup::__anon91
R_IFACE	tun/mac/client/tunsetup.hpp	/^	R_IFACE=(1<<1),$/;"	e	enum:openvpn::TunMac::Setup::__anon91
R_IFACE_HINT	tun/mac/client/tunsetup.hpp	/^	R_IFACE_HINT=(1<<2),$/;"	e	enum:openvpn::TunMac::Setup::__anon91
R_IPv6	tun/linux/client/tuncli.hpp	/^      R_IPv6=(1<<0),$/;"	e	enum:openvpn::TunLinux::__anon90
R_IPv6	tun/mac/client/tunsetup.hpp	/^	R_IPv6=(1<<0),$/;"	e	enum:openvpn::TunMac::Setup::__anon91
R_ONLINK	tun/mac/client/tunsetup.hpp	/^	R_ONLINK=(1<<3),$/;"	e	enum:openvpn::TunMac::Setup::__anon91
R_REJECT	tun/mac/client/tunsetup.hpp	/^	R_REJECT=(1<<4),$/;"	e	enum:openvpn::TunMac::Setup::__anon91
RandomAPI	random/randapi.hpp	/^  class RandomAPI : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
RandomAPI	ssl/sslchoose.hpp	/^    typedef PolarSSLRandom RandomAPI;$/;"	t	namespace:openvpn::SSLLib
RandomByteStore	random/randbytestore.hpp	/^  class RandomByteStore$/;"	c	namespace:openvpn
Range	addr/range.hpp	/^    typedef RangeType<IP::Addr> Range;$/;"	t	namespace:openvpn::IP
RangePartition	addr/range.hpp	/^    typedef RangePartitionType<IP::Addr> RangePartition;$/;"	t	namespace:openvpn::IP
RangePartitionType	addr/range.hpp	/^      RangePartitionType(const RangeType<ADDR>& src_range, const size_t n_partitions)$/;"	f	class:openvpn::IP::RangePartitionType
RangePartitionType	addr/range.hpp	/^    class RangePartitionType$/;"	c	namespace:openvpn::IP
RangeType	addr/range.hpp	/^      RangeType() : extent_(0) {}$/;"	f	class:openvpn::IP::RangeType
RangeType	addr/range.hpp	/^      RangeType(const ADDR& start, const size_t extent)$/;"	f	class:openvpn::IP::RangeType
RangeType	addr/range.hpp	/^    class RangeType$/;"	c	namespace:openvpn::IP
Reachability	applecrypto/util/reachable.hpp	/^    Reachability(const bool enable_internet, const bool enable_wifi)$/;"	f	class:openvpn::Reachability
Reachability	applecrypto/util/reachable.hpp	/^  class Reachability : public ReachabilityInterface$/;"	c	namespace:openvpn
ReachabilityBase	applecrypto/util/reachable.hpp	/^  class ReachabilityBase$/;"	c	namespace:openvpn
ReachabilityInterface	applecrypto/util/reach.hpp	/^  struct ReachabilityInterface$/;"	s	namespace:openvpn
ReachabilityTracker	applecrypto/util/reachable.hpp	/^    ReachabilityTracker(const bool enable_internet, const bool enable_wifi)$/;"	f	class:openvpn::ReachabilityTracker
ReachabilityTracker	applecrypto/util/reachable.hpp	/^  class ReachabilityTracker$/;"	c	namespace:openvpn
ReachabilityViaInternet	applecrypto/util/reachable.hpp	/^    ReachabilityViaInternet()$/;"	f	class:openvpn::ReachabilityViaInternet
ReachabilityViaInternet	applecrypto/util/reachable.hpp	/^  class ReachabilityViaInternet : public ReachabilityBase$/;"	c	namespace:openvpn
ReachabilityViaWiFi	applecrypto/util/reachable.hpp	/^    ReachabilityViaWiFi()$/;"	f	class:openvpn::ReachabilityViaWiFi
ReachabilityViaWiFi	applecrypto/util/reachable.hpp	/^  class ReachabilityViaWiFi : public ReachabilityBase$/;"	c	namespace:openvpn
ReachableViaWWAN	applecrypto/util/reach.hpp	/^      ReachableViaWWAN$/;"	e	enum:openvpn::ReachabilityInterface::Status
ReachableViaWiFi	applecrypto/util/reach.hpp	/^      ReachableViaWiFi,$/;"	e	enum:openvpn::ReachabilityInterface::Status
ReasonBase	client/clievent.hpp	/^      ReasonBase(const Type id, const std::string& reason_arg)$/;"	f	struct:openvpn::ClientEvent::ReasonBase
ReasonBase	client/clievent.hpp	/^      ReasonBase(const Type id, std::string&& reason_arg)$/;"	f	struct:openvpn::ClientEvent::ReasonBase
ReasonBase	client/clievent.hpp	/^    struct ReasonBase : public Base {$/;"	s	namespace:openvpn::ClientEvent
ReconnectNotify	transport/reconnect_notify.hpp	/^  class ReconnectNotify {$/;"	c	namespace:openvpn
Reconnecting	client/clievent.hpp	/^      Reconnecting() : Base(RECONNECTING) {}$/;"	f	struct:openvpn::ClientEvent::Reconnecting
Reconnecting	client/clievent.hpp	/^    struct Reconnecting : public Base$/;"	s	namespace:openvpn::ClientEvent
Red	ssl/datalimit.hpp	/^      Red=2,$/;"	e	enum:openvpn::DataLimit::State
RedirectBase	common/redir.hpp	/^  struct RedirectBase$/;"	s	namespace:openvpn
RedirectGatewayFlags	client/rgopt.hpp	/^    RedirectGatewayFlags() : flags_(RG_DEFAULT) {}$/;"	f	class:openvpn::RedirectGatewayFlags
RedirectGatewayFlags	client/rgopt.hpp	/^    RedirectGatewayFlags(unsigned int flags) : flags_(flags) {}$/;"	f	class:openvpn::RedirectGatewayFlags
RedirectGatewayFlags	client/rgopt.hpp	/^    explicit RedirectGatewayFlags(const OptionList& opt)$/;"	f	class:openvpn::RedirectGatewayFlags
RedirectGatewayFlags	client/rgopt.hpp	/^  class RedirectGatewayFlags {$/;"	c	namespace:openvpn
RedirectPipe	common/redir.hpp	/^    RedirectPipe() {}$/;"	f	class:openvpn::RedirectPipe
RedirectPipe	common/redir.hpp	/^    RedirectPipe(RedirectStdFD& remote,$/;"	f	class:openvpn::RedirectPipe
RedirectPipe	common/redir.hpp	/^  class RedirectPipe : public RedirectStdFD$/;"	c	namespace:openvpn
RedirectStd	common/redir.hpp	/^    RedirectStd() {}$/;"	f	class:openvpn::RedirectStd
RedirectStd	common/redir.hpp	/^    RedirectStd(const std::string& in_fn,$/;"	f	class:openvpn::RedirectStd
RedirectStd	common/redir.hpp	/^  class RedirectStd : public RedirectStdFD$/;"	c	namespace:openvpn
RedirectStdFD	common/redir.hpp	/^  struct RedirectStdFD : public RedirectBase$/;"	s	namespace:openvpn
RedirectTemp	common/redir.hpp	/^    RedirectTemp(const std::string& stdin_fn,$/;"	f	class:openvpn::RedirectTemp
RedirectTemp	common/redir.hpp	/^  class RedirectTemp : public RedirectStd$/;"	c	namespace:openvpn
RegKey	win/reg.hpp	/^      RegKey() : key(nullptr) {}$/;"	f	class:openvpn::Win::RegKey
RegKey	win/reg.hpp	/^    class RegKey$/;"	c	namespace:openvpn::Win
RekeyType	crypto/cryptodc.hpp	/^    enum RekeyType {$/;"	g	class:openvpn::CryptoDCInstance
ReliableAck	reliable/relack.hpp	/^    ReliableAck(const size_t max_ack_list)$/;"	f	class:openvpn::ReliableAck
ReliableAck	reliable/relack.hpp	/^  class ReliableAck$/;"	c	namespace:openvpn
ReliableMessageBase	reliable/relcommon.hpp	/^    ReliableMessageBase() : id_(0), erased_(false) {}$/;"	f	class:openvpn::ReliableMessageBase
ReliableMessageBase	reliable/relcommon.hpp	/^  class ReliableMessageBase$/;"	c	namespace:openvpn
ReliableRecv	ssl/proto.hpp	/^      typedef Base::ReliableRecv ReliableRecv;$/;"	t	class:openvpn::ProtoContext::KeyContext
ReliableRecv	ssl/protostack.hpp	/^    typedef ReliableRecvTemplate<PACKET> ReliableRecv;$/;"	t	class:openvpn::ProtoStackBase
ReliableRecvTemplate	reliable/relrecv.hpp	/^    ReliableRecvTemplate() {}$/;"	f	class:openvpn::ReliableRecvTemplate
ReliableRecvTemplate	reliable/relrecv.hpp	/^    ReliableRecvTemplate(const id_t span) { init(span); }$/;"	f	class:openvpn::ReliableRecvTemplate
ReliableRecvTemplate	reliable/relrecv.hpp	/^  class ReliableRecvTemplate$/;"	c	namespace:openvpn
ReliableSend	ssl/proto.hpp	/^      typedef Base::ReliableSend ReliableSend;$/;"	t	class:openvpn::ProtoContext::KeyContext
ReliableSend	ssl/protostack.hpp	/^    typedef ReliableSendTemplate<PACKET> ReliableSend;$/;"	t	class:openvpn::ProtoStackBase
ReliableSendTemplate	reliable/relsend.hpp	/^    ReliableSendTemplate() : next(0) {}$/;"	f	class:openvpn::ReliableSendTemplate
ReliableSendTemplate	reliable/relsend.hpp	/^    ReliableSendTemplate(const id_t span) { init(span); }$/;"	f	class:openvpn::ReliableSendTemplate
ReliableSendTemplate	reliable/relsend.hpp	/^  class ReliableSendTemplate$/;"	c	namespace:openvpn
RemoteAddress	tun/builder/capture.hpp	/^    class RemoteAddress$/;"	c	class:openvpn::TunBuilderCapture
RemoteItem	client/cliopthelper.hpp	/^    struct RemoteItem {$/;"	s	class:openvpn::ParseClientConfig
RemoteList	client/remotelist.hpp	/^    RemoteList()$/;"	f	class:openvpn::RemoteList
RemoteList	client/remotelist.hpp	/^    RemoteList(RemoteOverride* remote_override_arg)$/;"	f	class:openvpn::RemoteList
RemoteList	client/remotelist.hpp	/^    RemoteList(const OptionList& opt,$/;"	f	class:openvpn::RemoteList
RemoteList	client/remotelist.hpp	/^    RemoteList(const std::string& server_host,$/;"	f	class:openvpn::RemoteList
RemoteList	client/remotelist.hpp	/^  class RemoteList : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
RemoteOverride	client/remotelist.hpp	/^    struct RemoteOverride$/;"	s	class:openvpn::RemoteList
Reply	http/reply.hpp	/^      Reply() : http_version_major(0), http_version_minor(0), status_code(0) {}$/;"	f	struct:openvpn::HTTP::Reply
Reply	http/reply.hpp	/^    struct Reply {$/;"	s	namespace:openvpn::HTTP
ReplyParser	http/reply.hpp	/^      ReplyParser()$/;"	f	class:openvpn::HTTP::ReplyParser
ReplyParser	http/reply.hpp	/^    class ReplyParser {$/;"	c	namespace:openvpn::HTTP
ReplyType	http/reply.hpp	/^    struct ReplyType$/;"	s	namespace:openvpn::HTTP
Request	http/request.hpp	/^      Request() : http_version_major(0), http_version_minor(0) {}$/;"	f	struct:openvpn::HTTP::Request
Request	http/request.hpp	/^    struct Request {$/;"	s	namespace:openvpn::HTTP
RequestParser	http/request.hpp	/^      RequestParser()$/;"	f	class:openvpn::HTTP::RequestParser
RequestParser	http/request.hpp	/^    class RequestParser {$/;"	c	namespace:openvpn::HTTP
RequestType	http/request.hpp	/^    struct RequestType$/;"	s	namespace:openvpn::HTTP
RerouteGW	tun/builder/capture.hpp	/^    class RerouteGW$/;"	c	class:openvpn::TunBuilderCapture
Resolve	client/clievent.hpp	/^      Resolve() : Base(RESOLVE) {}$/;"	f	struct:openvpn::ClientEvent::Resolve
Resolve	client/clievent.hpp	/^    struct Resolve : public Base$/;"	s	namespace:openvpn::ClientEvent
ResolvedAddr	client/remotelist.hpp	/^    struct ResolvedAddr : public RC<thread_unsafe_refcount>$/;"	s	class:openvpn::RemoteList
ResolvedAddrList	client/remotelist.hpp	/^    struct ResolvedAddrList : public std::vector<ResolvedAddr::Ptr>, public RC<thread_unsafe_refcount>$/;"	s	class:openvpn::RemoteList
Result	random/randbytestore.hpp	/^    union Result {$/;"	u	class:openvpn::RandomByteStore
Resume	client/clievent.hpp	/^      Resume() : Base(RESUME) {}$/;"	f	struct:openvpn::ClientEvent::Resume
Resume	client/clievent.hpp	/^    struct Resume : public Base$/;"	s	namespace:openvpn::ClientEvent
Route	addr/route.hpp	/^    typedef RouteType<IP::Addr> Route;$/;"	t	namespace:openvpn::IP
Route	tun/builder/capture.hpp	/^    class Route : public RouteBase \/\/ must be canonical$/;"	c	class:openvpn::TunBuilderCapture
Route4	addr/route.hpp	/^    typedef RouteType<IPv4::Addr> Route4;$/;"	t	namespace:openvpn::IP
Route4List	addr/route.hpp	/^    typedef RouteTypeList<IPv4::Addr> Route4List;$/;"	t	namespace:openvpn::IP
Route6	addr/route.hpp	/^    typedef RouteType<IPv6::Addr> Route6;$/;"	t	namespace:openvpn::IP
Route6List	addr/route.hpp	/^    typedef RouteTypeList<IPv6::Addr> Route6List;$/;"	t	namespace:openvpn::IP
RouteAddress	tun/builder/capture.hpp	/^    class RouteAddress : public RouteBase \/\/ may be non-canonical$/;"	c	class:openvpn::TunBuilderCapture
RouteBase	tun/builder/capture.hpp	/^    class RouteBase$/;"	c	class:openvpn::TunBuilderCapture
RouteInverter	addr/routeinv.hpp	/^      RouteInverter() {}$/;"	f	class:openvpn::IP::RouteInverter
RouteInverter	addr/routeinv.hpp	/^      RouteInverter(const RouteList& in, const Addr::VersionMask vermask)$/;"	f	class:openvpn::IP::RouteInverter
RouteInverter	addr/routeinv.hpp	/^      explicit RouteInverter(const RouteList& in)$/;"	f	class:openvpn::IP::RouteInverter
RouteInverter	addr/routeinv.hpp	/^    class RouteInverter : public RouteList$/;"	c	namespace:openvpn::IP
RouteList	addr/route.hpp	/^    typedef RouteTypeList<IP::Addr> RouteList;$/;"	t	namespace:openvpn::IP
RouteListLinux	netconf/linux/route.hpp	/^    RouteListLinux(const OptionList& opt, const IP::Addr& server_addr_arg)$/;"	f	class:openvpn::RouteListLinux
RouteListLinux	netconf/linux/route.hpp	/^  class RouteListLinux : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
RouteType	addr/route.hpp	/^      RouteType()$/;"	f	struct:openvpn::IP::RouteType
RouteType	addr/route.hpp	/^      RouteType(const ADDR& addr_arg,$/;"	f	struct:openvpn::IP::RouteType
RouteType	addr/route.hpp	/^      RouteType(const std::string& rtstr, const char *title = nullptr)$/;"	f	struct:openvpn::IP::RouteType
RouteType	addr/route.hpp	/^      RouteType(const std::string& rtstr, const std::string& title)$/;"	f	struct:openvpn::IP::RouteType
RouteType	addr/route.hpp	/^    struct RouteType$/;"	s	namespace:openvpn::IP
RouteTypeList	addr/route.hpp	/^    struct RouteTypeList : public std::vector<RouteType<ADDR>>$/;"	s	namespace:openvpn::IP
RunContext	common/runcontext.hpp	/^    RunContext()$/;"	f	class:openvpn::RunContext
RunContext	common/runcontext.hpp	/^  class RunContext : public RunContextBase$/;"	c	namespace:openvpn
RunContextBase	common/runcontext.hpp	/^  struct RunContextBase : public LogBase$/;"	s	namespace:openvpn
RunContextLogEntry	common/runcontext.hpp	/^    RunContextLogEntry(const time_t timestamp_arg, const std::string& text_arg)$/;"	f	struct:openvpn::RunContextLogEntry
RunContextLogEntry	common/runcontext.hpp	/^  struct RunContextLogEntry$/;"	s	namespace:openvpn
SD	common/redir.hpp	/^      SD(asio::io_context& io_context, ScopedFD& fd)$/;"	f	class:openvpn::RedirectPipe::SD
SD	common/redir.hpp	/^    class SD$/;"	c	class:openvpn::RedirectPipe
SD_IN	common/redir.hpp	/^      SD_IN(asio::io_context& io_context, ScopedFD& fd)$/;"	f	class:openvpn::RedirectPipe::SD_IN
SD_IN	common/redir.hpp	/^    class SD_IN : public SD$/;"	c	class:openvpn::RedirectPipe
SD_OUT	common/redir.hpp	/^      SD_OUT(asio::io_context& io_context, const std::string& content, ScopedFD& fd)$/;"	f	class:openvpn::RedirectPipe::SD_OUT
SD_OUT	common/redir.hpp	/^    class SD_OUT : public SD$/;"	c	class:openvpn::RedirectPipe
SECONDARY	ssl/proto.hpp	/^	SECONDARY=1<<2,   \/\/ packet is associated with secondary KeyContext (otherwise primary)$/;"	e	enum:openvpn::ProtoContext::PacketType::__anon81
SEND_PARTIAL	transport/udplink.hpp	/^      SEND_PARTIAL=-2,$/;"	e	enum:openvpn::UDPTransport::__anon86
SEND_SOCKET_HALTED	transport/udplink.hpp	/^      SEND_SOCKET_HALTED=-1,$/;"	e	enum:openvpn::UDPTransport::__anon86
SERIAL	pki/x509track.hpp	/^      SERIAL,$/;"	e	enum:openvpn::X509Track::Type
SERIAL_HEX	pki/x509track.hpp	/^      SERIAL_HEX,$/;"	e	enum:openvpn::X509Track::Type
SERVER	common/mode.hpp	/^      SERVER,$/;"	e	enum:openvpn::Mode::Type
SERVER	ssl/nscert.hpp	/^      SERVER$/;"	e	enum:openvpn::NSCert::Type
SERVER_SUFFIX	transport/protocol.hpp	/^      SERVER_SUFFIX,$/;"	e	enum:openvpn::Protocol::AllowSuffix
SHA1	crypto/cryptoalgs.hpp	/^      SHA1,$/;"	e	enum:openvpn::CryptoAlgs::Type
SHA1	pki/pkcs1.hpp	/^	const unsigned char SHA1[] = { 0x30, 0x21, 0x30, 0x09, 0x06, 0x05,$/;"	m	namespace:openvpn::PKCS1::DigestPrefix::__anon66
SHA1	pki/x509track.hpp	/^      SHA1,$/;"	e	enum:openvpn::X509Track::Type
SHA224	crypto/cryptoalgs.hpp	/^      SHA224,$/;"	e	enum:openvpn::CryptoAlgs::Type
SHA256	crypto/cryptoalgs.hpp	/^      SHA256,$/;"	e	enum:openvpn::CryptoAlgs::Type
SHA256	pki/pkcs1.hpp	/^	const unsigned char SHA256[] = { 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09,$/;"	m	namespace:openvpn::PKCS1::DigestPrefix::__anon66
SHA384	crypto/cryptoalgs.hpp	/^      SHA384,$/;"	e	enum:openvpn::CryptoAlgs::Type
SHA384	pki/pkcs1.hpp	/^	const unsigned char SHA384[] = { 0x30, 0x41, 0x30, 0x0d, 0x06, 0x09,$/;"	m	namespace:openvpn::PKCS1::DigestPrefix::__anon66
SHA512	crypto/cryptoalgs.hpp	/^      SHA512,$/;"	e	enum:openvpn::CryptoAlgs::Type
SHA512	pki/pkcs1.hpp	/^	const unsigned char SHA512[] = { 0x30, 0x51, 0x30, 0x0d, 0x06, 0x09,$/;"	m	namespace:openvpn::PKCS1::DigestPrefix::__anon66
SHORT_FORM	crypto/packet_id.hpp	/^      SHORT_FORM = 0, \/\/ short form of ID (4 bytes)$/;"	e	enum:openvpn::PacketID::__anon39
SHOULD_RETRY	ssl/sslconsts.hpp	/^      SHOULD_RETRY = -1,$/;"	e	enum:openvpn::SSLConst::__anon83
SIGNALED	common/pthreadcond.hpp	/^      SIGNALED,      \/\/ signal() was called$/;"	e	enum:openvpn::PThreadBarrier::State
SIZE	addr/ipv4.hpp	/^      enum { SIZE=32 };$/;"	e	enum:openvpn::IPv4::Addr::__anon3
SIZE	addr/ipv6.hpp	/^      enum { SIZE=128 };$/;"	e	enum:openvpn::IPv6::Addr::__anon5
SIZE	crypto/cryptoalgs.hpp	/^      SIZE,$/;"	e	enum:openvpn::CryptoAlgs::Type
SIZE	random/randbytestore.hpp	/^    static constexpr size_t SIZE = sizeof(typename RAND_TYPE::result_type);$/;"	m	class:openvpn::RandomByteStore
SIZE	ssl/psid.hpp	/^      SIZE=8$/;"	e	enum:openvpn::ProtoSessionID::__anon82
SNAPPY	compress/compress.hpp	/^      SNAPPY,$/;"	e	enum:openvpn::CompressContext::Type
SNAPPY_COMPRESS	compress/snappy.hpp	/^      SNAPPY_COMPRESS = 0x68,$/;"	e	enum:openvpn::CompressSnappy::__anon37
SOCKET_PROTECT_ERROR	error/error.hpp	/^      SOCKET_PROTECT_ERROR, \/\/ Error calling protect() method on socket$/;"	e	enum:openvpn::Error::Type
SOFT_RESET	ssl/proto.hpp	/^	SOFT_RESET=1<<3,  \/\/ packet is a CONTROL_SOFT_RESET_V1 msg indicating a request for SSL\/TLS renegotiate$/;"	e	enum:openvpn::ProtoContext::PacketType::__anon81
SPtr	transport/tcplink.hpp	/^      typedef std::unique_ptr<PacketFrom> SPtr;$/;"	t	struct:openvpn::TCPTransport::PacketFrom
SPtr	transport/udplink.hpp	/^      typedef std::unique_ptr<PacketFrom> SPtr;$/;"	t	struct:openvpn::UDPTransport::PacketFrom
SPtr	tun/builder/client.hpp	/^      typedef std::unique_ptr<PacketFrom> SPtr;$/;"	t	struct:openvpn::TunBuilderClient::PacketFrom
SPtr	tun/linux/tun.hpp	/^      typedef std::unique_ptr<PacketFrom> SPtr;$/;"	t	struct:openvpn::TunLinux::PacketFrom
SPtr	tun/mac/client/tuncli.hpp	/^      typedef std::unique_ptr<PacketFrom> SPtr;$/;"	t	struct:openvpn::TunMac::PacketFrom
SPtr	tun/win/client/tuncli.hpp	/^      typedef std::unique_ptr<PacketFrom> SPtr;$/;"	t	struct:openvpn::TunWin::PacketFrom
SSL	applecrypto/ssl/sslctx.hpp	/^      SSL(const AppleSSLContext& ctx)$/;"	f	class:openvpn::AppleSSLContext::SSL
SSL	applecrypto/ssl/sslctx.hpp	/^    class SSL : public SSLAPI$/;"	c	class:openvpn::AppleSSLContext
SSL	openssl/ssl/sslctx.hpp	/^      SSL(const OpenSSLContext& ctx, const char *hostname)$/;"	f	class:openvpn::OpenSSLContext::SSL
SSL	openssl/ssl/sslctx.hpp	/^    class SSL : public SSLAPI$/;"	c	class:openvpn::OpenSSLContext
SSL	polarssl/ssl/sslctx.hpp	/^      SSL(PolarSSLContext* ctx, const char *hostname)$/;"	f	class:openvpn::PolarSSLContext::SSL
SSL	polarssl/ssl/sslctx.hpp	/^    class SSL : public SSLAPI$/;"	c	class:openvpn::PolarSSLContext
SSLAPI	ssl/sslapi.hpp	/^  class SSLAPI : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
SSLAPI	ssl/sslchoose.hpp	/^    typedef PolarSSLContext SSLAPI;$/;"	t	namespace:openvpn::SSLLib
SSLConfigAPI	ssl/sslapi.hpp	/^  class SSLConfigAPI : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
SSLConst	ssl/sslconsts.hpp	/^  namespace SSLConst {$/;"	n	namespace:openvpn
SSLFactoryAPI	ssl/sslapi.hpp	/^  class SSLFactoryAPI : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
SSLLib	ssl/sslchoose.hpp	/^  namespace SSLLib {$/;"	n	namespace:openvpn
SSLMode	server/listenlist.hpp	/^      enum SSLMode {$/;"	g	struct:openvpn::Listen::Item
SSLOff	server/listenlist.hpp	/^	SSLOff,$/;"	e	enum:openvpn::Listen::Item::SSLMode
SSLOn	server/listenlist.hpp	/^	SSLOn,$/;"	e	enum:openvpn::Listen::Item::SSLMode
SSLUnspecified	server/listenlist.hpp	/^	SSLUnspecified,$/;"	e	enum:openvpn::Listen::Item::SSLMode
SSL_ERROR	error/error.hpp	/^      SSL_ERROR,           \/\/ errors resulting from read\/write on SSL object$/;"	e	enum:openvpn::Error::Type
SSL_PARTIAL_WRITE	error/error.hpp	/^      SSL_PARTIAL_WRITE,   \/\/ SSL object did not process all written cleartext$/;"	e	enum:openvpn::Error::Type
ST	pki/x509track.hpp	/^      ST,$/;"	e	enum:openvpn::X509Track::Type
STATE_UNDEF	ssl/proto.hpp	/^      STATE_UNDEF=-1,$/;"	e	enum:openvpn::ProtoContext::__anon80
STATUS_GOOD	common/options.hpp	/^      STATUS_GOOD,$/;"	e	enum:openvpn::Option::validate_status
STATUS_LENGTH	common/options.hpp	/^      STATUS_LENGTH,$/;"	e	enum:openvpn::Option::validate_status
STATUS_MULTILINE	common/options.hpp	/^      STATUS_MULTILINE,$/;"	e	enum:openvpn::Option::validate_status
SUBROUTE	addr/routeinv.hpp	/^	SUBROUTE,$/;"	e	enum:openvpn::IP::RouteInverter::Type
SUCCESS	common/pthreadcond.hpp	/^      SUCCESS=0,  \/\/ successful$/;"	e	enum:openvpn::PThreadBarrier::Status
SUCCESS	error/error.hpp	/^      SUCCESS=0,           \/\/ no error$/;"	e	enum:openvpn::Error::Type
SUPPORTS_IN_PLACE_ENCRYPT	openssl/crypto/ciphergcm.hpp	/^	SUPPORTS_IN_PLACE_ENCRYPT = 0,$/;"	e	enum:openvpn::OpenSSLCrypto::CipherContextGCM::__anon58
SUPPORTS_IN_PLACE_ENCRYPT	polarssl/crypto/ciphergcm.hpp	/^	SUPPORTS_IN_PLACE_ENCRYPT = 1,$/;"	e	enum:openvpn::PolarSSLCrypto::CipherContextGCM::__anon70
SYNCHRONOUS	tun/mac/macdns_watchdog.hpp	/^      SYNCHRONOUS      = (1<<1),$/;"	e	enum:openvpn::MacDNSWatchdog::__anon93
SYSPATH_FMT_CHAR	win/call.hpp	/^#     define SYSPATH_FMT_CHAR /;"	d
SYSPATH_FMT_CHAR	win/call.hpp	/^#     undef SYSPATH_FMT_CHAR$/;"	d
SYSPATH_LEN_METH	win/call.hpp	/^#     define SYSPATH_LEN_METH(/;"	d
SYSPATH_LEN_METH	win/call.hpp	/^#     undef SYSPATH_LEN_METH$/;"	d
S_EOF	common/splitlines.hpp	/^      S_EOF,$/;"	e	enum:openvpn::SplitLinesType::Status
S_ERROR	common/splitlines.hpp	/^      S_ERROR$/;"	e	enum:openvpn::SplitLinesType::Status
S_INITIAL	ssl/proto.hpp	/^      S_INITIAL=7,$/;"	e	enum:openvpn::ProtoContext::__anon80
S_OKAY	common/splitlines.hpp	/^      S_OKAY,$/;"	e	enum:openvpn::SplitLinesType::Status
S_SIGHUP	common/asiosignal.hpp	/^      S_SIGHUP  = (1<<3),$/;"	e	enum:openvpn::ASIOSignals::__anon18
S_SIGINT	common/asiosignal.hpp	/^      S_SIGINT  = (1<<0),$/;"	e	enum:openvpn::ASIOSignals::__anon18
S_SIGQUIT	common/asiosignal.hpp	/^      S_SIGQUIT = (1<<2),$/;"	e	enum:openvpn::ASIOSignals::__anon18
S_SIGTERM	common/asiosignal.hpp	/^      S_SIGTERM = (1<<1),$/;"	e	enum:openvpn::ASIOSignals::__anon18
S_SIGUSR1	common/asiosignal.hpp	/^      S_SIGUSR1  = (1<<4),$/;"	e	enum:openvpn::ASIOSignals::__anon18
S_SIGUSR2	common/asiosignal.hpp	/^      S_SIGUSR2  = (1<<5),$/;"	e	enum:openvpn::ASIOSignals::__anon18
S_WAIT_AUTH	ssl/proto.hpp	/^      S_WAIT_AUTH=9,$/;"	e	enum:openvpn::ProtoContext::__anon80
S_WAIT_AUTH_ACK	ssl/proto.hpp	/^      S_WAIT_AUTH_ACK=3,$/;"	e	enum:openvpn::ProtoContext::__anon80
S_WAIT_RESET	ssl/proto.hpp	/^      S_WAIT_RESET=8,   \/\/ must be S_INITIAL+1$/;"	e	enum:openvpn::ProtoContext::__anon80
S_WAIT_RESET_ACK	ssl/proto.hpp	/^      S_WAIT_RESET_ACK=2,$/;"	e	enum:openvpn::ProtoContext::__anon80
SafeString	buffer/safestr.hpp	/^    SafeString()$/;"	f	class:openvpn::SafeString
SafeString	buffer/safestr.hpp	/^    SafeString(const char *str)$/;"	f	class:openvpn::SafeString
SafeString	buffer/safestr.hpp	/^    SafeString(const char *str, const size_t size)$/;"	f	class:openvpn::SafeString
SafeString	buffer/safestr.hpp	/^    SafeString(const std::string& str)$/;"	f	class:openvpn::SafeString
SafeString	buffer/safestr.hpp	/^  class SafeString$/;"	c	namespace:openvpn
Scope	common/stop.hpp	/^      Scope(Stop* stop_arg, std::function<void()>&& method_arg)$/;"	f	class:openvpn::Stop::Scope
Scope	common/stop.hpp	/^    class Scope$/;"	c	class:openvpn::Stop
ScopedAsioStream	common/scoped_asio_stream.hpp	/^    ScopedAsioStream() : obj_(undefined()) {}$/;"	f	class:openvpn::ScopedAsioStream
ScopedAsioStream	common/scoped_asio_stream.hpp	/^    explicit ScopedAsioStream(STREAM *obj)$/;"	f	class:openvpn::ScopedAsioStream
ScopedAsioStream	common/scoped_asio_stream.hpp	/^  class ScopedAsioStream$/;"	c	namespace:openvpn
ScopedFD	common/scoped_fd.hpp	/^    ScopedFD() : fd(undefined()) {}$/;"	f	class:openvpn::ScopedFD
ScopedFD	common/scoped_fd.hpp	/^    explicit ScopedFD(const int fd_arg)$/;"	f	class:openvpn::ScopedFD
ScopedFD	common/scoped_fd.hpp	/^  class ScopedFD$/;"	c	namespace:openvpn
ScopedHANDLE	win/scoped_handle.hpp	/^      ScopedHANDLE() : handle(Handle::undefined()) {}$/;"	f	class:openvpn::Win::ScopedHANDLE
ScopedHANDLE	win/scoped_handle.hpp	/^      explicit ScopedHANDLE(HANDLE h)$/;"	f	class:openvpn::Win::ScopedHANDLE
ScopedHANDLE	win/scoped_handle.hpp	/^    class ScopedHANDLE$/;"	c	namespace:openvpn::Win
ScopedTAPStream	tun/win/client/tuncli.hpp	/^    typedef ScopedAsioStream<TAPStream> ScopedTAPStream;$/;"	t	namespace:openvpn::TunWin
ScopedTUNStream	tun/mac/client/tuncli.hpp	/^    typedef ScopedAsioStream<TUNStream> ScopedTUNStream;$/;"	t	namespace:openvpn::TunMac
SearchDomain	tun/builder/capture.hpp	/^    class SearchDomain$/;"	c	class:openvpn::TunBuilderCapture
SelfTest	crypto/selftest.hpp	/^  namespace SelfTest {$/;"	n	namespace:openvpn
SendRecvQueue	transport/gremlin.hpp	/^      SendRecvQueue(asio::io_context& io_context,$/;"	f	class:openvpn::Gremlin::SendRecvQueue
SendRecvQueue	transport/gremlin.hpp	/^    class SendRecvQueue$/;"	c	namespace:openvpn::Gremlin
ServerEntry	client/cliopthelper.hpp	/^    struct ServerEntry {$/;"	s	class:openvpn::ParseClientConfig
ServerList	client/cliopthelper.hpp	/^    struct ServerList : public std::vector<ServerEntry>$/;"	s	class:openvpn::ParseClientConfig
ServerProto	server/servproto.hpp	/^  class ServerProto$/;"	c	namespace:openvpn
ServerPushList	options/servpush.hpp	/^  class ServerPushList : public std::vector<std::string>$/;"	c	namespace:openvpn
ServerThreadBase	common/runcontext.hpp	/^  typedef ServerThreadType<RC<thread_safe_refcount>> ServerThreadBase;$/;"	t	namespace:openvpn
ServerThreadType	common/runcontext.hpp	/^  struct ServerThreadType : public virtual RC_TYPE$/;"	s	namespace:openvpn
ServerThreadWeakBase	common/runcontext.hpp	/^  typedef ServerThreadType<RCWeak<thread_safe_refcount>> ServerThreadWeakBase;$/;"	t	namespace:openvpn
ServiceUnavailable	http/status.hpp	/^	ServiceUnavailable=503,$/;"	e	enum:openvpn::HTTP::Status::__anon45
Session	client/cliproto.hpp	/^      Session(asio::io_context& io_context_arg,$/;"	f	class:openvpn::ClientProto::Session
Session	client/cliproto.hpp	/^    class Session : ProtoContext,$/;"	c	namespace:openvpn::ClientProto
Session	server/servproto.hpp	/^      Session(asio::io_context& io_context_arg,$/;"	f	class:openvpn::ServerProto::Session
Session	server/servproto.hpp	/^    class Session : Base,                  \/\/ OpenVPN protocol implementation$/;"	c	class:openvpn::ServerProto
SessionStats	log/sessionstats.hpp	/^    SessionStats()$/;"	f	class:openvpn::SessionStats
SessionStats	log/sessionstats.hpp	/^  class SessionStats : public RC<thread_safe_refcount>$/;"	c	namespace:openvpn
Set	pki/x509track.hpp	/^    struct Set : public std::vector<KeyValue>$/;"	s	namespace:openvpn::X509Track
Set	ssl/peerinfo.hpp	/^    struct Set : public std::vector<KeyValue>, public RCCopyable<thread_unsafe_refcount>$/;"	s	namespace:openvpn::PeerInfo
SetUserGroup	common/usergroup.hpp	/^    SetUserGroup(const char *user, const char *group)$/;"	f	class:openvpn::SetUserGroup
SetUserGroup	common/usergroup.hpp	/^    SetUserGroup(const std::string& user, const std::string& group)$/;"	f	class:openvpn::SetUserGroup
SetUserGroup	common/usergroup.hpp	/^  class SetUserGroup$/;"	c	namespace:openvpn
Setup	tun/mac/client/tunsetup.hpp	/^    class Setup : public TunBuilderSetup::Base$/;"	c	namespace:openvpn::TunMac
Setup	tun/win/client/tunsetup.hpp	/^    class Setup : public SetupBase$/;"	c	namespace:openvpn::TunWin
SetupBase	tun/win/client/setupbase.hpp	/^    struct SetupBase : public DestructorBase$/;"	s	namespace:openvpn::TunWin
SetupFactory	tun/win/client/setupbase.hpp	/^    struct SetupFactory : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn::TunWin
Signal	common/signal.hpp	/^    Signal(const handler_t handler, const unsigned int flags)$/;"	f	class:openvpn::Signal
Signal	common/signal.hpp	/^  class Signal$/;"	c	namespace:openvpn
SignalBlocker	common/signal.hpp	/^    SignalBlocker(const unsigned int flags) \/\/ use signal mask from class Signal$/;"	f	class:openvpn::SignalBlocker
SignalBlocker	common/signal.hpp	/^  class SignalBlocker$/;"	c	namespace:openvpn
SignalBlockerDefault	common/signal.hpp	/^    SignalBlockerDefault()$/;"	f	struct:openvpn::SignalBlockerDefault
SignalBlockerDefault	common/signal.hpp	/^  struct SignalBlockerDefault : public SignalBlocker$/;"	s	namespace:openvpn
SignalBlockerPipe	common/signal.hpp	/^    SignalBlockerPipe()$/;"	f	struct:openvpn::SignalBlockerPipe
SignalBlockerPipe	common/signal.hpp	/^  struct SignalBlockerPipe : public SignalBlocker$/;"	s	namespace:openvpn
SockOpt	common/peercred.hpp	/^  namespace SockOpt {$/;"	n	namespace:openvpn
SockOpt	common/sockopt.hpp	/^  namespace SockOpt {$/;"	n	namespace:openvpn
Socket	common/asioboundsock.hpp	/^      explicit Socket(asio::io_context& io_context)$/;"	f	struct:openvpn::AsioBoundSocket::Socket
Socket	common/asioboundsock.hpp	/^    struct Socket : public SocketBase$/;"	s	namespace:openvpn::AsioBoundSocket
SocketBase	common/asioboundsock.hpp	/^    typedef asio::basic_stream_socket<asio::ip::tcp, SocketService> SocketBase;$/;"	t	namespace:openvpn::AsioBoundSocket
SocketProtect	transport/socket_protect.hpp	/^  class SocketProtect {$/;"	c	namespace:openvpn
SocketService	common/asioboundsock.hpp	/^      explicit SocketService(asio::io_context& io_context)$/;"	f	struct:openvpn::AsioBoundSocket::SocketService
SocketService	common/asioboundsock.hpp	/^    struct SocketService : public SocketServiceBase$/;"	s	namespace:openvpn::AsioBoundSocket
SocketServiceBase	common/asioboundsock.hpp	/^    typedef asio::stream_socket_service<asio::ip::tcp> SocketServiceBase;$/;"	t	namespace:openvpn::AsioBoundSocket
SpaceMatch	common/lex.hpp	/^  struct SpaceMatch$/;"	s	namespace:openvpn
Split	common/split.hpp	/^  namespace Split {$/;"	n	namespace:openvpn
SplitLines	common/splitlines.hpp	/^  typedef SplitLinesType<std::string> SplitLines;$/;"	t	namespace:openvpn
SplitLinesType	common/splitlines.hpp	/^    SplitLinesType(const STRING& str, const size_t max_line_len_arg=0)$/;"	f	class:openvpn::SplitLinesType
SplitLinesType	common/splitlines.hpp	/^  class SplitLinesType$/;"	c	namespace:openvpn
SrcList	applecrypto/cf/cf.hpp	/^    typedef BufferAllocatedType<CFTypeRef> SrcList;$/;"	t	namespace:openvpn::CF
StandardLex	common/lex.hpp	/^    StandardLex() : in_quote_(false), backslash(false), ch(-1) {}$/;"	f	class:openvpn::StandardLex
StandardLex	common/lex.hpp	/^  class StandardLex$/;"	c	namespace:openvpn
State	apple/maclife.hpp	/^      State()$/;"	f	struct:openvpn::MacLifeCycle::State
State	apple/maclife.hpp	/^      State(bool net_up_arg, const std::string& iface_arg, bool sleep_arg)$/;"	f	struct:openvpn::MacLifeCycle::State
State	apple/maclife.hpp	/^    struct State$/;"	s	class:openvpn::MacLifeCycle
State	applecrypto/crypto/hmac.hpp	/^      enum State {$/;"	g	class:openvpn::AppleCrypto::HMACContext
State	common/pthreadcond.hpp	/^    enum State {$/;"	g	class:openvpn::PThreadBarrier
State	http/htmlskip.hpp	/^      enum State {$/;"	g	class:openvpn::HTTP::HTMLSkip
State	http/reply.hpp	/^      typedef Reply State;$/;"	t	struct:openvpn::HTTP::ReplyType
State	http/request.hpp	/^      typedef Request State;$/;"	t	struct:openvpn::HTTP::RequestType
State	ssl/datalimit.hpp	/^    enum State {$/;"	g	class:openvpn::DataLimit
State	tun/client/tunprop.hpp	/^    struct State : public RC<thread_unsafe_refcount>$/;"	s	class:openvpn::TunProp
StaticKey	crypto/static_key.hpp	/^    StaticKey() {}$/;"	f	class:openvpn::StaticKey
StaticKey	crypto/static_key.hpp	/^    StaticKey(const unsigned char *key_data, const size_t key_size)$/;"	f	class:openvpn::StaticKey
StaticKey	crypto/static_key.hpp	/^  class StaticKey$/;"	c	namespace:openvpn
Stats	log/sessionstats.hpp	/^    enum Stats {$/;"	g	class:openvpn::SessionStats
Status	applecrypto/util/reach.hpp	/^    enum Status {$/;"	g	struct:openvpn::ReachabilityInterface
Status	applecrypto/util/reachable.hpp	/^    typedef ReachabilityInterface::Status Status;$/;"	t	class:openvpn::ReachabilityBase
Status	buffer/buffer.hpp	/^    enum Status {$/;"	g	class:openvpn::BufferException
Status	common/pthreadcond.hpp	/^    enum Status {$/;"	g	class:openvpn::PThreadBarrier
Status	common/splitlines.hpp	/^    enum Status {$/;"	g	class:openvpn::SplitLinesType
Status	http/htmlskip.hpp	/^      enum Status {$/;"	g	class:openvpn::HTTP::HTMLSkip
Status	http/status.hpp	/^    namespace Status {$/;"	n	namespace:openvpn::HTTP
Status	options/merge.hpp	/^    enum Status {$/;"	g	class:openvpn::ProfileMerge
Stop	common/stop.hpp	/^    Stop()$/;"	f	class:openvpn::Stop
Stop	common/stop.hpp	/^  class Stop$/;"	c	namespace:openvpn
StringList	client/clihalt.hpp	/^    typedef std::vector<std::string> StringList;$/;"	t	class:openvpn::ClientHalt
StringPair	addr/addrpair.hpp	/^	StringPair()$/;"	f	class:openvpn::IP::AddrMaskPair::StringPair
StringPair	addr/addrpair.hpp	/^	explicit StringPair(const std::string& s1)$/;"	f	class:openvpn::IP::AddrMaskPair::StringPair
StringPair	addr/addrpair.hpp	/^	explicit StringPair(const std::string& s1, const std::string& s2)$/;"	f	class:openvpn::IP::AddrMaskPair::StringPair
StringPair	addr/addrpair.hpp	/^      class StringPair {$/;"	c	struct:openvpn::IP::AddrMaskPair
Strong	common/rc.hpp	/^    typedef RCPtr<T> Strong;$/;"	t	class:openvpn::RCWeakPtr
TAPDHCPMasquerade	tun/win/tunutil.hpp	/^      class TAPDHCPMasquerade$/;"	c	namespace:openvpn::TunWin::Util
TAPDriverVersion	tun/win/tunutil.hpp	/^	TAPDriverVersion(HANDLE th)$/;"	f	class:openvpn::TunWin::Util::TAPDriverVersion
TAPDriverVersion	tun/win/tunutil.hpp	/^      class TAPDriverVersion$/;"	c	namespace:openvpn::TunWin::Util
TAPStream	tun/win/client/tuncli.hpp	/^    typedef asio::windows::stream_handle TAPStream;$/;"	t	namespace:openvpn::TunWin
TAP_NOT_SUPPORTED	error/error.hpp	/^      TAP_NOT_SUPPORTED,   \/\/ dev tap is present in profile but not supported$/;"	e	enum:openvpn::Error::Type
TCP	common/asiopolysock.hpp	/^      TCP(asio::io_context& io_context,$/;"	f	struct:openvpn::AsioPolySock::TCP
TCP	common/asiopolysock.hpp	/^    struct TCP : public Base$/;"	s	namespace:openvpn::AsioPolySock
TCP	ip/ip.hpp	/^      TCP = 6,  \/* TCP protocol *\/$/;"	e	enum:openvpn::IPHeader::__anon51
TCP	transport/protocol.hpp	/^      TCP=TCPv4,$/;"	e	enum:openvpn::Protocol::Type
TCPTransport	transport/client/tcpcli.hpp	/^  namespace TCPTransport {$/;"	n	namespace:openvpn
TCPTransport	transport/tcplink.hpp	/^  namespace TCPTransport {$/;"	n	namespace:openvpn
TCP_CONNECT_ERROR	error/error.hpp	/^      TCP_CONNECT_ERROR,   \/\/ client error on TCP connect$/;"	e	enum:openvpn::Error::Type
TCP_MODE	crypto/packet_id.hpp	/^      TCP_MODE = 1$/;"	e	enum:openvpn::PacketIDReceiveType::__anon40
TCP_OVERFLOW	error/error.hpp	/^      TCP_OVERFLOW,        \/\/ TCP output queue overflow$/;"	e	enum:openvpn::Error::Type
TCP_SIZE_ERROR	error/error.hpp	/^      TCP_SIZE_ERROR,      \/\/ bad embedded uint16_t TCP packet size$/;"	e	enum:openvpn::Error::Type
TCPv4	transport/protocol.hpp	/^      TCPv4,$/;"	e	enum:openvpn::Protocol::Type
TCPv6	transport/protocol.hpp	/^      TCPv6,$/;"	e	enum:openvpn::Protocol::Type
TERM_OVERHEAD	client/cliconstants.hpp	/^      TERM_OVERHEAD=16,        \/\/ bytes overhead of one argument in an option, for accounting purposes$/;"	e	enum:openvpn::ProfileParseLimits::__anon15
TIMEOUT	common/pthreadcond.hpp	/^      TIMEOUT,    \/\/ timeout$/;"	e	enum:openvpn::PThreadBarrier::Status
TLSAuthPreValidate	ssl/proto.hpp	/^      TLSAuthPreValidate(const Config& c, const bool server)$/;"	f	class:openvpn::ProtoContext::TLSAuthPreValidate
TLSAuthPreValidate	ssl/proto.hpp	/^    class TLSAuthPreValidate : public RC<thread_unsafe_refcount>$/;"	c	class:openvpn::ProtoContext
TLSPRF	ssl/tlsprf.hpp	/^    TLSPRF(const bool server)$/;"	f	class:openvpn::TLSPRF
TLSPRF	ssl/tlsprf.hpp	/^  class TLSPRF$/;"	c	namespace:openvpn
TLSPRFFactory	ssl/tlsprf.hpp	/^  class TLSPRFFactory : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
TLSPRFInstance	ssl/tlsprf.hpp	/^  class TLSPRFInstance : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
TLSRemote	ssl/tls_remote.hpp	/^  namespace TLSRemote {$/;"	n	namespace:openvpn
TLSVersion	ssl/tlsver.hpp	/^  namespace TLSVersion {$/;"	n	namespace:openvpn
TLSVersionMinFail	client/clievent.hpp	/^      TLSVersionMinFail() : Base(TLS_VERSION_MIN) {}$/;"	f	struct:openvpn::ClientEvent::TLSVersionMinFail
TLSVersionMinFail	client/clievent.hpp	/^    struct TLSVersionMinFail : public Base$/;"	s	namespace:openvpn::ClientEvent
TLSWebType	ssl/kuparse.hpp	/^    enum TLSWebType {$/;"	g	namespace:openvpn::KUParse
TLS_AUTH_FAIL	error/error.hpp	/^      TLS_AUTH_FAIL,       \/\/ tls-auth HMAC verification failed$/;"	e	enum:openvpn::Error::Type
TLS_VERSION_MIN	client/clievent.hpp	/^      TLS_VERSION_MIN,$/;"	e	enum:openvpn::ClientEvent::Type
TLS_VERSION_MIN	error/error.hpp	/^      TLS_VERSION_MIN,     \/\/ peer cannot handshake at our minimum required TLS version$/;"	e	enum:openvpn::Error::Type
TLS_WEB_CLIENT	ssl/kuparse.hpp	/^      TLS_WEB_CLIENT,$/;"	e	enum:openvpn::KUParse::TLSWebType
TLS_WEB_NONE	ssl/kuparse.hpp	/^      TLS_WEB_NONE,$/;"	e	enum:openvpn::KUParse::TLSWebType
TLS_WEB_SERVER	ssl/kuparse.hpp	/^      TLS_WEB_SERVER,$/;"	e	enum:openvpn::KUParse::TLSWebType
TOK_SIZE	openssl/util/tokenencrypt.hpp	/^    static constexpr size_t TOK_SIZE = 32;$/;"	m	class:openvpn::TokenEncrypt
TRANSPORT_ERROR	client/clievent.hpp	/^      TRANSPORT_ERROR,$/;"	e	enum:openvpn::ClientEvent::Type
TRANSPORT_ERROR	error/error.hpp	/^      TRANSPORT_ERROR,     \/\/ general transport error$/;"	e	enum:openvpn::Error::Type
TRIM_LEADING_SPACES	common/split.hpp	/^      TRIM_LEADING_SPACES=(1<<0),$/;"	e	enum:openvpn::Split::__anon24
TRIM_SPECIAL	common/split.hpp	/^      TRIM_SPECIAL=(1<<1), \/\/ trims quotes (but respects their content)$/;"	e	enum:openvpn::Split::__anon24
TRY_FILE	common/userpass.hpp	/^      TRY_FILE = (1<<4),            \/\/ option argument might be a filename, try to load creds from it$/;"	e	enum:openvpn::UserPass::Flags
TUNStream	tun/mac/client/tuncli.hpp	/^    typedef asio::posix::stream_descriptor TUNStream;$/;"	t	namespace:openvpn::TunMac
TUN_BYTES_IN	log/sessionstats.hpp	/^      TUN_BYTES_IN,        \/\/ tun\/tap bytes in$/;"	e	enum:openvpn::SessionStats::Stats
TUN_BYTES_OUT	log/sessionstats.hpp	/^      TUN_BYTES_OUT,       \/\/ tun\/tap bytes out$/;"	e	enum:openvpn::SessionStats::Stats
TUN_ERROR	client/clievent.hpp	/^      TUN_ERROR,$/;"	e	enum:openvpn::ClientEvent::Type
TUN_ERROR	error/error.hpp	/^      TUN_ERROR,           \/\/ general tun error$/;"	e	enum:openvpn::Error::Type
TUN_FRAMING_ERROR	error/error.hpp	/^      TUN_FRAMING_ERROR,   \/\/ error with tun PF_INET\/PF_INET6 prefix$/;"	e	enum:openvpn::Error::Type
TUN_IFACE_CREATE	client/clievent.hpp	/^      TUN_IFACE_CREATE,$/;"	e	enum:openvpn::ClientEvent::Type
TUN_IFACE_CREATE	error/error.hpp	/^      TUN_IFACE_CREATE,    \/\/ error creating tun\/tap interface$/;"	e	enum:openvpn::Error::Type
TUN_IFACE_DISABLED	client/clievent.hpp	/^      TUN_IFACE_DISABLED,$/;"	e	enum:openvpn::ClientEvent::Type
TUN_IFACE_DISABLED	error/error.hpp	/^      TUN_IFACE_DISABLED,  \/\/ tun\/tap interface is disabled$/;"	e	enum:openvpn::Error::Type
TUN_PACKETS_IN	log/sessionstats.hpp	/^      TUN_PACKETS_IN,      \/\/ tun\/tap packets in$/;"	e	enum:openvpn::SessionStats::Stats
TUN_PACKETS_OUT	log/sessionstats.hpp	/^      TUN_PACKETS_OUT,     \/\/ tun\/tap packets out$/;"	e	enum:openvpn::SessionStats::Stats
TUN_READ_ERROR	error/error.hpp	/^      TUN_READ_ERROR,      \/\/ read errors on tun\/tap interface$/;"	e	enum:openvpn::Error::Type
TUN_SETUP_FAILED	client/clievent.hpp	/^      TUN_SETUP_FAILED,$/;"	e	enum:openvpn::ClientEvent::Type
TUN_SETUP_FAILED	error/error.hpp	/^      TUN_SETUP_FAILED,    \/\/ error setting up tun\/tap interface$/;"	e	enum:openvpn::Error::Type
TUN_WRITE_ERROR	error/error.hpp	/^      TUN_WRITE_ERROR,     \/\/ write errors on tun\/tap interface$/;"	e	enum:openvpn::Error::Type
TapNameGuidPair	tun/win/tunutil.hpp	/^	TapNameGuidPair() : index(DWORD(-1)) {}$/;"	f	struct:openvpn::TunWin::Util::TapNameGuidPair
TapNameGuidPair	tun/win/tunutil.hpp	/^      struct TapNameGuidPair$/;"	s	namespace:openvpn::TunWin::Util
TapNameGuidPairList	tun/win/tunutil.hpp	/^	TapNameGuidPairList()$/;"	f	struct:openvpn::TunWin::Util::TapNameGuidPairList
TapNameGuidPairList	tun/win/tunutil.hpp	/^      struct TapNameGuidPairList : public std::vector<TapNameGuidPair>$/;"	s	namespace:openvpn::TunWin::Util
TempFile	common/tempfile.hpp	/^    TempFile(const std::string& fn_template,$/;"	f	class:openvpn::TempFile
TempFile	common/tempfile.hpp	/^  class TempFile$/;"	c	namespace:openvpn
ThreadContext	common/runcontext.hpp	/^      ThreadContext(RunContext& ctx_arg)$/;"	f	class:openvpn::RunContext::ThreadContext
ThreadContext	common/runcontext.hpp	/^    class ThreadContext$/;"	c	class:openvpn::RunContext
Time	time/time.hpp	/^  typedef TimeType<oulong> Time;$/;"	t	namespace:openvpn
TimePtr	time/time.hpp	/^  typedef Time* TimePtr;$/;"	t	namespace:openvpn
TimeType	time/time.hpp	/^    explicit TimeType(const T time) : time_(time) {}$/;"	f	class:openvpn::TimeType
TimeType	time/time.hpp	/^  class TimeType$/;"	c	namespace:openvpn
Title	win/console.hpp	/^	Title(const std::string& new_title)$/;"	f	class:openvpn::Win::Console::Title
Title	win/console.hpp	/^      class Title$/;"	c	namespace:openvpn::Win::Console
TokenEncrypt	openssl/util/tokenencrypt.hpp	/^    TokenEncrypt(const Key& key, const int mode)$/;"	f	class:openvpn::TokenEncrypt
TokenEncrypt	openssl/util/tokenencrypt.hpp	/^  class TokenEncrypt$/;"	c	namespace:openvpn
TokenEncryptDecrypt	openssl/util/tokenencrypt.hpp	/^    TokenEncryptDecrypt(const TokenEncrypt::Key& key)$/;"	f	struct:openvpn::TokenEncryptDecrypt
TokenEncryptDecrypt	openssl/util/tokenencrypt.hpp	/^  struct TokenEncryptDecrypt$/;"	s	namespace:openvpn
TransportClient	transport/client/transbase.hpp	/^  struct TransportClient : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TransportClientFactory	transport/client/transbase.hpp	/^  struct TransportClientFactory : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TransportClientInstanceFactory	transport/server/transbase.hpp	/^  struct TransportClientInstanceFactory : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TransportClientInstanceRecv	transport/server/transbase.hpp	/^  struct TransportClientInstanceRecv : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TransportClientInstanceSend	transport/server/transbase.hpp	/^  struct TransportClientInstanceSend : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TransportClientParent	transport/client/transbase.hpp	/^  struct TransportClientParent$/;"	s	namespace:openvpn
TransportConfig	transport/dco.hpp	/^      TransportConfig()$/;"	f	struct:openvpn::DCO::TransportConfig
TransportConfig	transport/dco.hpp	/^    struct TransportConfig$/;"	s	struct:openvpn::DCO
TransportError	client/clievent.hpp	/^      TransportError(std::string reason) : ReasonBase(TRANSPORT_ERROR, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::TransportError
TransportError	client/clievent.hpp	/^    struct TransportError : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
TransportLink	server/servproto.hpp	/^    typedef Link<TransportClientInstanceSend, TransportClientInstanceRecv> TransportLink;$/;"	t	class:openvpn::ServerProto
TransportMutateStream	transport/mutate.hpp	/^  class TransportMutateStream : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
TransportServer	transport/server/transbase.hpp	/^  struct TransportServer : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TransportServerFactory	transport/server/transbase.hpp	/^  struct TransportServerFactory : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
Tun	tun/builder/client.hpp	/^      Tun(asio::io_context& io_context,$/;"	f	class:openvpn::TunBuilderClient::Tun
Tun	tun/builder/client.hpp	/^    class Tun : public TunIO<ReadHandler, PacketFrom, asio::posix::stream_descriptor>$/;"	c	namespace:openvpn::TunBuilderClient
Tun	tun/linux/tun.hpp	/^      Tun(asio::io_context& io_context,$/;"	f	class:openvpn::TunLinux::Tun
Tun	tun/linux/tun.hpp	/^    class Tun : public TunIO<ReadHandler, PacketFrom, asio::posix::stream_descriptor>$/;"	c	namespace:openvpn::TunLinux
Tun	tun/mac/client/tuncli.hpp	/^      Tun(const typename TunPersist::Ptr& tun_persist,$/;"	f	class:openvpn::TunMac::Tun
Tun	tun/mac/client/tuncli.hpp	/^    class Tun : public TunIO<ReadHandler, PacketFrom, TunWrapAsioStream<TunPersist> >$/;"	c	namespace:openvpn::TunMac
Tun	tun/win/client/tuncli.hpp	/^      Tun(const typename TunPersist::Ptr& tun_persist,$/;"	f	class:openvpn::TunWin::Tun
Tun	tun/win/client/tuncli.hpp	/^    class Tun : public TunIO<ReadHandler, PacketFrom, TunWrapAsioStream<TunPersist> >$/;"	c	namespace:openvpn::TunWin
TunBuilderBase	tun/builder/base.hpp	/^  class TunBuilderBase$/;"	c	namespace:openvpn
TunBuilderCapture	tun/builder/capture.hpp	/^  class TunBuilderCapture : public TunBuilderBase, public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
TunBuilderClient	tun/builder/client.hpp	/^  namespace TunBuilderClient {$/;"	n	namespace:openvpn
TunBuilderSetup	tun/builder/setup.hpp	/^  namespace TunBuilderSetup {$/;"	n	namespace:openvpn
TunClient	tun/client/tunbase.hpp	/^  struct TunClient : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TunClientFactory	tun/client/tunbase.hpp	/^  struct TunClientFactory : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TunClientInstanceFactory	tun/server/tunbase.hpp	/^  struct TunClientInstanceFactory : public RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TunClientInstanceRecv	tun/server/tunbase.hpp	/^  struct TunClientInstanceRecv : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TunClientInstanceSend	tun/server/tunbase.hpp	/^  struct TunClientInstanceSend : public virtual RC<thread_unsafe_refcount>$/;"	s	namespace:openvpn
TunClientParent	tun/client/tunbase.hpp	/^  struct TunClientParent$/;"	s	namespace:openvpn
TunConfig	transport/dco.hpp	/^      TunConfig()$/;"	f	struct:openvpn::DCO::TunConfig
TunConfig	transport/dco.hpp	/^    struct TunConfig$/;"	s	struct:openvpn::DCO
TunError	client/clievent.hpp	/^      TunError(std::string reason) : ReasonBase(TUN_ERROR, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::TunError
TunError	client/clievent.hpp	/^    struct TunError : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
TunIO	tun/tunio.hpp	/^    TunIO(ReadHandler read_handler_arg,$/;"	f	class:openvpn::TunIO
TunIO	tun/tunio.hpp	/^  class TunIO : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
TunIfaceCreate	client/clievent.hpp	/^      TunIfaceCreate(std::string reason) : ReasonBase(TUN_IFACE_CREATE, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::TunIfaceCreate
TunIfaceCreate	client/clievent.hpp	/^    struct TunIfaceCreate : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
TunIfaceDisabled	client/clievent.hpp	/^      TunIfaceDisabled(std::string reason) : ReasonBase(TUN_IFACE_DISABLED, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::TunIfaceDisabled
TunIfaceDisabled	client/clievent.hpp	/^    struct TunIfaceDisabled : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
TunImpl	tun/builder/client.hpp	/^      typedef Tun<Client*> TunImpl;$/;"	t	class:openvpn::TunBuilderClient::Client
TunImpl	tun/linux/client/tuncli.hpp	/^      typedef Tun<Client*> TunImpl;$/;"	t	class:openvpn::TunLinux::Client
TunImpl	tun/mac/client/tuncli.hpp	/^      typedef Tun<Client*, TunPersist> TunImpl;$/;"	t	class:openvpn::TunMac::Client
TunImpl	tun/win/client/tuncli.hpp	/^      typedef Tun<Client*, TunPersist> TunImpl;$/;"	t	class:openvpn::TunWin::Client
TunLink	server/servproto.hpp	/^    typedef Link<TunClientInstanceSend, TunClientInstanceRecv> TunLink;$/;"	t	class:openvpn::ServerProto
TunLinux	tun/linux/client/tuncli.hpp	/^  namespace TunLinux {$/;"	n	namespace:openvpn
TunLinux	tun/linux/tun.hpp	/^  namespace TunLinux {$/;"	n	namespace:openvpn
TunMac	tun/mac/client/tuncli.hpp	/^  namespace TunMac {$/;"	n	namespace:openvpn
TunMac	tun/mac/client/tunsetup.hpp	/^  namespace TunMac {$/;"	n	namespace:openvpn
TunMac	tun/mac/tunutil.hpp	/^  namespace TunMac {$/;"	n	namespace:openvpn
TunMac	tun/mac/utun.hpp	/^  namespace TunMac {$/;"	n	namespace:openvpn
TunNull	tun/client/tunnull.hpp	/^  namespace TunNull {$/;"	n	namespace:openvpn
TunPersist	tun/builder/client.hpp	/^    typedef TunPersistTemplate<ScopedFD> TunPersist;$/;"	t	namespace:openvpn::TunBuilderClient
TunPersist	tun/mac/client/tuncli.hpp	/^    typedef TunPersistTemplate<ScopedTUNStream> TunPersist;$/;"	t	namespace:openvpn::TunMac
TunPersist	tun/win/client/tuncli.hpp	/^    typedef TunPersistTemplate<ScopedTAPStream> TunPersist;$/;"	t	namespace:openvpn::TunWin
TunPersistTemplate	tun/persist/tunpersist.hpp	/^    TunPersistTemplate(const bool enable_persistence, const bool retain_obj, TunBuilderBase* tb)$/;"	f	class:openvpn::TunPersistTemplate
TunPersistTemplate	tun/persist/tunpersist.hpp	/^  class TunPersistTemplate : public TunWrapTemplate<SCOPED_OBJ>$/;"	c	namespace:openvpn
TunProp	tun/client/tunprop.hpp	/^  class TunProp {$/;"	c	namespace:openvpn
TunSetupFailed	client/clievent.hpp	/^      TunSetupFailed(std::string reason) : ReasonBase(TUN_SETUP_FAILED, std::move(reason)) {}$/;"	f	struct:openvpn::ClientEvent::TunSetupFailed
TunSetupFailed	client/clievent.hpp	/^    struct TunSetupFailed : public ReasonBase$/;"	s	namespace:openvpn::ClientEvent
TunWin	tun/win/client/setupbase.hpp	/^  namespace TunWin {$/;"	n	namespace:openvpn
TunWin	tun/win/client/tuncli.hpp	/^  namespace TunWin {$/;"	n	namespace:openvpn
TunWin	tun/win/client/tunsetup.hpp	/^  namespace TunWin {$/;"	n	namespace:openvpn
TunWin	tun/win/nrpt.hpp	/^  namespace TunWin {$/;"	n	namespace:openvpn
TunWin	tun/win/tunutil.hpp	/^  namespace TunWin {$/;"	n	namespace:openvpn
TunWin	tun/win/wfp.hpp	/^  namespace TunWin {$/;"	n	namespace:openvpn
TunWrapAsioStream	tun/persist/tunwrapasio.hpp	/^    TunWrapAsioStream(const typename TunWrap::Ptr& tun_wrap_arg)$/;"	f	class:openvpn::TunWrapAsioStream
TunWrapAsioStream	tun/persist/tunwrapasio.hpp	/^  class TunWrapAsioStream$/;"	c	namespace:openvpn
TunWrapTemplate	tun/persist/tunwrap.hpp	/^    TunWrapTemplate(const bool retain_obj)$/;"	f	class:openvpn::TunWrapTemplate
TunWrapTemplate	tun/persist/tunwrap.hpp	/^  class TunWrapTemplate : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn
Type	addr/routeinv.hpp	/^      enum Type {$/;"	g	class:openvpn::IP::RouteInverter
Type	applecrypto/cf/cf.hpp	/^    template <typename T> struct Type {};$/;"	s	namespace:openvpn::CF
Type	applecrypto/util/reachable.hpp	/^    enum Type {$/;"	g	class:openvpn::ReachabilityBase
Type	auth/authcert.hpp	/^	enum Type {$/;"	g	class:openvpn::AuthCert::Fail
Type	client/clievent.hpp	/^    enum Type {$/;"	g	namespace:openvpn::ClientEvent
Type	common/mode.hpp	/^    enum Type {$/;"	g	class:openvpn::Mode
Type	compress/compress.hpp	/^    enum Type {$/;"	g	class:openvpn::CompressContext
Type	crypto/cryptoalgs.hpp	/^    enum Type {$/;"	g	namespace:openvpn::CryptoAlgs
Type	error/error.hpp	/^    enum Type {$/;"	g	namespace:openvpn::Error
Type	http/method.hpp	/^      enum Type {$/;"	g	namespace:openvpn::HTTP::Method
Type	pki/x509track.hpp	/^    enum Type {$/;"	g	namespace:openvpn::X509Track
Type	server/servhalt.hpp	/^    enum Type {$/;"	g	namespace:openvpn::HaltRestart
Type	ssl/nscert.hpp	/^    enum Type {$/;"	g	namespace:openvpn::NSCert
Type	ssl/tlsver.hpp	/^    enum Type {$/;"	g	namespace:openvpn::TLSVersion
Type	transport/protocol.hpp	/^    enum Type {$/;"	g	class:openvpn::Protocol
Type	tun/ipv6_setting.hpp	/^    enum Type {$/;"	g	class:openvpn::IPv6Setting
Type	tun/layer.hpp	/^    enum Type {$/;"	g	class:openvpn::Layer
UCharWrap	common/base64.hpp	/^      UCharWrap(const unsigned char *data, size_t size)$/;"	f	class:openvpn::Base64::UCharWrap
UCharWrap	common/base64.hpp	/^    class UCharWrap$/;"	c	class:openvpn::Base64
UDP	ip/ip.hpp	/^      UDP = 17, \/* UDP protocol *\/$/;"	e	enum:openvpn::IPHeader::__anon51
UDP	transport/protocol.hpp	/^      UDP=UDPv4,$/;"	e	enum:openvpn::Protocol::Type
UDPHeader	ip/udp.hpp	/^  struct UDPHeader {$/;"	s	namespace:openvpn
UDPTransport	transport/client/udpcli.hpp	/^  namespace UDPTransport {$/;"	n	namespace:openvpn
UDPTransport	transport/udplink.hpp	/^  namespace UDPTransport {$/;"	n	namespace:openvpn
UDP_CONNECT_ERROR	error/error.hpp	/^      UDP_CONNECT_ERROR,   \/\/ client error on UDP connect$/;"	e	enum:openvpn::Error::Type
UDP_MODE	crypto/packet_id.hpp	/^      UDP_MODE = 0,$/;"	e	enum:openvpn::PacketIDReceiveType::__anon40
UDPv4	transport/protocol.hpp	/^      UDPv4,$/;"	e	enum:openvpn::Protocol::Type
UDPv6	transport/protocol.hpp	/^      UDPv6,$/;"	e	enum:openvpn::Protocol::Type
UMask	common/umask.hpp	/^    UMask(mode_t new_umask)$/;"	f	class:openvpn::UMask
UMask	common/umask.hpp	/^  class UMask$/;"	c	namespace:openvpn
UMaskPrivate	common/umask.hpp	/^    UMaskPrivate()$/;"	f	struct:openvpn::UMaskPrivate
UMaskPrivate	common/umask.hpp	/^  struct UMaskPrivate : public UMask$/;"	s	namespace:openvpn
UNDEF	crypto/packet_id.hpp	/^      UNDEF = 0,       \/\/ special undefined\/null id_t value$/;"	e	enum:openvpn::PacketID::__anon39
UNDEF	error/error.hpp	/^      UNDEF=SUCCESS,$/;"	e	enum:openvpn::Error::Type
UNDEF	log/logperiod.hpp	/^      UNDEF,$/;"	e	enum:openvpn::LogPeriod::Period
UNDEF	pki/x509track.hpp	/^      UNDEF=-1,$/;"	e	enum:openvpn::X509Track::Type
UNDEF	ssl/tlsver.hpp	/^      UNDEF=0,$/;"	e	enum:openvpn::TLSVersion::Type
UNI_MAX_BMP	common/unicode-impl.hpp	/^    const UTF32 UNI_MAX_BMP = (UTF32)0x0000FFFF;$/;"	m	namespace:openvpn::Unicode
UNI_MAX_LEGAL_UTF32	common/unicode-impl.hpp	/^    const UTF32 UNI_MAX_LEGAL_UTF32 = (UTF32)0x0010FFFF;$/;"	m	namespace:openvpn::Unicode
UNI_MAX_UTF16	common/unicode-impl.hpp	/^    const UTF32 UNI_MAX_UTF16 = (UTF32)0x0010FFFF;$/;"	m	namespace:openvpn::Unicode
UNI_MAX_UTF32	common/unicode-impl.hpp	/^    const UTF32 UNI_MAX_UTF32 = (UTF32)0x7FFFFFFF;$/;"	m	namespace:openvpn::Unicode
UNI_REPLACEMENT_CHAR	common/unicode-impl.hpp	/^    const UTF32 UNI_REPLACEMENT_CHAR = (UTF32)0x0000FFFD;$/;"	m	namespace:openvpn::Unicode
UNI_SUR_HIGH_END	common/unicode-impl.hpp	/^    const UTF32 UNI_SUR_HIGH_END    = (UTF32)0xDBFF;$/;"	m	namespace:openvpn::Unicode
UNI_SUR_HIGH_START	common/unicode-impl.hpp	/^    const UTF32 UNI_SUR_HIGH_START  = (UTF32)0xD800;$/;"	m	namespace:openvpn::Unicode
UNI_SUR_LOW_END	common/unicode-impl.hpp	/^    const UTF32 UNI_SUR_LOW_END     = (UTF32)0xDFFF;$/;"	m	namespace:openvpn::Unicode
UNI_SUR_LOW_START	common/unicode-impl.hpp	/^    const UTF32 UNI_SUR_LOW_START   = (UTF32)0xDC00;$/;"	m	namespace:openvpn::Unicode
UNSIGNALED	common/pthreadcond.hpp	/^      UNSIGNALED=0,  \/\/ initial state$/;"	e	enum:openvpn::PThreadBarrier::State
UNSPEC	addr/ip.hpp	/^      enum Version { UNSPEC, V4, V6 };$/;"	e	enum:openvpn::IP::Addr::Version
URL	http/urlencode.hpp	/^  namespace URL {$/;"	n	namespace:openvpn
URL	http/urlparm.hpp	/^  namespace URL {$/;"	n	namespace:openvpn
URL	http/urlparse.hpp	/^  namespace URL {$/;"	n	namespace:openvpn
USERNAME_REQUIRED	common/userpass.hpp	/^      USERNAME_REQUIRED = (1<<2),   \/\/ username must be present$/;"	e	enum:openvpn::UserPass::Flags
UTF16	common/unicode-impl.hpp	/^    typedef unsigned short UTF16; \/* at least 16 bits *\/$/;"	t	namespace:openvpn::Unicode
UTF16	win/unicode.hpp	/^    typedef std::unique_ptr<wchar_t[]> UTF16;$/;"	t	namespace:openvpn::Win
UTF32	common/unicode-impl.hpp	/^    typedef unsigned int UTF32; \/* at least 32 bits *\/$/;"	t	namespace:openvpn::Unicode
UTF8	common/unicode-impl.hpp	/^    typedef unsigned char UTF8; \/* typically 8 bits *\/$/;"	t	namespace:openvpn::Unicode
UTF8Iterator	common/unicode.hpp	/^      UTF8Iterator(const std::string& str_arg)$/;"	f	class:openvpn::Unicode::UTF8Iterator
UTF8Iterator	common/unicode.hpp	/^    class UTF8Iterator$/;"	c	namespace:openvpn::Unicode
UTF8_BAD	common/unicode.hpp	/^      UTF8_BAD,    \/\/ failed, string is not legal UTF8$/;"	e	enum:openvpn::Unicode::__anon28
UTF8_FILTER	common/unicode.hpp	/^      UTF8_FILTER=(1<<30),$/;"	e	enum:openvpn::Unicode::__anon29
UTF8_GOOD	common/unicode.hpp	/^      UTF8_GOOD=0, \/\/ succeeded, result in index$/;"	e	enum:openvpn::Unicode::__anon28
UTF8_NO_CTRL	common/unicode.hpp	/^      UTF8_NO_CTRL  = (1<<30), \/\/ no control chars allowed$/;"	e	enum:openvpn::Unicode::__anon27
UTF8_NO_SPACE	common/unicode.hpp	/^      UTF8_NO_SPACE = (1<<31), \/\/ no space chars allowed$/;"	e	enum:openvpn::Unicode::__anon27
UTF8_PASS_FMT	common/unicode.hpp	/^      UTF8_PASS_FMT=(1<<31),$/;"	e	enum:openvpn::Unicode::__anon29
UTF8_RANGE	common/unicode.hpp	/^      UTF8_RANGE,  \/\/ failed, index is beyond end of string$/;"	e	enum:openvpn::Unicode::__anon28
UTun	tun/mac/utun.hpp	/^    namespace UTun {$/;"	n	namespace:openvpn::TunMac
Unauthorized	http/status.hpp	/^	Unauthorized=401,$/;"	e	enum:openvpn::HTTP::Status::__anon45
Unicode	common/unicode-impl.hpp	/^  namespace Unicode {$/;"	n	namespace:openvpn
Unicode	common/unicode.hpp	/^  namespace Unicode {$/;"	n	namespace:openvpn
Unix	common/asiopolysock.hpp	/^      Unix(asio::io_context& io_context,$/;"	f	struct:openvpn::AsioPolySock::Unix
Unix	common/asiopolysock.hpp	/^    struct Unix : public Base$/;"	s	namespace:openvpn::AsioPolySock
UnixDGram	transport/protocol.hpp	/^      UnixDGram,    \/\/ unix domain socket (datagram)$/;"	e	enum:openvpn::Protocol::Type
UnixStream	transport/protocol.hpp	/^      UnixStream,   \/\/ unix domain socket (stream)$/;"	e	enum:openvpn::Protocol::Type
UseCount	common/usecount.hpp	/^    UseCount(int& count)$/;"	f	class:openvpn::UseCount
UseCount	common/usecount.hpp	/^  class UseCount$/;"	c	namespace:openvpn
UseDNS	tun/win/client/tunsetup.hpp	/^	UseDNS() {}$/;"	f	class:openvpn::TunWin::Setup::UseDNS
UseDNS	tun/win/client/tunsetup.hpp	/^	UseDNS(const TunBuilderCapture& pull)$/;"	f	class:openvpn::TunWin::Setup::UseDNS
UseDNS	tun/win/client/tunsetup.hpp	/^      class UseDNS$/;"	c	class:openvpn::TunWin::Setup
UserPass	common/userpass.hpp	/^  namespace UserPass {$/;"	n	namespace:openvpn
Util	http/parseutil.hpp	/^    namespace Util {$/;"	n	namespace:openvpn::HTTP
Util	tun/mac/tunutil.hpp	/^    namespace Util {$/;"	n	namespace:openvpn::TunMac
Util	tun/win/tunutil.hpp	/^    namespace Util {$/;"	n	namespace:openvpn::TunWin
V1_0	ssl/tlsver.hpp	/^      V1_0,$/;"	e	enum:openvpn::TLSVersion::Type
V1_1	ssl/tlsver.hpp	/^      V1_1,$/;"	e	enum:openvpn::TLSVersion::Type
V1_2	ssl/tlsver.hpp	/^      V1_2$/;"	e	enum:openvpn::TLSVersion::Type
V4	addr/ip.hpp	/^      enum Version { UNSPEC, V4, V6 };$/;"	e	enum:openvpn::IP::Addr::Version
V4_MASK	addr/ip.hpp	/^      enum { V4_MASK=(1<<0), V6_MASK=(1<<1) };$/;"	e	enum:openvpn::IP::Addr::__anon1
V4_SIZE	addr/ip.hpp	/^	V4_SIZE = IPv4::Addr::SIZE,$/;"	e	enum:openvpn::IP::Addr::VersionSize
V6	addr/ip.hpp	/^      enum Version { UNSPEC, V4, V6 };$/;"	e	enum:openvpn::IP::Addr::Version
V6_MASK	addr/ip.hpp	/^      enum { V4_MASK=(1<<0), V6_MASK=(1<<1) };$/;"	e	enum:openvpn::IP::Addr::__anon1
V6_SIZE	addr/ip.hpp	/^	V6_SIZE = IPv6::Addr::SIZE,$/;"	e	enum:openvpn::IP::Addr::VersionSize
VPNServerNetblock	server/vpnservnetblock.hpp	/^    VPNServerNetblock(const OptionList& opt,$/;"	f	class:openvpn::VPNServerNetblock
VPNServerNetblock	server/vpnservnetblock.hpp	/^  class VPNServerNetblock$/;"	c	namespace:openvpn
VPNServerPool	server/vpnservpool.hpp	/^  namespace VPNServerPool {$/;"	n	namespace:openvpn
Variant	tun/mac/macgw.hpp	/^      Variant() {}$/;"	f	struct:openvpn::MacGWInfo::Variant
Variant	tun/mac/macgw.hpp	/^      Variant(const IP::Addr::Version v, const CF::DynamicStore& dstore)$/;"	f	struct:openvpn::MacGWInfo::Variant
Variant	tun/mac/macgw.hpp	/^    struct Variant$/;"	s	struct:openvpn::MacGWInfo
Version	addr/ip.hpp	/^      enum Version { UNSPEC, V4, V6 };$/;"	g	class:openvpn::IP::Addr
Version	apple/macver.hpp	/^      Version()$/;"	f	class:openvpn::Mac::Version
Version	apple/macver.hpp	/^    class Version : public AppleVersion$/;"	c	namespace:openvpn::Mac
VersionMask	addr/ip.hpp	/^      typedef unsigned int VersionMask;$/;"	t	class:openvpn::IP::Addr
VersionSize	addr/ip.hpp	/^      enum VersionSize {$/;"	g	class:openvpn::IP::Addr
WAIT	client/clievent.hpp	/^      WAIT,$/;"	e	enum:openvpn::ClientEvent::Type
WAIT_PROXY	client/clievent.hpp	/^      WAIT_PROXY,$/;"	e	enum:openvpn::ClientEvent::Type
WARN_UNSUPPORTED	client/remotelist.hpp	/^      WARN_UNSUPPORTED=1<<0,$/;"	e	enum:openvpn::RemoteList::__anon17
WFP	tun/win/wfp.hpp	/^    class WFP : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::TunWin
WFPContext	tun/win/wfp.hpp	/^    class WFPContext : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::TunWin
WFPEngine	tun/win/wfp.hpp	/^	WFPEngine()$/;"	f	class:openvpn::TunWin::WFP::WFPEngine
WFPEngine	tun/win/wfp.hpp	/^      class WFPEngine$/;"	c	class:openvpn::TunWin::WFP
WINSServer	tun/builder/capture.hpp	/^    class WINSServer$/;"	c	class:openvpn::TunBuilderCapture
WPtr	common/rc.hpp	/^    typedef RCWeakPtr<RCWeak> WPtr;$/;"	t
WPtr	common/runcontext.hpp	/^    typedef RCWeakPtr<ServerThreadType> WPtr;$/;"	t	struct:openvpn::ServerThreadType
WRITE_ACK_STANDALONE	frame/frame.hpp	/^      WRITE_ACK_STANDALONE,$/;"	e	enum:openvpn::Frame::__anon44
WRITE_DC_MSG	frame/frame.hpp	/^      WRITE_DC_MSG,$/;"	e	enum:openvpn::Frame::__anon44
WRITE_HTTP	frame/frame.hpp	/^      WRITE_HTTP,$/;"	e	enum:openvpn::Frame::__anon44
WRITE_SSL_CLEARTEXT	frame/frame.hpp	/^      WRITE_SSL_CLEARTEXT,$/;"	e	enum:openvpn::Frame::__anon44
WRITE_SSL_INIT	frame/frame.hpp	/^      WRITE_SSL_INIT,$/;"	e	enum:openvpn::Frame::__anon44
Wait	client/clievent.hpp	/^      Wait() : Base(WAIT) {}$/;"	f	struct:openvpn::ClientEvent::Wait
Wait	client/clievent.hpp	/^    struct Wait : public Base$/;"	s	namespace:openvpn::ClientEvent
WaitProxy	client/clievent.hpp	/^      WaitProxy() : Base(WAIT_PROXY) {}$/;"	f	struct:openvpn::ClientEvent::WaitProxy
WaitProxy	client/clievent.hpp	/^    struct WaitProxy : public Base$/;"	s	namespace:openvpn::ClientEvent
WebException	http/webexcept.hpp	/^      WebException(const int status)$/;"	f	class:openvpn::HTTP::WebException
WebException	http/webexcept.hpp	/^      WebException(const int status, const std::string& error)$/;"	f	class:openvpn::HTTP::WebException
WebException	http/webexcept.hpp	/^    class WebException : public std::exception$/;"	c	namespace:openvpn::HTTP
WiFi	applecrypto/util/reachable.hpp	/^      WiFi,$/;"	e	enum:openvpn::ReachabilityBase::Type
Win	win/call.hpp	/^  namespace Win {$/;"	n	namespace:openvpn
Win	win/console.hpp	/^  namespace Win {$/;"	n	namespace:openvpn
Win	win/handle.hpp	/^  namespace Win {$/;"	n	namespace:openvpn
Win	win/modname.hpp	/^  namespace Win {$/;"	n	namespace:openvpn
Win	win/reg.hpp	/^  namespace Win {$/;"	n	namespace:openvpn
Win	win/scoped_handle.hpp	/^  namespace Win {$/;"	n	namespace:openvpn
Win	win/unicode.hpp	/^  namespace Win {$/;"	n	namespace:openvpn
Win	win/winerr.hpp	/^  namespace Win {$/;"	n	namespace:openvpn
WinCmd	win/cmd.hpp	/^    WinCmd(const std::string& command)$/;"	f	class:openvpn::WinCmd
WinCmd	win/cmd.hpp	/^  class WinCmd : public Action$/;"	c	namespace:openvpn
WinSleep	win/sleep.hpp	/^    WinSleep(DWORD dwMilliseconds_arg)$/;"	f	class:openvpn::WinSleep
WinSleep	win/sleep.hpp	/^  class WinSleep : public Action$/;"	c	namespace:openvpn
Wrap	applecrypto/cf/cf.hpp	/^      Wrap() : obj_(nullptr) {}$/;"	f	class:openvpn::CF::Wrap
Wrap	applecrypto/cf/cf.hpp	/^      Wrap(const Wrap& other)$/;"	f	class:openvpn::CF::Wrap
Wrap	applecrypto/cf/cf.hpp	/^      explicit Wrap(T obj, const Own own=OWN)$/;"	f	class:openvpn::CF::Wrap
Wrap	applecrypto/cf/cf.hpp	/^    class Wrap$/;"	c	namespace:openvpn::CF
Wrapper	log/logsimple.hpp	/^      struct Wrapper {};$/;"	s	struct:openvpn::Log::Context
Wrapper	log/logthread.hpp	/^      struct Wrapper$/;"	s	struct:openvpn::Log::Context
X509	openssl/pki/x509.hpp	/^      X509() {}$/;"	f	class:openvpn::OpenSSLPKI::X509
X509	openssl/pki/x509.hpp	/^      X509(const X509& other)$/;"	f	class:openvpn::OpenSSLPKI::X509
X509	openssl/pki/x509.hpp	/^      X509(const std::string& cert_txt, const std::string& title)$/;"	f	class:openvpn::OpenSSLPKI::X509
X509	openssl/pki/x509.hpp	/^    class X509 : public X509Base, public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::OpenSSLPKI
X509Base	openssl/pki/x509.hpp	/^      X509Base() : x509_(nullptr) {}$/;"	f	class:openvpn::OpenSSLPKI::X509Base
X509Base	openssl/pki/x509.hpp	/^      explicit X509Base(::X509 *x509) : x509_(x509) {}$/;"	f	class:openvpn::OpenSSLPKI::X509Base
X509Base	openssl/pki/x509.hpp	/^    class X509Base$/;"	c	namespace:openvpn::OpenSSLPKI
X509CRL	polarssl/pki/x509crl.hpp	/^      X509CRL() : chain(nullptr) {}$/;"	f	class:openvpn::PolarSSLPKI::X509CRL
X509CRL	polarssl/pki/x509crl.hpp	/^      X509CRL(const std::string& crl_txt)$/;"	f	class:openvpn::PolarSSLPKI::X509CRL
X509CRL	polarssl/pki/x509crl.hpp	/^    class X509CRL : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::PolarSSLPKI
X509Cert	polarssl/pki/x509cert.hpp	/^      X509Cert() : chain(nullptr) {}$/;"	f	class:openvpn::PolarSSLPKI::X509Cert
X509Cert	polarssl/pki/x509cert.hpp	/^      X509Cert(const std::string& cert_txt, const std::string& title, const bool strict)$/;"	f	class:openvpn::PolarSSLPKI::X509Cert
X509Cert	polarssl/pki/x509cert.hpp	/^    class X509Cert : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::PolarSSLPKI
X509List	openssl/pki/x509.hpp	/^    class X509List : public std::vector<X509Ptr>$/;"	c	namespace:openvpn::OpenSSLPKI
X509Ptr	openssl/pki/x509.hpp	/^    typedef RCPtr<X509> X509Ptr;$/;"	t	namespace:openvpn::OpenSSLPKI
X509Store	openssl/pki/x509store.hpp	/^      X509Store() : x509_store_(nullptr) {}$/;"	f	class:openvpn::OpenSSLPKI::X509Store
X509Store	openssl/pki/x509store.hpp	/^      explicit X509Store(const CertCRLList& cc)$/;"	f	class:openvpn::OpenSSLPKI::X509Store
X509Store	openssl/pki/x509store.hpp	/^    class X509Store : public RC<thread_unsafe_refcount>$/;"	c	namespace:openvpn::OpenSSLPKI
X509Track	pki/x509track.hpp	/^  namespace X509Track {$/;"	n	namespace:openvpn
YES	tun/ipv6_setting.hpp	/^      YES,$/;"	e	enum:openvpn::IPv6Setting::Type
ZLib	buffer/zlib.hpp	/^  namespace ZLib {$/;"	n	namespace:openvpn
ZStreamBase	buffer/zlib.hpp	/^      ZStreamBase()  { std::memset(&s, 0, sizeof(s)); }$/;"	f	class:openvpn::ZLib::ZStreamBase
ZStreamBase	buffer/zlib.hpp	/^    class ZStreamBase \/\/ used internally by compress_gzip\/decompress_gzip$/;"	c	namespace:openvpn::ZLib
_NET_ROUTE_H_	netconf/ios/net-route.h	/^#define	_NET_ROUTE_H_$/;"	d
ack	reliable/relack.hpp	/^    static size_t ack(REL_SEND& rel_send, Buffer& buf, const bool live)$/;"	f	class:openvpn::ReliableAck
ack	reliable/relsend.hpp	/^    void ack(const id_t id) { window_.rm_by_id(id); }$/;"	f	class:openvpn::ReliableSendTemplate
ack_send_buf	ssl/protostack.hpp	/^    PACKET ack_send_buf;  \/\/ only used for standalone ACKs to be sent to peer$/;"	m	class:openvpn::ProtoStackBase
ack_skip	reliable/relack.hpp	/^    static size_t ack_skip(Buffer& buf)$/;"	f	class:openvpn::ReliableAck
acquire	server/vpnservpool.hpp	/^      unsigned int acquire(IP46& addr_pair, const bool request_ipv6)$/;"	f	class:openvpn::VPNServerPool::Pool
acquire_addr	addr/pool.hpp	/^      bool acquire_addr(ADDR& dest)$/;"	f	class:openvpn::IP::PoolType
acquire_specific_addr	addr/pool.hpp	/^      bool acquire_specific_addr(const ADDR& addr)$/;"	f	class:openvpn::IP::PoolType
action_timer	apple/maclife.hpp	/^    CF::Timer action_timer;$/;"	m	class:openvpn::MacLifeCycle
action_timer_callback	apple/maclife.hpp	/^    void action_timer_callback(CFRunLoopTimerRef timer)$/;"	f	class:openvpn::MacLifeCycle
action_timer_callback_static	apple/maclife.hpp	/^    static void action_timer_callback_static(CFRunLoopTimerRef timer, void *info)$/;"	f	class:openvpn::MacLifeCycle
actions	common/actionthread.hpp	/^    ActionList::Ptr actions;       \/\/ actions to execute in child thread$/;"	m	class:openvpn::ActionThread
activate	common/usergroup.hpp	/^    void activate() const$/;"	f	class:openvpn::SetUserGroup
active	client/cliproto.hpp	/^      virtual void active()$/;"	f	class:openvpn::ClientProto::Session
active	ssl/proto.hpp	/^      void active()$/;"	f	class:openvpn::ProtoContext::KeyContext
active	ssl/proto.hpp	/^    virtual void active()$/;"	f	class:openvpn::ProtoContext
active_event	ssl/proto.hpp	/^      void active_event()$/;"	f	class:openvpn::ProtoContext::KeyContext
actual_headroom	frame/frame.hpp	/^      size_t actual_headroom(const void *base) const$/;"	f	class:openvpn::Frame::Context
ad	crypto/crypto_aead.hpp	/^	const unsigned char *ad() const$/;"	f	class:openvpn::AEAD::Crypto::Nonce
ad_len	crypto/crypto_aead.hpp	/^	const size_t ad_len() const$/;"	f	class:openvpn::AEAD::Crypto::Nonce
ad_op32	crypto/crypto_aead.hpp	/^	bool ad_op32; \/\/ true if AD includes op32 opcode$/;"	m	class:openvpn::AEAD::Crypto::Nonce
adapt	tun/win/tunutil.hpp	/^	std::unique_ptr<IP_PER_ADAPTER_INFO> adapt;$/;"	m	struct:openvpn::TunWin::Util::IPPerAdapterInfo
adapter	tun/win/tunutil.hpp	/^	const IP_ADAPTER_INFO* adapter(const DWORD index) const$/;"	f	struct:openvpn::TunWin::Util::IPAdaptersInfo
adapter_config	tun/win/client/tunsetup.hpp	/^      void adapter_config(HANDLE th,$/;"	f	class:openvpn::TunWin::Setup
adapter_config_l2	tun/win/client/tunsetup.hpp	/^      void adapter_config_l2(HANDLE th,$/;"	f	class:openvpn::TunWin::Setup
adapter_domain_suffix	tun/builder/capture.hpp	/^    std::string adapter_domain_suffix;     \/\/ domain suffix on tun\/tap adapter (currently Windows only)$/;"	m	class:openvpn::TunBuilderCapture
adapter_index_to_luid	tun/win/wfp.hpp	/^      static NET_LUID adapter_index_to_luid(const NET_IFINDEX index)$/;"	f	class:openvpn::TunWin::WFP
add	addr/addrlist.hpp	/^      void add(const IP::Addr& a)$/;"	f	class:openvpn::IP::AddrList
add	addr/ipv6.hpp	/^      static void add(ipv6addr& dest, const ipv6addr& src) {$/;"	f	class:openvpn::IPv6::Addr
add	buffer/buflimit.hpp	/^    void add(const Buffer& buf)$/;"	f	class:openvpn::BufferLimit
add	client/remotelist.hpp	/^    void add(const OptionList& opt, Protocol& default_proto, std::string& default_port, ConnBlock::Ptr conn_block)$/;"	f	class:openvpn::RemoteList
add	common/action.hpp	/^    void add(Action* action)$/;"	f	class:openvpn::ActionList
add	common/action.hpp	/^    void add(const Action::Ptr& action)$/;"	f	class:openvpn::ActionList
add	common/action.hpp	/^    void add(const ActionList& other)$/;"	f	class:openvpn::ActionList
add	common/hostlist.hpp	/^      void add(const std::string& host,$/;"	f	class:openvpn::HostList::List
add	http/htmlskip.hpp	/^      Status add(unsigned char c)$/;"	f	class:openvpn::HTTP::HTMLSkip
add	options/continuation.hpp	/^    void add(const OptionList& other, OptionList::FilterBase* filt)$/;"	f	class:openvpn::OptionListContinuation
add	ssl/datalimit.hpp	/^      State add(const size_type n)$/;"	f	class:openvpn::DataLimit::Component
add	ssl/datalimit.hpp	/^    State add(const Mode mode, const size_type n)$/;"	f	class:openvpn::DataLimit
add	tun/win/client/tunsetup.hpp	/^	int add(const TunBuilderCapture::DNSServer& ds,$/;"	f	class:openvpn::TunWin::Setup::UseDNS
add_actions	tun/mac/macdns_watchdog.hpp	/^    static void add_actions(const MacDNS::Config::Ptr& dns,$/;"	f	class:openvpn::MacDNSWatchdog
add_addr	addr/pool.hpp	/^      void add_addr(const ADDR& addr)$/;"	f	class:openvpn::IP::PoolType
add_bytes	common/options.hpp	/^      void add_bytes(const size_t n)$/;"	f	class:openvpn::OptionList::Limits
add_del_reroute_gw_v4	netconf/linux/route.hpp	/^    void add_del_reroute_gw_v4(const bool add)$/;"	f	class:openvpn::RouteListLinux
add_del_route	netconf/linux/route.hpp	/^    int add_del_route(const bool add,$/;"	f	class:openvpn::RouteListLinux
add_del_route	tun/linux/client/tuncli.hpp	/^    inline void add_del_route(const std::string& addr_str,$/;"	f	namespace:openvpn::TunLinux
add_del_route	tun/mac/client/tunsetup.hpp	/^      static void add_del_route(const std::string& addr_str,$/;"	f	class:openvpn::TunMac::Setup
add_destructor	tun/persist/tunwrap.hpp	/^    void add_destructor(const DestructorBase::Ptr& destruct)$/;"	f	class:openvpn::TunWrapTemplate
add_dhcp_options	tun/client/tunprop.hpp	/^    static unsigned int add_dhcp_options(TunBuilderBase* tb, const OptionList& opt, const bool quiet)$/;"	f	class:openvpn::TunProp
add_exclude_route	tun/client/tunprop.hpp	/^    static void add_exclude_route(TunBuilderBase* tb, $/;"	f	class:openvpn::TunProp
add_fail	auth/authcert.hpp	/^	void add_fail(const size_t depth, const Type new_code, const char *reason)$/;"	f	class:openvpn::AuthCert::Fail
add_fail	auth/authcert.hpp	/^      void add_fail(const size_t depth, const Fail::Type new_code, const char *reason)$/;"	f	struct:openvpn::AuthCert
add_filter	tun/win/wfp.hpp	/^      void add_filter(const FWPM_FILTER0 *filter,$/;"	f	class:openvpn::TunWin::WFP
add_flags	client/rgopt.hpp	/^    void add_flags(const OptionList& opt, const OptionList::IndexList& idx, const bool redirect_gateway)$/;"	f	class:openvpn::RedirectGatewayFlags
add_google_dns	tun/client/tunprop.hpp	/^    static void add_google_dns(TunBuilderBase* tb)$/;"	f	class:openvpn::TunProp
add_item	common/options.hpp	/^    void add_item(const Option& opt) $/;"	f	class:openvpn::OptionList
add_label	common/exception.hpp	/^    void add_label(const std::string& label)$/;"	f	class:openvpn::Exception
add_opt	common/options.hpp	/^      void add_opt()$/;"	f	class:openvpn::OptionList::Limits
add_range	addr/pool.hpp	/^      void add_range(const RangeType<ADDR>& range)$/;"	f	class:openvpn::IP::PoolType
add_remote_bypass_routes	tun/client/tunprop.hpp	/^    static void add_remote_bypass_routes(TunBuilderBase* tb,$/;"	f	class:openvpn::TunProp
add_route	client/cliemuexr.hpp	/^    virtual void add_route(const bool add, const IP::Addr& addr, const int prefix_len)$/;"	f	class:openvpn::EmulateExcludeRouteImpl
add_route_metric_default	tun/client/tunprop.hpp	/^    static void add_route_metric_default(TunBuilderBase* tb,$/;"	f	class:openvpn::TunProp
add_routes	server/vpnservpool.hpp	/^      void add_routes(std::vector<IP::Route>& rtvec)$/;"	f	struct:openvpn::VPNServerPool::IP46
add_routes	tun/builder/capture.hpp	/^    std::vector<Route> add_routes;         \/\/ routes that should be added to tunnel$/;"	m	class:openvpn::TunBuilderCapture
add_routes	tun/client/tunprop.hpp	/^    static void add_routes(TunBuilderBase* tb,$/;"	f	class:openvpn::TunProp
add_security_buffer	proxy/ntlm.hpp	/^      static void add_security_buffer(const size_t sb_offset,$/;"	f	class:openvpn::HTTPProxy::NTLM
add_string	common/options.hpp	/^      void add_string(const std::string& str)$/;"	f	class:openvpn::OptionList::Limits
add_term	common/options.hpp	/^      void add_term()$/;"	f	class:openvpn::OptionList::Limits
add_term	common/split.hpp	/^      void add_term() {}$/;"	f	struct:openvpn::Split::NullLimit
add_thread	common/runcontext.hpp	/^    void add_thread()$/;"	f	class:openvpn::RunContext
add_trailing	common/string.hpp	/^    inline void add_trailing(std::string& str, const char c)$/;"	f	namespace:openvpn::string
add_trailing_copy	common/string.hpp	/^    inline std::string add_trailing_copy(const std::string& str, const char c)$/;"	f	namespace:openvpn::string
add_trailing_crlf	common/string.hpp	/^    inline void add_trailing_crlf(std::string& str)$/;"	f	namespace:openvpn::string
add_trailing_crlf_copy	common/string.hpp	/^    inline std::string add_trailing_crlf_copy(std::string str)$/;"	f	namespace:openvpn::string
addr	addr/addrpair.hpp	/^      Addr addr;$/;"	m	struct:openvpn::IP::AddrMaskPair
addr	addr/ipv4.hpp	/^	base_type addr; \/\/ host byte order$/;"	m	union:openvpn::IPv4::Addr::__anon4
addr	addr/range.hpp	/^	const ADDR& addr() const { return addr_; }$/;"	f	class:openvpn::IP::RangeType::Iterator
addr	addr/route.hpp	/^      ADDR addr;$/;"	m	struct:openvpn::IP::RouteType
addr	client/remotelist.hpp	/^      IP::Addr addr;$/;"	m	struct:openvpn::RemoteList::ResolvedAddr
addr	server/listenlist.hpp	/^      std::string addr;$/;"	m	struct:openvpn::Listen::Item
addr	server/peeraddr.hpp	/^    IP::Addr addr;$/;"	m	struct:openvpn::AddrPort
addr	tun/win/tunutil.hpp	/^	std::string addr;$/;"	m	class:openvpn::TunWin::Util::DefaultGateway
addr_	addr/macaddr.hpp	/^    unsigned char addr_[6];$/;"	m	class:openvpn::MACAddr
addr_	addr/range.hpp	/^	ADDR addr_;$/;"	m	class:openvpn::IP::RangeType::Iterator
address	tun/builder/capture.hpp	/^      std::string address;$/;"	m	class:openvpn::TunBuilderCapture::DNSServer
address	tun/builder/capture.hpp	/^      std::string address;$/;"	m	class:openvpn::TunBuilderCapture::RemoteAddress
address	tun/builder/capture.hpp	/^      std::string address;$/;"	m	class:openvpn::TunBuilderCapture::RouteBase
address	tun/builder/capture.hpp	/^      std::string address;$/;"	m	class:openvpn::TunBuilderCapture::WINSServer
adj_capacity_	frame/frame.hpp	/^      size_t adj_capacity_;$/;"	m	class:openvpn::Frame::Context
adj_headroom_	frame/frame.hpp	/^      size_t adj_headroom_;$/;"	m	class:openvpn::Frame::Context
advance	buffer/bufcomplete.hpp	/^    bool advance(size_t size)$/;"	f	class:openvpn::BufferComplete
advance	buffer/buffer.hpp	/^    void advance(const size_t delta)$/;"	f	class:openvpn::BufferType
advance	reliable/relrecv.hpp	/^    void advance()$/;"	f	class:openvpn::ReliableRecvTemplate
advance_string	buffer/bufcomplete.hpp	/^    bool advance_string()$/;"	f	class:openvpn::BufferComplete
advance_to_null	buffer/bufcomplete.hpp	/^    bool advance_to_null()$/;"	f	class:openvpn::BufferComplete
aes_cbc_ciphersuites	polarssl/ssl/sslctx.hpp	/^      const int aes_cbc_ciphersuites[] = \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::polarssl_ctx_private::__anon73
algs	crypto/cryptoalgs.hpp	/^    constexpr Alg algs[] = { \/\/ NOTE: MUST be indexed by CryptoAlgs::Type (CONST GLOBAL)$/;"	m	namespace:openvpn::CryptoAlgs
align_adjust_	frame/frame.hpp	/^      size_t align_adjust_;$/;"	m	class:openvpn::Frame::Context
align_adjust_hint	ssl/proto.hpp	/^    size_t align_adjust_hint() const$/;"	f	class:openvpn::ProtoContext
align_block_	frame/frame.hpp	/^      size_t align_block_;$/;"	m	class:openvpn::Frame::Context
all_ones	addr/ip.hpp	/^      bool all_ones() const$/;"	f	class:openvpn::IP::Addr
all_ones	addr/ipv4.hpp	/^      bool all_ones() const$/;"	f	class:openvpn::IPv4::Addr
all_ones	addr/ipv6.hpp	/^      bool all_ones() const$/;"	f	class:openvpn::IPv6::Addr
all_zeros	addr/ip.hpp	/^      bool all_zeros() const$/;"	f	class:openvpn::IP::Addr
all_zeros	addr/ipv4.hpp	/^      bool all_zeros() const$/;"	f	class:openvpn::IPv4::Addr
all_zeros	addr/ipv6.hpp	/^      bool all_zeros() const$/;"	f	class:openvpn::IPv6::Addr
alloc	buffer/safestr.hpp	/^    void alloc()$/;"	f	class:openvpn::SafeString
alloc	polarssl/pki/dh.hpp	/^      void alloc()$/;"	f	class:openvpn::PolarSSLPKI::DH
alloc	polarssl/pki/pkctx.hpp	/^      void alloc()$/;"	f	class:openvpn::PolarSSLPKI::PKContext
alloc	polarssl/pki/x509cert.hpp	/^      void alloc()$/;"	f	class:openvpn::PolarSSLPKI::X509Cert
alloc	polarssl/pki/x509crl.hpp	/^      void alloc()$/;"	f	class:openvpn::PolarSSLPKI::X509CRL
alloc_if_addrs	netconf/enumiface.hpp	/^      static ifaddrs* alloc_if_addrs()$/;"	f	class:openvpn::EnumIface
allocated	buffer/buffer.hpp	/^    bool allocated() const { return data_ != nullptr; }$/;"	f	class:openvpn::BufferType
allowPasswordSave	client/cliopthelper.hpp	/^    bool allowPasswordSave() const { return allowPasswordSave_; }$/;"	f	class:openvpn::ParseClientConfig
allowPasswordSave_	client/cliopthelper.hpp	/^    bool allowPasswordSave_;$/;"	m	class:openvpn::ParseClientConfig
allow_cache_password	client/clicreds.hpp	/^    bool allow_cache_password;$/;"	m	class:openvpn::ClientCreds
allow_cleartext_auth	transport/client/httpcli.hpp	/^      bool allow_cleartext_auth;$/;"	m	class:openvpn::HTTPProxyTransport::Options
alt_proxy	client/cliopt.hpp	/^      bool alt_proxy = false;$/;"	m	struct:openvpn::ClientOptions::Config
alt_proxy	client/cliopt.hpp	/^    AltProxy::Ptr alt_proxy;$/;"	m	class:openvpn::ClientOptions
and_flags	buffer/buffer.hpp	/^    void and_flags(const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
api_flags	client/ipverflags.hpp	/^    unsigned int api_flags() const$/;"	f	class:openvpn::IPVerFlags
api_flags_	client/ipverflags.hpp	/^    unsigned int api_flags_;$/;"	m	class:openvpn::IPVerFlags
app_pre_write_queue	ssl/proto.hpp	/^      std::deque<BufferPtr> app_pre_write_queue;$/;"	m	class:openvpn::ProtoContext::KeyContext
app_recv	ssl/proto.hpp	/^      void app_recv(BufferPtr&& to_app_buf) \/\/ called by ProtoStackBase$/;"	f	class:openvpn::ProtoContext::KeyContext
app_recv	ssl/proto.hpp	/^    void app_recv(const unsigned int key_id, BufferPtr&& to_app_buf)$/;"	f	class:openvpn::ProtoContext
app_recv_buf	ssl/proto.hpp	/^      BufferComposed app_recv_buf;$/;"	m	class:openvpn::ProtoContext::KeyContext
app_send	ssl/proto.hpp	/^      void app_send(BufferPtr&& bp)$/;"	f	class:openvpn::ProtoContext::KeyContext
app_send	ssl/protostack.hpp	/^    void app_send(BufferPtr&& buf)$/;"	f	class:openvpn::ProtoStackBase
app_send_validate	ssl/proto.hpp	/^      void app_send_validate(BufferPtr&& bp)$/;"	f	class:openvpn::ProtoContext::KeyContext
app_write_queue	ssl/protostack.hpp	/^    std::deque<BufferPtr> app_write_queue;$/;"	m	class:openvpn::ProtoStackBase
append	buffer/buffer.hpp	/^    void append(const BufferType& other)$/;"	f	class:openvpn::BufferType
append	buffer/safestr.hpp	/^    SafeString& append(const SafeString& str)$/;"	f	class:openvpn::SafeString
append	buffer/safestr.hpp	/^    SafeString& append(const SafeString& str, size_t subpos, size_t sublen)$/;"	f	class:openvpn::SafeString
append	buffer/safestr.hpp	/^    SafeString& append(const char* s)$/;"	f	class:openvpn::SafeString
append	common/format.hpp	/^      void append(T value)$/;"	f	class:openvpn::print_formatted_detail::Output
append	common/format.hpp	/^      void append(char *value)$/;"	f	class:openvpn::print_formatted_detail::Output
append	common/format.hpp	/^      void append(const T& value)$/;"	f	class:openvpn::print_formatted_detail::Output
append	common/format.hpp	/^      void append(const bool value)$/;"	f	class:openvpn::print_formatted_detail::Output
append	common/format.hpp	/^      void append(const char *value)$/;"	f	class:openvpn::print_formatted_detail::Output
append	common/format.hpp	/^      void append(const char c)$/;"	f	class:openvpn::print_formatted_detail::Output
append	common/format.hpp	/^      void append(const std::string& value)$/;"	f	class:openvpn::print_formatted_detail::Output
append	common/format.hpp	/^      void append(std::nullptr_t)$/;"	f	class:openvpn::print_formatted_detail::Output
append_foreign_set_ptr	ssl/peerinfo.hpp	/^      void append_foreign_set_ptr(const SET* other)$/;"	f	struct:openvpn::PeerInfo::Set
append_foreign_set_ref	ssl/peerinfo.hpp	/^      void append_foreign_set_ref(const SET& other)$/;"	f	struct:openvpn::PeerInfo::Set
apply_override	ssl/tlsver.hpp	/^    inline void apply_override(Type& tvm, const std::string& override)$/;"	f	namespace:openvpn::TLSVersion
argc	common/argv.hpp	/^    size_t argc;$/;"	m	class:openvpn::ArgvWrapper
argv	common/process.hpp	/^    Argv argv;$/;"	m	struct:openvpn::Command
arpa	addr/ip.hpp	/^      std::string arpa() const$/;"	f	class:openvpn::IP::Addr
arpa	addr/ipv4.hpp	/^      std::string arpa() const$/;"	f	class:openvpn::IPv4::Addr
arpa	addr/ipv6.hpp	/^      std::string arpa() const$/;"	f	class:openvpn::IPv6::Addr
array	applecrypto/cf/cf.hpp	/^    inline Array array(const SrcList& values)$/;"	f	namespace:openvpn::CF
array	applecrypto/cf/cf.hpp	/^    inline Array array(const void **values, CFIndex numValues)$/;"	f	namespace:openvpn::CF
arrayAppendValue	applecrypto/cf/cfhelper.hpp	/^    inline void arrayAppendValue(CFMutableArrayRef theArray, const void *value)$/;"	f	namespace:openvpn::CF
array_append_index	applecrypto/cf/cfhelper.hpp	/^    inline void array_append_index(MutableArray& array, CFIndex value)$/;"	f	namespace:openvpn::CF
array_append_int	applecrypto/cf/cfhelper.hpp	/^    inline void array_append_int(MutableArray& array, int value)$/;"	f	namespace:openvpn::CF
array_append_int32	applecrypto/cf/cfhelper.hpp	/^    inline void array_append_int32(MutableArray& array, SInt32 value)$/;"	f	namespace:openvpn::CF
array_append_long_long	applecrypto/cf/cfhelper.hpp	/^    inline void array_append_long_long(MutableArray& array, long long value)$/;"	f	namespace:openvpn::CF
array_append_str	applecrypto/cf/cfhelper.hpp	/^    inline void array_append_str(MutableArray& array, const VALUE& value)$/;"	f	namespace:openvpn::CF
array_index	applecrypto/cf/cf.hpp	/^    inline CFTypeRef array_index(const ARRAY& array, const CFIndex idx)$/;"	f	namespace:openvpn::CF
array_len	applecrypto/cf/cf.hpp	/^    inline CFIndex array_len(const ARRAY& array)$/;"	f	namespace:openvpn::CF
array_to_string	applecrypto/cf/cf.hpp	/^    inline std::string array_to_string(const ARRAY& array, const char delim=',')$/;"	f	namespace:openvpn::CF
asio_bytes	addr/ipv6.hpp	/^	asio::ip::address_v6::bytes_type asio_bytes;$/;"	m	union:openvpn::IPv6::Addr::ipv6addr
asio_work	client/cliconnect.hpp	/^    std::unique_ptr<asio::io_context::work> asio_work;$/;"	m	class:openvpn::ClientConnect
assign	openssl/pki/crl.hpp	/^      void assign(const X509_CRL *crl)$/;"	f	class:openvpn::OpenSSLPKI::CRL
assign	openssl/pki/dh.hpp	/^      void assign(const ::DH *dh)$/;"	f	class:openvpn::OpenSSLPKI::DH
assign	openssl/pki/pkey.hpp	/^      void assign(const EVP_PKEY *pkey)$/;"	f	class:openvpn::OpenSSLPKI::PKey
assign	openssl/pki/x509.hpp	/^      void assign(const ::X509 *x509)$/;"	f	class:openvpn::OpenSSLPKI::X509
asym	compress/compress.hpp	/^    bool asym() const { return asym_; }$/;"	f	class:openvpn::CompressContext
asym	compress/lz4.hpp	/^    const bool asym;$/;"	m	class:openvpn::CompressLZ4
asym	compress/lz4.hpp	/^    const bool asym;$/;"	m	class:openvpn::CompressLZ4v2
asym	compress/lzo.hpp	/^    const bool asym;$/;"	m	class:openvpn::CompressLZO
asym	compress/snappy.hpp	/^    const bool asym;$/;"	m	class:openvpn::CompressSnappy
asym_	compress/compress.hpp	/^    bool asym_;$/;"	m	class:openvpn::CompressContext
async_read_some	tun/persist/tunwrapasio.hpp	/^      async_read_some(const MutableBufferSequence& buffers,$/;"	f	class:openvpn::TunWrapAsioStream
async_sleep_milliseconds	common/asyncsleep.hpp	/^  inline bool async_sleep_milliseconds(int milliseconds, Stop* async_stop)$/;"	f	namespace:openvpn
async_stop	common/runcontext.hpp	/^    virtual Stop* async_stop()$/;"	f	class:openvpn::RunContext
async_stop_	common/runcontext.hpp	/^    Stop* async_stop_ = nullptr;$/;"	m	class:openvpn::RunContext
at_least_http_1_1	http/request.hpp	/^      bool at_least_http_1_1() const$/;"	f	struct:openvpn::HTTP::Request
auth_cert	applecrypto/ssl/sslctx.hpp	/^      virtual const AuthCert::Ptr& auth_cert() const$/;"	f	class:openvpn::AppleSSLContext::SSL
auth_cert	openssl/ssl/sslctx.hpp	/^      virtual const AuthCert::Ptr& auth_cert() const$/;"	f	class:openvpn::OpenSSLContext::SSL
auth_cert	polarssl/ssl/sslctx.hpp	/^      virtual const AuthCert::Ptr& auth_cert() const$/;"	f	class:openvpn::PolarSSLContext::SSL
auth_cert	ssl/protostack.hpp	/^    const AuthCert::Ptr& auth_cert() const$/;"	f	class:openvpn::ProtoStackBase
auth_failed	server/servproto.hpp	/^      virtual void auth_failed(const std::string& reason,$/;"	f	class:openvpn::ServerProto::Session
auth_info	client/clicreds.hpp	/^    std::string auth_info() const$/;"	f	class:openvpn::ClientCreds
auth_prefix	ssl/proto.hpp	/^      const unsigned char auth_prefix[] = { 0, 0, 0, 0, 2 }; \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::proto_context_private::__anon77
authcert	openssl/ssl/sslctx.hpp	/^      AuthCert::Ptr authcert;$/;"	m	class:openvpn::OpenSSLContext::SSL
authcert	polarssl/ssl/sslctx.hpp	/^      AuthCert::Ptr authcert;$/;"	m	class:openvpn::PolarSSLContext::SSL
autologin	client/cliopt.hpp	/^    bool autologin;$/;"	m	class:openvpn::ClientOptions
autologin	client/cliopthelper.hpp	/^    bool autologin() const { return autologin_; }$/;"	f	class:openvpn::ParseClientConfig
autologin_	client/cliopthelper.hpp	/^    bool autologin_;$/;"	m	class:openvpn::ParseClientConfig
autologin_sessions	client/cliopt.hpp	/^      bool autologin_sessions = false;$/;"	m	struct:openvpn::ClientOptions::Config
autologin_sessions	client/cliopt.hpp	/^    bool autologin_sessions;$/;"	m	class:openvpn::ClientOptions
autologin_sessions	client/cliproto.hpp	/^	bool autologin_sessions = false;$/;"	m	struct:openvpn::ClientProto::Session::Config
autologin_sessions	client/cliproto.hpp	/^      bool autologin_sessions;$/;"	m	class:openvpn::ClientProto::Session
available	common/lex.hpp	/^    bool available() const { return ch != -1; }$/;"	f	class:openvpn::NullLex
available	common/lex.hpp	/^    bool available() const { return ch != -1; }$/;"	f	class:openvpn::StandardLex
available	common/options.hpp	/^      bool available() const { return ch != -1; }$/;"	f	class:openvpn::OptionList::LexComment
available	win/console.hpp	/^	bool available()$/;"	f	class:openvpn::Win::Console::Input
back	buffer/buffer.hpp	/^    T back()$/;"	f	class:openvpn::BufferType
backslash	common/lex.hpp	/^    bool backslash;$/;"	m	class:openvpn::StandardLex
backslash	common/options.hpp	/^      bool backslash;$/;"	m	class:openvpn::OptionList::LexComment
backup_orig	tun/mac/macdns.hpp	/^      void backup_orig(const std::string& key, const bool wipe_orig=true)$/;"	f	class:openvpn::MacDNS::DSDict
base	crypto/packet_id.hpp	/^    unsigned int base;              \/\/ bit position of deque base in history$/;"	m	class:openvpn::PacketIDReceiveType
base64	common/base64.hpp	/^  OPENVPN_EXTERN const Base64* base64; \/\/ GLOBAL$/;"	m	namespace:openvpn
base64_init_static	common/base64.hpp	/^  inline void base64_init_static()$/;"	f	namespace:openvpn
base64_uninit_static	common/base64.hpp	/^  inline void base64_uninit_static()$/;"	f	namespace:openvpn
base_	time/time.hpp	/^    static base_type base_;$/;"	m	class:openvpn::TimeType
base_	time/time.hpp	/^  template <typename T> typename TimeType<T>::base_type TimeType<T>::base_;$/;"	m	class:openvpn::TimeType
base_type	addr/ipv4.hpp	/^      typedef std::uint32_t base_type;$/;"	t	class:openvpn::IPv4::Addr
base_type	common/scoped_asio_stream.hpp	/^    typedef STREAM* base_type;$/;"	t	class:openvpn::ScopedAsioStream
base_type	common/scoped_fd.hpp	/^    typedef int base_type;$/;"	t	class:openvpn::ScopedFD
base_type	time/time.hpp	/^    typedef ::time_t base_type;$/;"	t	class:openvpn::TimeType
base_type	win/scoped_handle.hpp	/^      typedef HANDLE base_type;$/;"	t	class:openvpn::Win::ScopedHANDLE
basename	common/path.hpp	/^    inline std::string basename(const std::string& path)$/;"	f	namespace:openvpn::path
basename	options/merge.hpp	/^    const std::string& basename() const { return basename_; }$/;"	f	class:openvpn::ProfileMerge
basename_	options/merge.hpp	/^    std::string basename_;$/;"	m	class:openvpn::ProfileMerge
basic_auth	transport/client/httpcli.hpp	/^      void basic_auth(HTTPProxy::ProxyAuthenticate& pa)$/;"	f	class:openvpn::HTTPProxyTransport::Client
bc	buffer/bufcomposed.hpp	/^      BufferComposed& bc;$/;"	m	class:openvpn::BufferComposed::Complete
bcast	server/vpnservnetblock.hpp	/^      IP::Addr bcast;$/;"	m	struct:openvpn::VPNServerNetblock::Netblock
become_primary	ssl/proto.hpp	/^      Time::Duration become_primary;   \/\/ KeyContext (that is ACTIVE) becomes primary at this time$/;"	m	class:openvpn::ProtoContext::Config
become_primary_time	ssl/proto.hpp	/^      Time become_primary_time()$/;"	f	class:openvpn::ProtoContext::KeyContext
begin	buffer/asiobuf.hpp	/^    const asio::const_buffer* begin() const { return buf; }$/;"	f	class:openvpn::AsioConstBufferSeq2
bin_prefix	common/binprefix.hpp	/^  inline T bin_prefix(const unsigned char *data)$/;"	f	namespace:openvpn
bin_prefix	common/binprefix.hpp	/^  inline T bin_prefix(const unsigned char *data, const size_t len)$/;"	f	namespace:openvpn
bin_prefix_floor	common/binprefix.hpp	/^  inline T bin_prefix_floor(const unsigned char *data, const size_t len, const T floor)$/;"	f	namespace:openvpn
binary_ms	time/time.hpp	/^      static Duration binary_ms(const T v) { return Duration(v); }$/;"	f	class:openvpn::TimeType::Duration
bind_local	common/asioboundsock.hpp	/^      void bind_local(const IP::Addr& addr)$/;"	f	struct:openvpn::AsioBoundSocket::Socket
bind_local_addr	common/asioboundsock.hpp	/^	IP::Addr bind_local_addr;$/;"	m	struct:openvpn::AsioBoundSocket::SocketService::implementation_type
bind_to_core	linux/core.hpp	/^  inline int bind_to_core(const int core_id)$/;"	f	namespace:openvpn
bio_memq_internal	openssl/bio/bio_memq_dgram.hpp	/^    namespace bio_memq_internal {$/;"	n	namespace:openvpn::bmq_dgram
bio_memq_internal	openssl/bio/bio_memq_stream.hpp	/^    namespace bio_memq_internal {$/;"	n	namespace:openvpn::bmq_stream
bit	addr/ipv6.hpp	/^      bool bit(unsigned int pos) const$/;"	f	class:openvpn::IPv6::Addr
block	tun/win/wfp.hpp	/^      void block(const std::wstring& openvpn_app_path,$/;"	f	class:openvpn::TunWin::WFPContext
block_dns	tun/win/wfp.hpp	/^      void block_dns(const std::wstring& openvpn_app_path,$/;"	f	class:openvpn::TunWin::WFP
block_ipv6	tun/builder/capture.hpp	/^    bool block_ipv6 = false;               \/\/ block IPv6 traffic while VPN is active$/;"	m	class:openvpn::TunBuilderCapture
block_size	applecrypto/crypto/cipher.hpp	/^      size_t block_size() const$/;"	f	class:openvpn::AppleCrypto::CipherContext
block_size	crypto/cryptoalgs.hpp	/^      size_t block_size() const { return block_size_; }  \/\/ cipher only$/;"	f	class:openvpn::CryptoAlgs::Alg
block_size	crypto/cryptoalgs.hpp	/^    inline size_t block_size(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
block_size	openssl/crypto/cipher.hpp	/^      size_t block_size() const$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
block_size	polarssl/crypto/cipher.hpp	/^      size_t block_size() const$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
block_size_	crypto/cryptoalgs.hpp	/^      unsigned int block_size_;$/;"	m	class:openvpn::CryptoAlgs::Alg
blocked_	common/signal.hpp	/^    bool blocked_;$/;"	m	class:openvpn::SignalBlocker
bmq_dgram	openssl/bio/bio_memq_dgram.hpp	/^  namespace bmq_dgram {$/;"	n	namespace:openvpn
bmq_stream	openssl/bio/bio_memq_stream.hpp	/^  namespace bmq_stream {$/;"	n	namespace:openvpn
buf	buffer/asiobuf.hpp	/^    const asio::const_buffer buf[2];$/;"	m	class:openvpn::AsioConstBufferSeq2
buf	buffer/bufcomplete.hpp	/^    Buffer buf;$/;"	m	class:openvpn::BufferComplete
buf	buffer/bufstream.hpp	/^    Buffer& buf;$/;"	m	class:openvpn::BufferStream
buf	common/redir.hpp	/^      BufferAllocated buf;$/;"	m	class:openvpn::RedirectPipe::SD_IN
buf	common/redir.hpp	/^      BufferAllocated buf;$/;"	m	class:openvpn::RedirectPipe::SD_OUT
buf	ssl/proto.hpp	/^      BufferPtr buf;$/;"	m	class:openvpn::ProtoContext::Packet
buf	transport/tcplink.hpp	/^      BufferAllocated buf;$/;"	m	struct:openvpn::TCPTransport::PacketFrom
buf	transport/udplink.hpp	/^      BufferAllocated buf;$/;"	m	struct:openvpn::UDPTransport::PacketFrom
buf	tun/builder/client.hpp	/^      BufferAllocated buf;$/;"	m	struct:openvpn::TunBuilderClient::PacketFrom
buf	tun/linux/tun.hpp	/^      BufferAllocated buf;$/;"	m	struct:openvpn::TunLinux::PacketFrom
buf	tun/mac/client/tuncli.hpp	/^      BufferAllocated buf;$/;"	m	struct:openvpn::TunMac::PacketFrom
buf	tun/win/client/tuncli.hpp	/^      BufferAllocated buf;$/;"	m	struct:openvpn::TunWin::PacketFrom
buf_alloc_from_string	buffer/bufstr.hpp	/^  inline BufferAllocated buf_alloc_from_string(const char *str)$/;"	f	namespace:openvpn
buf_alloc_from_string	buffer/bufstr.hpp	/^  inline BufferAllocated buf_alloc_from_string(const std::string& str)$/;"	f	namespace:openvpn
buf_append_string	buffer/bufstr.hpp	/^  inline void buf_append_string(Buffer& buf, const char *str)$/;"	f	namespace:openvpn
buf_append_string	buffer/bufstr.hpp	/^  inline void buf_append_string(Buffer& buf, const std::string& str)$/;"	f	namespace:openvpn
buf_clamp_read	buffer/bufclamp.hpp	/^  inline size_t buf_clamp_read(const size_t size)$/;"	f	namespace:openvpn
buf_clamp_write	buffer/bufclamp.hpp	/^  inline size_t buf_clamp_write(const size_t size)$/;"	f	namespace:openvpn
buf_from_string	buffer/bufstr.hpp	/^  inline BufferPtr buf_from_string(const char *str)$/;"	f	namespace:openvpn
buf_from_string	buffer/bufstr.hpp	/^  inline BufferPtr buf_from_string(const std::string& str)$/;"	f	namespace:openvpn
buf_to_string	buffer/bufstr.hpp	/^  inline std::string buf_to_string(const Buffer& buf)$/;"	f	namespace:openvpn
buf_to_string	buffer/bufstr.hpp	/^  inline std::string buf_to_string(const ConstBuffer& buf)$/;"	f	namespace:openvpn
buf_write_string	buffer/bufstr.hpp	/^  inline void buf_write_string(Buffer& buf, const char *str)$/;"	f	namespace:openvpn
buf_write_string	buffer/bufstr.hpp	/^  inline void buf_write_string(Buffer& buf, const std::string& str)$/;"	f	namespace:openvpn
buffer	ssl/proto.hpp	/^      const Buffer& buffer() const { return *buf; }$/;"	f	class:openvpn::ProtoContext::Packet
buffer	transport/pktstream.hpp	/^    BufferAllocated buffer;     \/\/ accumulated packet data$/;"	m	class:openvpn::PacketStream
buffer_const_index	buffer/buffer.hpp	/^      buffer_const_index,$/;"	e	enum:openvpn::BufferException::Status
buffer_flags	frame/frame.hpp	/^      unsigned int buffer_flags() const { return buffer_flags_; }$/;"	f	class:openvpn::Frame::Context
buffer_flags_	frame/frame.hpp	/^      unsigned int buffer_flags_;$/;"	m	class:openvpn::Frame::Context
buffer_full	buffer/buffer.hpp	/^      buffer_full,$/;"	e	enum:openvpn::BufferException::Status
buffer_headroom	buffer/buffer.hpp	/^      buffer_headroom,$/;"	e	enum:openvpn::BufferException::Status
buffer_index	buffer/buffer.hpp	/^      buffer_index,$/;"	e	enum:openvpn::BufferException::Status
buffer_no_reset_impl	buffer/buffer.hpp	/^      buffer_no_reset_impl,$/;"	e	enum:openvpn::BufferException::Status
buffer_overflow	buffer/buffer.hpp	/^      buffer_overflow,$/;"	e	enum:openvpn::BufferException::Status
buffer_pop_back	buffer/buffer.hpp	/^      buffer_pop_back,$/;"	e	enum:openvpn::BufferException::Status
buffer_ptr	ssl/proto.hpp	/^      const BufferPtr& buffer_ptr() { return buf; }$/;"	f	class:openvpn::ProtoContext::Packet
buffer_push_front_headroom	buffer/buffer.hpp	/^      buffer_push_front_headroom,$/;"	e	enum:openvpn::BufferException::Status
buffer_range	buffer/buffer.hpp	/^      buffer_range,$/;"	e	enum:openvpn::BufferException::Status
buffer_set_size	buffer/buffer.hpp	/^      buffer_set_size,$/;"	e	enum:openvpn::BufferException::Status
buffer_underflow	buffer/buffer.hpp	/^      buffer_underflow,$/;"	e	enum:openvpn::BufferException::Status
build	apple/ver.hpp	/^    int build() const { return ver[2]; }$/;"	f	class:openvpn::AppleVersion
build_peer_info	client/cliopt.hpp	/^    static PeerInfo::Set::Ptr build_peer_info(const Config& config, const ParseClientConfig& pcc, const bool autologin_sessions)$/;"	f	class:openvpn::ClientOptions
builder	client/cliopt.hpp	/^      TunBuilderBase* builder = nullptr;$/;"	m	struct:openvpn::ClientOptions::Config
builder	tun/builder/client.hpp	/^      TunBuilderBase* builder;$/;"	m	class:openvpn::TunBuilderClient::ClientConfig
bv	buffer/bufcomposed.hpp	/^    BufferVector bv;$/;"	m	class:openvpn::BufferComposed
by_char	common/split.hpp	/^    inline V by_char(const std::string& input, const char split_by, const unsigned int flags=0, const unsigned int max_terms=~0, LIM* lim=nullptr)$/;"	f	namespace:openvpn::Split
by_char_void	common/split.hpp	/^    inline void by_char_void(V& ret, const std::string& input, const char split_by, const unsigned int flags=0, const unsigned int max_terms=~0, LIM* lim=nullptr)$/;"	f	namespace:openvpn::Split
by_space	common/split.hpp	/^    inline V by_space(const std::string& input, LIM* lim=nullptr)$/;"	f	namespace:openvpn::Split
by_space_void	common/split.hpp	/^    inline void by_space_void(V& ret, const std::string& input, LIM* lim=nullptr)$/;"	f	namespace:openvpn::Split
bypass_host	tun/builder/capture.hpp	/^      std::string bypass_host;$/;"	m	class:openvpn::TunBuilderCapture::ProxyBypass
byte_string_is_v4	addr/ipv6.hpp	/^      static bool byte_string_is_v4(const unsigned char *bytestr)$/;"	f	class:openvpn::IPv6::Addr
bytes	addr/ipv4.hpp	/^	unsigned char bytes[4];$/;"	m	union:openvpn::IPv4::Addr::__anon4
bytes	addr/ipv6.hpp	/^	unsigned char bytes[16];$/;"	m	union:openvpn::IPv6::Addr::ipv6addr
bytes	common/options.hpp	/^      std::uint64_t bytes;$/;"	m	class:openvpn::OptionList::Limits
bytes	http/htmlskip.hpp	/^      unsigned long bytes;$/;"	m	class:openvpn::HTTP::HTMLSkip
bytes	random/randbytestore.hpp	/^      unsigned char bytes[SIZE];$/;"	m	union:openvpn::RandomByteStore::Result
bytes	ssl/datalimit.hpp	/^      size_type bytes = 0;$/;"	m	class:openvpn::DataLimit::Component
bytes_exceeded	transport/client/httpcli.hpp	/^	virtual void bytes_exceeded() {$/;"	f	struct:openvpn::HTTPProxyTransport::Client::ProxyResponseLimit
bytes_in	log/sessionstats.hpp	/^	count_t bytes_in;$/;"	m	struct:openvpn::SessionStats::DCOTransportSource::Data
bytes_out	log/sessionstats.hpp	/^	count_t bytes_out;$/;"	m	struct:openvpn::SessionStats::DCOTransportSource::Data
c_data	buffer/buffer.hpp	/^    const T* c_data() const { return data_ + offset_; }$/;"	f	class:openvpn::BufferType
c_data_end	buffer/buffer.hpp	/^    const T* c_data_end() const { return data_ + offset_ + size_; }$/;"	f	class:openvpn::BufferType
c_data_raw	buffer/buffer.hpp	/^    const T* c_data_raw() const { return data_; }$/;"	f	class:openvpn::BufferType
c_index	buffer/buffer.hpp	/^    const T* c_index(const size_t index) const$/;"	f	class:openvpn::BufferType
c_str	buffer/buffer.hpp	/^    const T* c_str() const { return c_data(); }$/;"	f	class:openvpn::BufferType
c_str	buffer/safestr.hpp	/^    const char *c_str() const$/;"	f	class:openvpn::SafeString
ca	openssl/ssl/sslctx.hpp	/^      CertCRLList ca;                   \/\/ from OpenVPN "ca" option$/;"	m	class:openvpn::OpenSSLContext::Config
ca_chain	polarssl/ssl/sslctx.hpp	/^      PolarSSLPKI::X509Cert::Ptr ca_chain;   \/\/ CA chain for remote verification$/;"	m	class:openvpn::PolarSSLContext::Config
cache_op32	ssl/proto.hpp	/^      void cache_op32()$/;"	f	class:openvpn::ProtoContext::KeyContext
cached_ip_address_list	client/remotelist.hpp	/^    void cached_ip_address_list(IP::AddrList& addrlist) const$/;"	f	class:openvpn::RemoteList
cached_item_exists	client/remotelist.hpp	/^    bool cached_item_exists() const$/;"	f	class:openvpn::RemoteList
calcHA1	proxy/httpdigest.hpp	/^      static std::string calcHA1(DigestFactory& digest_factory,$/;"	f	class:openvpn::HTTPProxy::Digest
calcResponse	proxy/httpdigest.hpp	/^      static std::string calcResponse(DigestFactory& digest_factory,$/;"	f	class:openvpn::HTTPProxy::Digest
call	transport/gremlin.hpp	/^	virtual void call()$/;"	f	struct:openvpn::Gremlin::DelayedQueue::Event
call	win/call.hpp	/^    inline std::string call(const std::string& cmd)$/;"	f	namespace:openvpn::Win
callable	common/rc.hpp	/^	: callable(c)$/;"	f	class:openvpn::RCWeak::NotifyItem
callable	common/rc.hpp	/^      CALLABLE callable;$/;"	m	class:openvpn::RCWeak::NotifyItem
callback	apple/macsleep.hpp	/^    void callback(io_service_t service, natural_t messageType, void *messageArgument)$/;"	f	class:openvpn::MacSleep
callback	tun/mac/macdns_watchdog.hpp	/^    void callback(SCDynamicStoreRef store, CFArrayRef changedKeys)$/;"	f	class:openvpn::MacDNSWatchdog
callback_static	apple/macsleep.hpp	/^    static void callback_static(void* arg, io_service_t service, natural_t messageType, void *messageArgument)$/;"	f	class:openvpn::MacSleep
callback_static	tun/mac/macdns_watchdog.hpp	/^    static void callback_static(SCDynamicStoreRef store, CFArrayRef changedKeys, void *arg)$/;"	f	class:openvpn::MacDNSWatchdog
can_retry_auth_with_cached_password	client/clicreds.hpp	/^    bool can_retry_auth_with_cached_password()$/;"	f	class:openvpn::ClientCreds
cancel	applecrypto/util/reachable.hpp	/^    void cancel(ReachabilityBase& rb)$/;"	f	class:openvpn::ReachabilityTracker
cancel	client/remotelist.hpp	/^      void cancel()$/;"	f	class:openvpn::RemoteList::PreResolve
cancel	common/asiosignal.hpp	/^    void cancel()$/;"	f	class:openvpn::ASIOSignals
cancel	tun/persist/tunwrapasio.hpp	/^    void cancel()$/;"	f	class:openvpn::TunWrapAsioStream
cancel_action_timer	apple/maclife.hpp	/^    void cancel_action_timer()$/;"	f	class:openvpn::MacLifeCycle
cancel_push_timer	tun/mac/macdns_watchdog.hpp	/^    void cancel_push_timer()$/;"	f	class:openvpn::MacDNSWatchdog
cancel_push_timer_nolock	tun/mac/macdns_watchdog.hpp	/^    void cancel_push_timer_nolock()$/;"	f	class:openvpn::MacDNSWatchdog
cancel_timers	client/cliconnect.hpp	/^    void cancel_timers()$/;"	f	class:openvpn::ClientConnect
capacity	buffer/buffer.hpp	/^    size_t capacity() const { return capacity_; }$/;"	f	class:openvpn::BufferType
capacity	frame/frame.hpp	/^      size_t capacity() const { return adj_capacity_; }$/;"	f	class:openvpn::Frame::Context
capacity_	buffer/buffer.hpp	/^    size_t capacity_;  \/\/ maximum number of array objects of type T for which memory is allocated, starting at data_$/;"	m	class:openvpn::BufferType
capacity_	common/circ_list.hpp	/^    size_t capacity_;$/;"	m	class:openvpn::CircList
cargv	common/argv.hpp	/^    char **cargv;$/;"	m	class:openvpn::ArgvWrapper
cast	applecrypto/cf/cf.hpp	/^      static T cast(CFTypeRef obj) { return T(Type<T>::cast(obj)); }$/;"	f	class:openvpn::CF::Wrap
cat	common/options.hpp	/^    std::string cat(const std::string& name) const$/;"	f	class:openvpn::OptionList
cc	client/cliopt.hpp	/^    SSLLib::SSLAPI::Config cc;$/;"	m	class:openvpn::ClientOptions
cert	openssl/ssl/sslctx.hpp	/^      OpenSSLPKI::X509 cert;            \/\/ from OpenVPN "cert" option$/;"	m	class:openvpn::OpenSSLContext::Config
cert_fail_code	openssl/ssl/sslctx.hpp	/^    static AuthCert::Fail::Type cert_fail_code(const int openssl_err)$/;"	f	class:openvpn::OpenSSLContext
cert_info	polarssl/ssl/sslctx.hpp	/^    static std::string cert_info(const x509_crt *cert, const char *prefix = nullptr)$/;"	f	class:openvpn::PolarSSLContext
cert_status_line	openssl/ssl/sslctx.hpp	/^    static std::string cert_status_line(int preverify_ok,$/;"	f	class:openvpn::OpenSSLContext
certs	pki/cclist.hpp	/^    CertList certs;$/;"	m	class:openvpn::CertCRLListTemplate
ch	common/lex.hpp	/^    int ch;$/;"	m	class:openvpn::NullLex
ch	common/lex.hpp	/^    int ch;$/;"	m	class:openvpn::StandardLex
ch	common/options.hpp	/^      int ch;$/;"	m	class:openvpn::OptionList::LexComment
chaddr	ip/dhcp.hpp	/^    std::uint8_t  chaddr[16]; \/* client hardware address *\/$/;"	m	struct:openvpn::DHCP
chain	polarssl/pki/x509cert.hpp	/^      x509_crt *chain;$/;"	m	class:openvpn::PolarSSLPKI::X509Cert
chain	polarssl/pki/x509crl.hpp	/^      x509_crl *chain;$/;"	m	class:openvpn::PolarSSLPKI::X509CRL
challenge_text	auth/cr.hpp	/^    std::string challenge_text;$/;"	m	class:openvpn::ChallengeResponse
check	ip/ip.hpp	/^    std::uint16_t   check;$/;"	m	struct:openvpn::IPHeader
check	ip/udp.hpp	/^    std::uint16_t   check;$/;"	m	struct:openvpn::UDPHeader
check_initialized	applecrypto/crypto/cipher.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::AppleCrypto::CipherContext
check_initialized	applecrypto/crypto/digest.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::AppleCrypto::DigestContext
check_initialized	openssl/crypto/cipher.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
check_initialized	openssl/crypto/ciphergcm.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::OpenSSLCrypto::CipherContextGCM
check_initialized	openssl/crypto/digest.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
check_initialized	openssl/crypto/hmac.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
check_initialized	polarssl/crypto/cipher.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
check_initialized	polarssl/crypto/ciphergcm.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::PolarSSLCrypto::CipherContextGCM
check_initialized	polarssl/crypto/digest.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
check_initialized	polarssl/crypto/hmac.hpp	/^      void check_initialized() const$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
check_overflow	common/options.hpp	/^      void check_overflow()$/;"	f	class:openvpn::OptionList::Limits
checksum	ip/icmp.hpp	/^    std::uint16_t checksum;$/;"	m	struct:openvpn::ICMP
chosen	common/pthreadcond.hpp	/^    bool chosen = false;$/;"	m	class:openvpn::PThreadBarrier
ciaddr	ip/dhcp.hpp	/^    std::uint32_t ciaddr;     \/* client IP address, client sets if known *\/$/;"	m	struct:openvpn::DHCP
cinfo	applecrypto/crypto/cipher.hpp	/^      const CryptoAlgs::Alg* cinfo;$/;"	m	class:openvpn::AppleCrypto::CipherContext
cipher	crypto/crypto_aead.hpp	/^      CryptoAlgs::Type cipher;$/;"	m	class:openvpn::AEAD::Crypto
cipher	crypto/crypto_aead.hpp	/^      CryptoAlgs::Type cipher;$/;"	m	class:openvpn::AEAD::CryptoContext
cipher	crypto/crypto_chm.hpp	/^    CryptoAlgs::Type cipher;$/;"	m	class:openvpn::CryptoCHM
cipher	crypto/crypto_chm.hpp	/^    CryptoAlgs::Type cipher;$/;"	m	class:openvpn::CryptoContextCHM
cipher	crypto/cryptodc.hpp	/^    CryptoAlgs::Type cipher() const { return cipher_; }$/;"	f	class:openvpn::CryptoDCSettings
cipher	crypto/decrypt_chm.hpp	/^    CipherContext<CRYPTO_API> cipher;$/;"	m	class:openvpn::DecryptCHM
cipher	crypto/encrypt_chm.hpp	/^    CipherContext<CRYPTO_API> cipher;$/;"	m	class:openvpn::EncryptCHM
cipher_	crypto/cryptodc.hpp	/^    CryptoAlgs::Type cipher_;$/;"	m	class:openvpn::CryptoDCSettings
cipher_alg	crypto/cryptodc.hpp	/^      CryptoAlgs::Type cipher_alg;$/;"	m	struct:openvpn::CryptoDCContext::Info
cipher_mode	applecrypto/crypto/cipher.hpp	/^      int cipher_mode() const$/;"	f	class:openvpn::AppleCrypto::CipherContext
cipher_mode	crypto/cipher.hpp	/^    int cipher_mode() const$/;"	f	class:openvpn::CipherContext
cipher_mode	openssl/crypto/cipher.hpp	/^      int cipher_mode() const$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
cipher_mode	polarssl/crypto/cipher.hpp	/^      int cipher_mode() const$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
cipher_type	applecrypto/crypto/cipher.hpp	/^      static CCAlgorithm cipher_type(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::AppleCrypto::CipherContext
cipher_type	openssl/crypto/cipher.hpp	/^      static const EVP_CIPHER *cipher_type(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
cipher_type	openssl/crypto/ciphergcm.hpp	/^      static const EVP_CIPHER *cipher_type(const CryptoAlgs::Type alg,$/;"	f	class:openvpn::OpenSSLCrypto::CipherContextGCM
cipher_type	polarssl/crypto/cipher.hpp	/^      static const cipher_info_t *cipher_type(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
cipher_type	polarssl/crypto/ciphergcm.hpp	/^      static cipher_id_t cipher_type(const CryptoAlgs::Type alg, unsigned int& keysize)$/;"	f	class:openvpn::PolarSSLCrypto::CipherContextGCM
ciphersuites	polarssl/ssl/sslctx.hpp	/^      const int ciphersuites[] = \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::polarssl_ctx_private::__anon73
clean	common/cleanup.hpp	/^    F clean;$/;"	m	class:openvpn::CleanupType
clear	applecrypto/crypto/digest.hpp	/^      void clear()$/;"	f	class:openvpn::AppleCrypto::DigestContext
clear	buffer/buffer.hpp	/^    void clear()$/;"	f	class:openvpn::BufferAllocatedType
clear	buffer/memq.hpp	/^    void clear()$/;"	f	class:openvpn::MemQBase
clear	common/options.hpp	/^    void clear() { data.clear(); }$/;"	f	class:openvpn::Option
clear	common/options.hpp	/^    void clear()$/;"	f	class:openvpn::OptionList
clear	polarssl/ssl/sslctx.hpp	/^      void clear()$/;"	f	class:openvpn::PolarSSLContext::SSL
clear_server	common/runcontext.hpp	/^    void clear_server(const unsigned int unit)$/;"	f	class:openvpn::RunContext
cli_events	client/cliopt.hpp	/^      ClientEvent::Queue::Ptr cli_events;$/;"	m	struct:openvpn::ClientOptions::Config
cli_events	client/cliopt.hpp	/^    ClientEvent::Queue::Ptr cli_events;$/;"	m	class:openvpn::ClientOptions
cli_events	client/cliproto.hpp	/^	ClientEvent::Queue::Ptr cli_events;$/;"	m	struct:openvpn::ClientProto::Session::Config
cli_events	client/cliproto.hpp	/^      ClientEvent::Queue::Ptr cli_events;$/;"	m	class:openvpn::ClientProto::Session
cli_stats	client/cliopt.hpp	/^      SessionStats::Ptr cli_stats;$/;"	m	struct:openvpn::ClientOptions::Config
cli_stats	client/cliopt.hpp	/^    SessionStats::Ptr cli_stats;$/;"	m	class:openvpn::ClientOptions
cli_stats	client/cliproto.hpp	/^	SessionStats::Ptr cli_stats;$/;"	m	struct:openvpn::ClientProto::Session::Config
cli_stats	client/cliproto.hpp	/^      SessionStats::Ptr cli_stats;$/;"	m	class:openvpn::ClientProto::Session
client	client/cliconnect.hpp	/^    Client::Ptr client;$/;"	m	class:openvpn::ClientConnect
clientCertEnabled	client/cliopthelper.hpp	/^    bool clientCertEnabled() const { return clientCertEnabled_; }$/;"	f	class:openvpn::ParseClientConfig
clientCertEnabled_	client/cliopthelper.hpp	/^    bool clientCertEnabled_;$/;"	m	class:openvpn::ParseClientConfig
client_auth	client/cliproto.hpp	/^      virtual void client_auth(Buffer& buf)$/;"	f	class:openvpn::ClientProto::Session
client_auth	ssl/proto.hpp	/^    virtual void client_auth(Buffer& buf)$/;"	f	class:openvpn::ProtoContext
client_config	client/cliopt.hpp	/^    Client::Config::Ptr client_config()$/;"	f	class:openvpn::ClientOptions
client_endpoint_render	server/servproto.hpp	/^      std::string client_endpoint_render()$/;"	f	class:openvpn::ServerProto::Session
client_finalized	client/cliconnect.hpp	/^    bool client_finalized;$/;"	m	class:openvpn::ClientConnect
client_ip	client/clievent.hpp	/^      std::string client_ip;$/;"	m	struct:openvpn::ClientEvent::Connected
client_lifecycle	client/cliopt.hpp	/^    ClientLifeCycle::Ptr client_lifecycle;$/;"	m	class:openvpn::ClientOptions
client_options	client/cliconnect.hpp	/^    ClientOptions::Ptr client_options;$/;"	m	class:openvpn::ClientConnect
client_proto_connected	client/cliconnect.hpp	/^    virtual void client_proto_connected()$/;"	f	class:openvpn::ClientConnect
client_proto_connected	client/cliproto.hpp	/^      virtual void client_proto_connected() {}$/;"	f	struct:openvpn::ClientProto::NotifyCallback
client_proto_terminate	client/cliconnect.hpp	/^    virtual void client_proto_terminate()$/;"	f	class:openvpn::ClientConnect
clients	server/vpnservnetblock.hpp	/^      IP::Range clients;$/;"	m	struct:openvpn::VPNServerNetblock::Netblock
cln_pause	client/cliconnect.hpp	/^    virtual void cln_pause(const std::string& reason)$/;"	f	class:openvpn::ClientConnect
cln_reconnect	client/cliconnect.hpp	/^    virtual void cln_reconnect(int seconds)$/;"	f	class:openvpn::ClientConnect
cln_resume	client/cliconnect.hpp	/^    virtual void cln_resume()$/;"	f	class:openvpn::ClientConnect
cln_stop	client/cliconnect.hpp	/^    virtual void cln_stop()$/;"	f	class:openvpn::ClientConnect
cloexec	common/redir.hpp	/^    static int cloexec(const int fd)$/;"	f	class:openvpn::RedirectPipe
clone_proto_config	server/servproto.hpp	/^      ProtoConfig::Ptr clone_proto_config() const$/;"	f	class:openvpn::ServerProto::Factory
close	common/scoped_asio_stream.hpp	/^    bool close()$/;"	f	class:openvpn::ScopedAsioStream
close	common/scoped_fd.hpp	/^    bool close()$/;"	f	class:openvpn::ScopedFD
close	tun/persist/tunpersist.hpp	/^    void close()$/;"	f	class:openvpn::TunPersistTemplate
close	tun/persist/tunwrap.hpp	/^    void close()$/;"	f	class:openvpn::TunWrapTemplate
close	tun/persist/tunwrapasio.hpp	/^    void close()$/;"	f	class:openvpn::TunWrapAsioStream
close	win/scoped_handle.hpp	/^      bool close()$/;"	f	class:openvpn::Win::ScopedHANDLE
close_destructor	tun/persist/tunwrap.hpp	/^    void close_destructor()$/;"	f	class:openvpn::TunWrapTemplate
close_file	common/tempfile.hpp	/^    void close_file()$/;"	f	class:openvpn::TempFile
close_local	tun/persist/tunpersist.hpp	/^    void close_local()$/;"	f	class:openvpn::TunPersistTemplate
cmd	tun/win/tunutil.hpp	/^	static std::string cmd(const TapNameGuidPair& tap)$/;"	f	class:openvpn::TunWin::Util::ActionEnableDHCP
cmd	win/cmd.hpp	/^    std::string cmd;$/;"	m	class:openvpn::WinCmd
cn	auth/authcert.hpp	/^      std::string cn;                \/\/ common name$/;"	m	struct:openvpn::AuthCert
cn_defined	auth/authcert.hpp	/^      bool cn_defined() const$/;"	f	struct:openvpn::AuthCert
code	error/excode.hpp	/^    Error::Type code() const { return Error::Type(code_ & ~FATAL_FLAG); }$/;"	f	class:openvpn::ExceptionCode
code	ip/icmp.hpp	/^    std::uint8_t code;$/;"	m	struct:openvpn::ICMP
code_	error/excode.hpp	/^    unsigned int code_;$/;"	m	class:openvpn::ExceptionCode
code_defined	error/excode.hpp	/^    bool code_defined() const { return code_ != 0; }$/;"	f	class:openvpn::ExceptionCode
combine	common/hash.hpp	/^    inline void combine(std::size_t& seed, const T& first, Args... args)$/;"	f	namespace:openvpn::Hash
combine	common/hash.hpp	/^    inline void combine(std::size_t& seed, const T& v)$/;"	f	namespace:openvpn::Hash
combine	common/hash.hpp	/^    inline void combine(std::size_t& seed, const char *str)$/;"	f	namespace:openvpn::Hash
combine_data	common/hash.hpp	/^    inline void combine_data(std::size_t& seed, const void *data, std::size_t size)$/;"	f	namespace:openvpn::Hash
combine_out_err	common/redir.hpp	/^    bool combine_out_err = false;$/;"	m	struct:openvpn::RedirectStdFD
combined_length	common/options.hpp	/^      size_t combined_length() const$/;"	f	class:openvpn::OptionList::KeyValue
comp_ctx	ssl/proto.hpp	/^      CompressContext comp_ctx;$/;"	m	class:openvpn::ProtoContext::Config
compare	common/options.hpp	/^      static bool compare(const Ptr& a, const Ptr& b)$/;"	f	class:openvpn::OptionList::KeyValue
complete	buffer/bufcomposed.hpp	/^    Complete complete()$/;"	f	class:openvpn::BufferComposed
complete	options/continuation.hpp	/^    bool complete() const { return complete_; }$/;"	f	class:openvpn::OptionListContinuation
complete_	options/continuation.hpp	/^    bool complete_;$/;"	m	class:openvpn::OptionListContinuation
completion_handler	common/actionthread.hpp	/^    Notify* completion_handler;    \/\/ completion handler$/;"	m	class:openvpn::ActionThread
completion_post	common/actionthread.hpp	/^    void completion_post(bool status)$/;"	f	class:openvpn::ActionThread
component	ssl/datalimit.hpp	/^    Component& component(const Mode m)$/;"	f	class:openvpn::DataLimit
compress	compress/compnull.hpp	/^    virtual void compress(BufferAllocated& buf, const bool hint) {}$/;"	f	class:openvpn::CompressNull
compress	compress/compstub.hpp	/^    virtual void compress(BufferAllocated& buf, const bool hint)$/;"	f	class:openvpn::CompressStub
compress	compress/compstub.hpp	/^    virtual void compress(BufferAllocated& buf, const bool hint)$/;"	f	class:openvpn::CompressStubV2
compress	compress/lz4.hpp	/^    virtual void compress(BufferAllocated& buf, const bool hint)$/;"	f	class:openvpn::CompressLZ4
compress	compress/lz4.hpp	/^    virtual void compress(BufferAllocated& buf, const bool hint)$/;"	f	class:openvpn::CompressLZ4v2
compress	compress/lzo.hpp	/^    virtual void compress(BufferAllocated& buf, const bool hint)$/;"	f	class:openvpn::CompressLZO
compress	compress/lzoasym.hpp	/^    virtual void compress(BufferAllocated& buf, const bool hint)$/;"	f	class:openvpn::CompressLZOAsym
compress	compress/snappy.hpp	/^    virtual void compress(BufferAllocated& buf, const bool hint)$/;"	f	class:openvpn::CompressSnappy
compress	ssl/proto.hpp	/^      Compress::Ptr compress;$/;"	m	class:openvpn::ProtoContext::KeyContext
compress_gzip	buffer/zlib.hpp	/^    inline BufferPtr compress_gzip(BufferPtr src,$/;"	f	namespace:openvpn::ZLib
compression_mode	ssl/proto_context_options.hpp	/^    CompressionMode compression_mode;$/;"	m	struct:openvpn::ProtoContextOptions
compressor_available	compress/compress.hpp	/^    static bool compressor_available(const Type t)$/;"	f	class:openvpn::CompressContext
cond_reset	applecrypto/crypto/hmac.hpp	/^      void cond_reset(const bool force_init)$/;"	f	class:openvpn::AppleCrypto::HMACContext
conf	ssl/proto.hpp	/^    Config& conf() { return *config; }$/;"	f	class:openvpn::ProtoContext
conf	ssl/proto.hpp	/^    const Config& conf() const { return *config; }$/;"	f	class:openvpn::ProtoContext
conf	transport/gremlin.hpp	/^      Config::Ptr conf;$/;"	m	class:openvpn::Gremlin::SendRecvQueue
conf_ptr	ssl/proto.hpp	/^    const Config::Ptr& conf_ptr() const { return config; }$/;"	f	class:openvpn::ProtoContext
config	openssl/ssl/sslctx.hpp	/^    Config::Ptr config;$/;"	m	class:openvpn::OpenSSLContext
config	polarssl/ssl/sslctx.hpp	/^    Config::Ptr config;$/;"	m	class:openvpn::PolarSSLContext
config	ssl/proto.hpp	/^    Config::Ptr config;$/;"	m	class:openvpn::ProtoContext
config	transport/client/httpcli.hpp	/^      ClientConfig::Ptr config;$/;"	m	class:openvpn::HTTPProxyTransport::Client
config	transport/client/tcpcli.hpp	/^      ClientConfig::Ptr config;$/;"	m	class:openvpn::TCPTransport::Client
config	transport/client/udpcli.hpp	/^      ClientConfig::Ptr config;$/;"	m	class:openvpn::UDPTransport::Client
config	tun/builder/client.hpp	/^      ClientConfig::Ptr config;$/;"	m	class:openvpn::TunBuilderClient::Client
config	tun/client/tunnull.hpp	/^      ClientConfig::Ptr config;$/;"	m	class:openvpn::TunNull::Client
config	tun/linux/client/tuncli.hpp	/^      ClientConfig::Ptr config;$/;"	m	class:openvpn::TunLinux::Client
config	tun/mac/client/tuncli.hpp	/^      ClientConfig::Ptr config;$/;"	m	class:openvpn::TunMac::Client
config	tun/mac/macdns_watchdog.hpp	/^      const MacDNS::Config::Ptr config;$/;"	m	class:openvpn::MacDNSWatchdog::DNSAction
config	tun/win/client/tuncli.hpp	/^      ClientConfig::Ptr config;$/;"	m	class:openvpn::TunWin::Client
config_	applecrypto/ssl/sslctx.hpp	/^    Config::Ptr config_;$/;"	m	class:openvpn::AppleSSLContext
config_	tun/mac/macdns_watchdog.hpp	/^    MacDNS::Config::Ptr config_;$/;"	m	class:openvpn::MacDNSWatchdog
configure_builder	tun/client/tunprop.hpp	/^    static void configure_builder(TunBuilderBase* tb,$/;"	f	class:openvpn::TunProp
configured	server/vpnservpool.hpp	/^      static bool configured(const OptionList& opt,$/;"	f	class:openvpn::VPNServerPool::Pool
configured	tun/client/dhcp_capture.hpp	/^    bool configured = false;$/;"	m	class:openvpn::DHCPCapture
confirm	tun/win/client/setupbase.hpp	/^      virtual void confirm()$/;"	f	struct:openvpn::TunWin::SetupBase
conn_block	client/remotelist.hpp	/^      ConnBlock::Ptr conn_block;$/;"	m	struct:openvpn::RemoteList::Item
conn_timeout	client/cliconnect.hpp	/^    int conn_timeout;$/;"	m	class:openvpn::ClientConnect
conn_timeout	client/cliopt.hpp	/^      int conn_timeout = 0;$/;"	m	struct:openvpn::ClientOptions::Config
conn_timeout	client/cliopt.hpp	/^    int conn_timeout() const { return conn_timeout_; }$/;"	f	class:openvpn::ClientOptions
conn_timeout_	client/cliopt.hpp	/^    int conn_timeout_;$/;"	m	class:openvpn::ClientOptions
conn_timer	client/cliconnect.hpp	/^    AsioTimer conn_timer;$/;"	m	class:openvpn::ClientConnect
conn_timer_callback	client/cliconnect.hpp	/^    void conn_timer_callback(unsigned int gen, const asio::error_code& e)$/;"	f	class:openvpn::ClientConnect
conn_timer_pending	client/cliconnect.hpp	/^    bool conn_timer_pending;$/;"	m	class:openvpn::ClientConnect
conn_timer_start	client/cliconnect.hpp	/^    void conn_timer_start()$/;"	f	class:openvpn::ClientConnect
connected_	client/cliproto.hpp	/^      ClientEvent::Connected::Ptr connected_;$/;"	m	class:openvpn::ClientProto::Session
connected_cast	client/clievent.hpp	/^      const Connected* connected_cast() const$/;"	f	class:openvpn::ClientEvent::Base
connection	client/remotelist.hpp	/^      std::string connection;$/;"	m	struct:openvpn::RemoteList::Directives
consider_compression	crypto/crypto_aead.hpp	/^      virtual bool consider_compression(const CompressContext& comp_ctx)$/;"	f	class:openvpn::AEAD::Crypto
consider_compression	crypto/crypto_chm.hpp	/^    virtual bool consider_compression(const CompressContext& comp_ctx)$/;"	f	class:openvpn::CryptoCHM
console_mode_save	win/console.hpp	/^	DWORD console_mode_save;$/;"	m	class:openvpn::Win::Console::Input
const_array	applecrypto/cf/cf.hpp	/^    inline Array const_array(MutableArray& marray)$/;"	f	namespace:openvpn::CF
const_buffer_ref	buffer/buffer.hpp	/^  inline BufferType<const T>& const_buffer_ref(BufferType<T>& src)$/;"	f	namespace:openvpn
const_buffers_1	buffer/buffer.hpp	/^    asio::const_buffers_1 const_buffers_1() const$/;"	f	class:openvpn::BufferType
const_buffers_1_clamp	buffer/buffer.hpp	/^    asio::const_buffers_1 const_buffers_1_clamp() const$/;"	f	class:openvpn::BufferType
const_buffers_1_limit	buffer/buffer.hpp	/^    asio::const_buffers_1 const_buffers_1_limit(const size_t limit) const$/;"	f	class:openvpn::BufferType
const_dict	applecrypto/cf/cf.hpp	/^    inline Dict const_dict(MutableDict& mdict)$/;"	f	namespace:openvpn::CF
const_iterator	buffer/asiobuf.hpp	/^    typedef const asio::const_buffer* const_iterator;$/;"	t	class:openvpn::AsioConstBufferSeq2
const_memq_from_bio	openssl/bio/bio_memq_dgram.hpp	/^    inline const MemQ *const_memq_from_bio(const BIO *b)$/;"	f	namespace:openvpn::bmq_dgram
const_memq_from_bio	openssl/bio/bio_memq_stream.hpp	/^    inline const MemQ *const_memq_from_bio(const BIO *b)$/;"	f	namespace:openvpn::bmq_stream
const_type	buffer/buffer.hpp	/^    typedef const T* const_type;$/;"	t	class:openvpn::BufferType
construct_dynamic_password	auth/cr.hpp	/^    std::string construct_dynamic_password(const std::string& response) const$/;"	f	class:openvpn::ChallengeResponse
construct_static_password	auth/cr.hpp	/^    static std::string construct_static_password(const std::string& password,$/;"	f	class:openvpn::ChallengeResponse
construct_time	ssl/proto.hpp	/^      Time construct_time;$/;"	m	class:openvpn::ProtoContext::KeyContext
consume	http/reply.hpp	/^      status consume(Reply& req, const unsigned char input)$/;"	f	class:openvpn::HTTP::ReplyParser
consume	http/request.hpp	/^      status consume(Request& req, const unsigned char input)$/;"	f	class:openvpn::HTTP::RequestParser
contains	addr/route.hpp	/^      bool contains(const ADDR& a) const \/\/ assumes canonical address\/routes$/;"	f	struct:openvpn::IP::RouteType
contains	addr/route.hpp	/^      bool contains(const RouteType& r) const \/\/ assumes canonical routes$/;"	f	struct:openvpn::IP::RouteType
contains_non_space_ctrl	common/string.hpp	/^    inline bool contains_non_space_ctrl(const std::string& str)$/;"	f	namespace:openvpn::string
contains_null	buffer/buffer.hpp	/^    bool contains_null() const$/;"	f	class:openvpn::BufferType
contains_protocol	client/remotelist.hpp	/^    bool contains_protocol(const Protocol& proto)$/;"	f	class:openvpn::RemoteList
contains_space	common/string.hpp	/^    inline bool contains_space(const std::string& str)$/;"	f	namespace:openvpn::string
content	common/redir.hpp	/^      const std::string content() const$/;"	f	class:openvpn::RedirectPipe::SD_IN
context	crypto/cryptodc.hpp	/^    CryptoDCContext& context()$/;"	f	class:openvpn::CryptoDCSettings
context_	crypto/cryptodc.hpp	/^    CryptoDCContext::Ptr context_;$/;"	m	class:openvpn::CryptoDCSettings
contexts	common/asiocontext.hpp	/^    std::vector<std::unique_ptr<asio::io_context>> contexts;$/;"	m	class:openvpn::AsioContextStore
contexts	frame/frame.hpp	/^    Context contexts[N_ALIGN_CONTEXTS];$/;"	m	class:openvpn::Frame
continuation	options/continuation.hpp	/^    static bool continuation(const OptionList& opt)$/;"	f	class:openvpn::OptionListContinuation
control_net_recv	ssl/proto.hpp	/^    bool control_net_recv(const PacketType& type, BufferAllocated&& net_buf)$/;"	f	class:openvpn::ProtoContext
control_net_recv	ssl/proto.hpp	/^    bool control_net_recv(const PacketType& type, BufferPtr&& net_bp)$/;"	f	class:openvpn::ProtoContext
control_net_send	client/cliproto.hpp	/^      virtual void control_net_send(const Buffer& net_buf)$/;"	f	class:openvpn::ClientProto::Session
control_net_send	server/servproto.hpp	/^      virtual void control_net_send(const Buffer& net_buf)$/;"	f	class:openvpn::ServerProto::Session
control_net_validate	ssl/proto.hpp	/^    bool control_net_validate(const PacketType& type, const Buffer& net_buf)$/;"	f	class:openvpn::ProtoContext
control_recv	client/cliproto.hpp	/^      virtual void control_recv(BufferPtr&& app_bp)$/;"	f	class:openvpn::ClientProto::Session
control_recv	server/servproto.hpp	/^      virtual void control_recv(BufferPtr&& app_bp)$/;"	f	class:openvpn::ServerProto::Session
control_send	ssl/proto.hpp	/^    void control_send(BufferAllocated&& app_buf)$/;"	f	class:openvpn::ProtoContext
control_send	ssl/proto.hpp	/^    void control_send(BufferPtr&& app_bp)$/;"	f	class:openvpn::ProtoContext
controller	common/rc.hpp	/^      typename Controller::Ptr controller;  \/\/ object containing actual refcount$/;"	m	namespace:openvpn
controller	common/rc.hpp	/^    typename T::Controller::Ptr controller;$/;"	m	class:openvpn::RCWeakPtr
conversionOK	common/unicode-impl.hpp	/^      conversionOK,   \/* conversion successful *\/$/;"	e	enum:openvpn::Unicode::__anon25
conversion_result_throw	common/unicode.hpp	/^    inline void conversion_result_throw(const ConversionResult res)$/;"	f	namespace:openvpn::Unicode
convert_to_option	common/options.hpp	/^      Option convert_to_option(Limits* lim) const$/;"	f	class:openvpn::OptionList::KeyValue
copt_	tun/persist/tunpersist.hpp	/^    TunBuilderCapture::Ptr copt_;$/;"	m	class:openvpn::TunPersistTemplate
copy	buffer/buflist.hpp	/^    BufferCollection copy() const$/;"	f	struct:openvpn::BufferCollection
copy	common/process.hpp	/^    Command* copy() const$/;"	f	struct:openvpn::Command
copy	frame/frame.hpp	/^      BufferPtr copy(const BufferPtr& buf) const$/;"	f	class:openvpn::Frame::Context
copy	frame/frame.hpp	/^      BufferPtr copy(const unsigned char *data, const size_t size) const$/;"	f	class:openvpn::Frame::Context
copy	ssl/peerinfo.hpp	/^      Ptr copy() const$/;"	f	struct:openvpn::PeerInfo::Set
copy_64	compress/lzoasym_impl.hpp	/^    inline void copy_64(unsigned char *dest, const unsigned char *src)$/;"	f	namespace:openvpn::lzo_asym_impl
copy_by_value	frame/frame.hpp	/^      BufferAllocated copy_by_value(const unsigned char *data, const size_t size) const$/;"	f	class:openvpn::Frame::Context
copy_fast	compress/lzoasym_impl.hpp	/^    inline void copy_fast(unsigned char *dest, const unsigned char *src, ssize_t len)$/;"	f	namespace:openvpn::lzo_asym_impl
copy_mem	compress/lzoasym_impl.hpp	/^    inline void copy_mem(void *dest, const void *src)$/;"	f	namespace:openvpn::lzo_asym_impl
count	common/pthreadcond.hpp	/^    unsigned int count = 0;$/;"	m	class:openvpn::PThreadBarrier
count_	common/usecount.hpp	/^    int& count_;$/;"	m	class:openvpn::UseCount
count_t	common/count.hpp	/^  typedef long long count_t;$/;"	t	namespace:openvpn
cp	client/cliopt.hpp	/^    Client::ProtoConfig::Ptr cp;$/;"	m	class:openvpn::ClientOptions
cppstring	applecrypto/cf/cf.hpp	/^    inline std::string cppstring(CFStringRef str)$/;"	f	namespace:openvpn::CF
cppstring	applecrypto/cf/cf.hpp	/^    inline std::string cppstring(const String& str)$/;"	f	namespace:openvpn::CF
create_http_connect_msg	transport/client/httpcli.hpp	/^      void create_http_connect_msg(BufferAllocated& buf)$/;"	f	class:openvpn::HTTPProxyTransport::Client
create_rule	tun/win/nrpt.hpp	/^      static void create_rule(const std::vector<std::string> names, const std::vector<std::string> dns_servers)$/;"	f	class:openvpn::TunWin::NRPT
creds	client/cliopt.hpp	/^    ClientCreds::Ptr creds;$/;"	m	class:openvpn::ClientOptions
creds	client/cliproto.hpp	/^	ClientCreds::Ptr creds;$/;"	m	struct:openvpn::ClientProto::Session::Config
creds	client/cliproto.hpp	/^      ClientCreds::Ptr creds;$/;"	m	class:openvpn::ClientProto::Session
creds_locked	client/cliopt.hpp	/^    bool creds_locked;$/;"	m	class:openvpn::ClientOptions
cref	applecrypto/crypto/cipher.hpp	/^      CCCryptorRef cref;$/;"	m	class:openvpn::AppleCrypto::CipherContext
crl_	openssl/pki/crl.hpp	/^      X509_CRL *crl_;$/;"	m	class:openvpn::OpenSSLPKI::CRL
crl_chain	polarssl/ssl/sslctx.hpp	/^      PolarSSLPKI::X509CRL::Ptr crl_chain;   \/\/ CRL chain for remote verification$/;"	m	class:openvpn::PolarSSLContext::Config
crls	pki/cclist.hpp	/^    CRLList crls;$/;"	m	class:openvpn::CertCRLListTemplate
crt_chain	polarssl/ssl/sslctx.hpp	/^      PolarSSLPKI::X509Cert::Ptr crt_chain;  \/\/ local cert chain (including client cert + extra certs)$/;"	m	class:openvpn::PolarSSLContext::Config
crypt	openssl/util/tokenencrypt.hpp	/^    std::string crypt(const std::string& tokstr)$/;"	f	class:openvpn::TokenEncrypt
crypto	common/memneq.hpp	/^  namespace crypto {$/;"	n	namespace:openvpn
crypto	ssl/proto.hpp	/^      CryptoDCInstance::Ptr crypto;$/;"	m	class:openvpn::ProtoContext::KeyContext
crypto_flags	ssl/proto.hpp	/^      unsigned int crypto_flags;$/;"	m	class:openvpn::ProtoContext::KeyContext
crypto_info	crypto/crypto_aead.hpp	/^      virtual Info crypto_info()$/;"	f	class:openvpn::AEAD::CryptoContext
crypto_info	crypto/crypto_chm.hpp	/^    virtual Info crypto_info()$/;"	f	class:openvpn::CryptoContextCHM
crypto_init	init/cryptoinit.hpp	/^  class crypto_init$/;"	c	namespace:openvpn
crypto_init_	init/initprocess.hpp	/^      crypto_init crypto_init_;$/;"	m	class:openvpn::InitProcess::Init
crypto_self_test	crypto/selftest.hpp	/^    inline std::string crypto_self_test()$/;"	f	namespace:openvpn::SelfTest
crypto_self_test_polarssl	polarssl/util/selftest.hpp	/^  inline std::string crypto_self_test_polarssl()$/;"	f	namespace:openvpn
ct_in	applecrypto/ssl/sslctx.hpp	/^      MemQStream ct_in;  \/\/ write ciphertext to here$/;"	m	class:openvpn::AppleSSLContext::SSL
ct_in	openssl/ssl/sslctx.hpp	/^      BIO *ct_in;          \/\/ write ciphertext to here$/;"	m	class:openvpn::OpenSSLContext::SSL
ct_in	polarssl/ssl/sslctx.hpp	/^      MemQStream ct_in;    \/\/ write ciphertext to here$/;"	m	class:openvpn::PolarSSLContext::SSL
ct_out	applecrypto/ssl/sslctx.hpp	/^      MemQStream ct_out; \/\/ read ciphertext from here$/;"	m	class:openvpn::AppleSSLContext::SSL
ct_out	openssl/ssl/sslctx.hpp	/^      BIO *ct_out;         \/\/ read ciphertext from here$/;"	m	class:openvpn::OpenSSLContext::SSL
ct_out	polarssl/ssl/sslctx.hpp	/^      MemQStream ct_out;   \/\/ read ciphertext from here$/;"	m	class:openvpn::PolarSSLContext::SSL
ct_read_func	applecrypto/ssl/sslctx.hpp	/^      static OSStatus ct_read_func(SSLConnectionRef cref, void *data, size_t *length)$/;"	f	class:openvpn::AppleSSLContext::SSL
ct_read_func	polarssl/ssl/sslctx.hpp	/^      static int ct_read_func(void *arg, unsigned char *data, size_t length)$/;"	f	class:openvpn::PolarSSLContext::SSL
ct_write_func	applecrypto/ssl/sslctx.hpp	/^      static OSStatus ct_write_func(SSLConnectionRef cref, const void *data, size_t *length)$/;"	f	class:openvpn::AppleSSLContext::SSL
ct_write_func	polarssl/ssl/sslctx.hpp	/^      static int ct_write_func(void *arg, const unsigned char *data, size_t length)$/;"	f	class:openvpn::PolarSSLContext::SSL
ctrl	openssl/bio/bio_memq_dgram.hpp	/^      long ctrl (BIO *b, int cmd, long num, void *ptr)$/;"	f	class:openvpn::bmq_dgram::MemQ
ctrl	openssl/bio/bio_memq_stream.hpp	/^      long ctrl (BIO *b, int cmd, long num, void *ptr)$/;"	f	class:openvpn::bmq_stream::MemQ
ctx	applecrypto/crypto/digest.hpp	/^      DigestCTX ctx;$/;"	m	class:openvpn::AppleCrypto::DigestContext
ctx	applecrypto/crypto/hmac.hpp	/^      CCHmacContext ctx;$/;"	m	class:openvpn::AppleCrypto::HMACContext
ctx	common/runcontext.hpp	/^      RunContext& ctx;$/;"	m	class:openvpn::RunContext::ThreadContext
ctx	crypto/cipher.hpp	/^    typename CRYPTO_API::CipherContext ctx;$/;"	m	class:openvpn::CipherContext
ctx	crypto/hashstr.hpp	/^    DigestInstance::Ptr ctx;$/;"	m	class:openvpn::HashString
ctx	crypto/ovpnhmac.hpp	/^    typename CRYPTO_API::HMACContext ctx;$/;"	m	class:openvpn::OvpnHMAC
ctx	openssl/crypto/cipher.hpp	/^      EVP_CIPHER_CTX ctx;$/;"	m	class:openvpn::OpenSSLCrypto::CipherContext
ctx	openssl/crypto/ciphergcm.hpp	/^      EVP_CIPHER_CTX ctx;$/;"	m	class:openvpn::OpenSSLCrypto::CipherContextGCM
ctx	openssl/crypto/digest.hpp	/^      EVP_MD_CTX ctx;$/;"	m	class:openvpn::OpenSSLCrypto::DigestContext
ctx	openssl/crypto/hmac.hpp	/^      HMAC_CTX ctx;$/;"	m	class:openvpn::OpenSSLCrypto::HMACContext
ctx	openssl/ssl/sslctx.hpp	/^    SSL_CTX* ctx;$/;"	m	class:openvpn::OpenSSLContext
ctx	openssl/util/tokenencrypt.hpp	/^    EVP_CIPHER_CTX ctx;$/;"	m	class:openvpn::TokenEncrypt
ctx	polarssl/crypto/cipher.hpp	/^      cipher_context_t ctx;$/;"	m	class:openvpn::PolarSSLCrypto::CipherContext
ctx	polarssl/crypto/ciphergcm.hpp	/^      gcm_context ctx;$/;"	m	class:openvpn::PolarSSLCrypto::CipherContextGCM
ctx	polarssl/crypto/digest.hpp	/^      md_context_t ctx;$/;"	m	class:openvpn::PolarSSLCrypto::DigestContext
ctx	polarssl/crypto/hmac.hpp	/^      md_context_t ctx;$/;"	m	class:openvpn::PolarSSLCrypto::HMACContext
ctx	polarssl/pki/pkctx.hpp	/^      pk_context *ctx;$/;"	m	class:openvpn::PolarSSLPKI::PKContext
ctx	polarssl/util/rand.hpp	/^    ctr_drbg_context ctx;$/;"	m	class:openvpn::PolarSSLRandom
current_conn_block	client/remotelist.hpp	/^    typename T::Ptr current_conn_block() const$/;"	f	class:openvpn::RemoteList
current_conn_block_rawptr	client/remotelist.hpp	/^    T* current_conn_block_rawptr() const$/;"	f	class:openvpn::RemoteList
current_event	ssl/proto.hpp	/^      EventType current_event;$/;"	m	class:openvpn::ProtoContext::KeyContext
current_server_host	client/remotelist.hpp	/^    const std::string& current_server_host() const$/;"	f	class:openvpn::RemoteList
current_transport_protocol	client/remotelist.hpp	/^    const Protocol& current_transport_protocol() const$/;"	f	class:openvpn::RemoteList
cv	common/pthreadcond.hpp	/^    std::condition_variable cv;$/;"	m	class:openvpn::PThreadBarrier
cvt_pnr_ip_v4	netconf/linux/route.hpp	/^    static IP::Addr cvt_pnr_ip_v4(const std::string& hexaddr)$/;"	f	class:openvpn::RouteListLinux
cvt_pnr_ip_v4	tun/linux/client/tuncli.hpp	/^    inline IP::Addr cvt_pnr_ip_v4(const std::string& hexaddr)$/;"	f	namespace:openvpn::TunLinux
cxx_demangle	common/demangle.hpp	/^  inline std::string cxx_demangle(const char *mangled_name)$/;"	f	namespace:openvpn
d	crypto/crypto_aead.hpp	/^      Decrypt d;$/;"	m	class:openvpn::AEAD::Crypto
daddr	ip/ip.hpp	/^    std::uint32_t   daddr;$/;"	m	struct:openvpn::IPHeader
daemon_pid	linux/daemon_alive.hpp	/^  inline int daemon_pid(const std::string& cmd,$/;"	f	namespace:openvpn
daemonize	common/daemon.hpp	/^  inline void daemonize()$/;"	f	namespace:openvpn
daemonize	common/daemon.hpp	/^  inline void daemonize(const std::string& log_fn,$/;"	f	namespace:openvpn
data	addr/addrpair.hpp	/^	std::string data[2];$/;"	m	class:openvpn::IP::AddrMaskPair::StringPair
data	applecrypto/cf/cf.hpp	/^    inline Data data(const void *bytes, CFIndex length)$/;"	f	namespace:openvpn::CF
data	buffer/buffer.hpp	/^    T* data() { return data_ + offset_; }$/;"	f	class:openvpn::BufferType
data	buffer/safestr.hpp	/^    BufferAllocated data;$/;"	m	class:openvpn::SafeString
data	common/function.hpp	/^    void* data[N];$/;"	m	class:openvpn::Function
data	common/options.hpp	/^    std::vector<std::string> data;$/;"	m	class:openvpn::Option
data	common/redir.hpp	/^      BufferList data;$/;"	m	class:openvpn::RedirectPipe::SD_IN
data	common/splitlines.hpp	/^    const char *data;$/;"	m	class:openvpn::SplitLinesType
data	common/unicode.hpp	/^	unsigned char data[4];$/;"	m	struct:openvpn::Unicode::UTF8Iterator::Char
data	crypto/crypto_aead.hpp	/^	unsigned char data[16];$/;"	m	class:openvpn::AEAD::Crypto::Nonce
data	crypto/static_key.hpp	/^    const unsigned char *data() const { return key_data_.c_data(); }$/;"	f	class:openvpn::StaticKey
data	openssl/util/tokenencrypt.hpp	/^      std::uint8_t data[TOK_SIZE];$/;"	m	struct:openvpn::TokenEncrypt::Key
data	reliable/relack.hpp	/^    std::deque<id_t> data;$/;"	m	class:openvpn::ReliableAck
data_	buffer/buffer.hpp	/^    T* data_;          \/\/ pointer to data$/;"	m	class:openvpn::BufferType
data_	common/base64.hpp	/^      const unsigned char *data_;$/;"	m	class:openvpn::Base64::UCharWrap
data_	common/circ_list.hpp	/^    std::vector<T> data_;$/;"	m	class:openvpn::CircList
data_channel_key	ssl/proto.hpp	/^      std::unique_ptr<DataChannelKey> data_channel_key;$/;"	m	class:openvpn::ProtoContext::KeyContext
data_channel_ready	ssl/proto.hpp	/^      bool data_channel_ready() const { return state >= ACTIVE; }$/;"	f	class:openvpn::ProtoContext::KeyContext
data_channel_ready	ssl/proto.hpp	/^    bool data_channel_ready() const { return primary->data_channel_ready(); }$/;"	f	class:openvpn::ProtoContext
data_decrypt	ssl/proto.hpp	/^    bool data_decrypt(const PacketType& type, BufferAllocated& in_out)$/;"	f	class:openvpn::ProtoContext
data_encrypt	ssl/proto.hpp	/^    void data_encrypt(BufferAllocated& in_out)$/;"	f	class:openvpn::ProtoContext
data_end	buffer/buffer.hpp	/^    T* data_end() { return data_ + offset_ + size_; }$/;"	f	class:openvpn::BufferType
data_limit	ssl/proto.hpp	/^      std::unique_ptr<DataLimit> data_limit;$/;"	m	class:openvpn::ProtoContext::KeyContext
data_limit_add	ssl/proto.hpp	/^      void data_limit_add(const DataLimit::Mode mode, const size_t size)$/;"	f	class:openvpn::ProtoContext::KeyContext
data_limit_defer	ssl/proto.hpp	/^      bool data_limit_defer() const$/;"	f	class:openvpn::ProtoContext::KeyContext
data_limit_event	ssl/proto.hpp	/^      void data_limit_event(const DataLimit::Mode mode, const DataLimit::State state)$/;"	f	class:openvpn::ProtoContext::KeyContext
data_limit_expire	ssl/proto.hpp	/^      Time data_limit_expire() const$/;"	f	class:openvpn::ProtoContext::KeyContext
data_limit_notify	server/servproto.hpp	/^      virtual void data_limit_notify(const int key_id,$/;"	f	class:openvpn::ServerProto::Session
data_limit_notify	ssl/proto.hpp	/^      void data_limit_notify(const DataLimit::Mode cdl_mode,$/;"	f	class:openvpn::ProtoContext::KeyContext
data_limit_notify	ssl/proto.hpp	/^    void data_limit_notify(const int key_id,$/;"	f	class:openvpn::ProtoContext
data_raw	buffer/buffer.hpp	/^    T* data_raw() { return data_; }$/;"	f	class:openvpn::BufferType
datac	buffer/buffer.hpp	/^    T* datac() const { return data_ + offset_; }$/;"	f	class:openvpn::BufferType
date_time	time/timestr.hpp	/^  inline std::string date_time()$/;"	f	namespace:openvpn
date_time	time/timestr.hpp	/^  inline std::string date_time(const time_t now)$/;"	f	namespace:openvpn
date_time_rfc822	time/timestr.hpp	/^  inline std::string date_time_rfc822()$/;"	f	namespace:openvpn
date_time_rfc822	time/timestr.hpp	/^  inline std::string date_time_rfc822(const time_t t)$/;"	f	namespace:openvpn
date_time_store_time_t	time/timestr.hpp	/^  inline std::string date_time_store_time_t(time_t& save)$/;"	f	namespace:openvpn
dbg_callback	polarssl/ssl/sslctx.hpp	/^      static void dbg_callback(void *arg, int level, const char *text)$/;"	f	class:openvpn::PolarSSLContext::SSL
dc	ssl/proto.hpp	/^      CryptoDCSettings dc;$/;"	m	class:openvpn::ProtoContext::Config
dc_deferred	ssl/proto.hpp	/^      bool dc_deferred = false;$/;"	m	class:openvpn::ProtoContext::Config
dc_deferred	ssl/proto.hpp	/^    bool dc_deferred;$/;"	m	class:openvpn::ProtoContext
dc_settings	ssl/proto.hpp	/^    CryptoDCSettings& dc_settings()$/;"	f	class:openvpn::ProtoContext
dco	client/cliopt.hpp	/^      bool dco = false;$/;"	m	struct:openvpn::ClientOptions::Config
dco	client/cliopt.hpp	/^    DCO::Ptr dco;$/;"	m	class:openvpn::ClientOptions
dco_	log/sessionstats.hpp	/^    DCOTransportSource::Ptr dco_;$/;"	m	class:openvpn::SessionStats
dco_configure	log/sessionstats.hpp	/^    void dco_configure(SessionStats::DCOTransportSource* source)$/;"	f	class:openvpn::SessionStats
dco_update	log/sessionstats.hpp	/^    void dco_update()$/;"	f	class:openvpn::SessionStats
dealloc	polarssl/pki/dh.hpp	/^      void dealloc()$/;"	f	class:openvpn::PolarSSLPKI::DH
dealloc	polarssl/pki/pkctx.hpp	/^      void dealloc()$/;"	f	class:openvpn::PolarSSLPKI::PKContext
dealloc	polarssl/pki/x509cert.hpp	/^      void dealloc()$/;"	f	class:openvpn::PolarSSLPKI::X509Cert
dealloc	polarssl/pki/x509crl.hpp	/^      void dealloc()$/;"	f	class:openvpn::PolarSSLPKI::X509CRL
debug_level	ssl/proto.hpp	/^      int debug_level = 1;$/;"	m	class:openvpn::ProtoContext::Config
debug_prefix	ssl/proto.hpp	/^    std::string debug_prefix()$/;"	f	class:openvpn::ProtoContext
dec	common/base64.hpp	/^    unsigned char dec[128];$/;"	m	class:openvpn::Base64
decapsulate	ssl/proto.hpp	/^      bool decapsulate(Packet& pkt) \/\/ called by ProtoStackBase$/;"	f	class:openvpn::ProtoContext::KeyContext
declared_size	transport/pktstream.hpp	/^    size_t declared_size;       \/\/ declared size of packet in leading uint16_t prefix$/;"	m	class:openvpn::PacketStream
declared_size_defined	transport/pktstream.hpp	/^    bool declared_size_defined; \/\/ true if declared_size is defined$/;"	m	class:openvpn::PacketStream
decode	common/base64.hpp	/^    std::string decode(const std::string& str) const$/;"	f	class:openvpn::Base64
decode	common/base64.hpp	/^    void decode(V& dest, const std::string& str) const$/;"	f	class:openvpn::Base64
decode	http/urlencode.hpp	/^    inline std::string decode(const std::string& encoded)$/;"	f	namespace:openvpn::URL
decode_base64_char	common/base64.hpp	/^    unsigned int decode_base64_char(const char c) const$/;"	f	class:openvpn::Base64
decode_path	http/urlencode.hpp	/^    inline std::vector<std::string> decode_path(std::string path)$/;"	f	namespace:openvpn::URL
decode_size_max	common/base64.hpp	/^    static size_t decode_size_max(const size_t encode_size)$/;"	f	class:openvpn::Base64
decompress	compress/compnull.hpp	/^    virtual void decompress(BufferAllocated& buf) {}$/;"	f	class:openvpn::CompressNull
decompress	compress/compstub.hpp	/^    virtual void decompress(BufferAllocated& buf)$/;"	f	class:openvpn::CompressStub
decompress	compress/compstub.hpp	/^    virtual void decompress(BufferAllocated& buf)$/;"	f	class:openvpn::CompressStubV2
decompress	compress/lz4.hpp	/^    virtual void decompress(BufferAllocated& buf)$/;"	f	class:openvpn::CompressLZ4
decompress	compress/lz4.hpp	/^    virtual void decompress(BufferAllocated& buf)$/;"	f	class:openvpn::CompressLZ4v2
decompress	compress/lzo.hpp	/^    virtual void decompress(BufferAllocated& buf)$/;"	f	class:openvpn::CompressLZO
decompress	compress/lzoasym.hpp	/^    virtual void decompress(BufferAllocated& buf)$/;"	f	class:openvpn::CompressLZOAsym
decompress	compress/snappy.hpp	/^    virtual void decompress(BufferAllocated& buf)$/;"	f	class:openvpn::CompressSnappy
decompress_gzip	buffer/zlib.hpp	/^    inline BufferPtr decompress_gzip(BufferPtr src,$/;"	f	namespace:openvpn::ZLib
decompress_work	compress/lzo.hpp	/^    void decompress_work(BufferAllocated& buf)$/;"	f	class:openvpn::CompressLZO
decompress_work	compress/lzoasym.hpp	/^    void decompress_work(BufferAllocated& buf)$/;"	f	class:openvpn::CompressLZOAsym
decrypt	crypto/cipher.hpp	/^    size_t decrypt(const unsigned char *iv,$/;"	f	class:openvpn::CipherContext
decrypt	crypto/crypto_aead.hpp	/^      virtual Error::Type decrypt(BufferAllocated& buf, const PacketID::time_t now, const unsigned char *op32)$/;"	f	class:openvpn::AEAD::Crypto
decrypt	crypto/crypto_chm.hpp	/^    virtual Error::Type decrypt(BufferAllocated& buf, const PacketID::time_t now, const unsigned char *op32)$/;"	f	class:openvpn::CryptoCHM
decrypt	crypto/decrypt_chm.hpp	/^    Error::Type decrypt(BufferAllocated& buf, const PacketID::time_t now)$/;"	f	class:openvpn::DecryptCHM
decrypt	openssl/crypto/ciphergcm.hpp	/^      bool decrypt(const unsigned char *input,$/;"	f	class:openvpn::OpenSSLCrypto::CipherContextGCM
decrypt	openssl/util/tokenencrypt.hpp	/^    TokenEncrypt decrypt;$/;"	m	struct:openvpn::TokenEncryptDecrypt
decrypt	polarssl/crypto/ciphergcm.hpp	/^      bool decrypt(const unsigned char *input,$/;"	f	class:openvpn::PolarSSLCrypto::CipherContextGCM
decrypt	ssl/datalimit.hpp	/^    Component decrypt;$/;"	m	class:openvpn::DataLimit
decrypt	ssl/proto.hpp	/^      void decrypt(BufferAllocated& buf)$/;"	f	class:openvpn::ProtoContext::KeyContext
decrypt_	crypto/crypto_chm.hpp	/^    DecryptCHM<CRYPTO_API> decrypt_;$/;"	m	class:openvpn::CryptoCHM
decrypt_red_limit	ssl/datalimit.hpp	/^      size_type decrypt_red_limit = 0;$/;"	m	struct:openvpn::DataLimit::Parameters
default_key_direction	client/cliopt.hpp	/^      int default_key_direction = -1;$/;"	m	struct:openvpn::ClientOptions::Config
default_port	http/urlparse.hpp	/^      void default_port()$/;"	f	class:openvpn::URL::Parse
defined	addr/ip.hpp	/^      bool defined() const$/;"	f	class:openvpn::IP::Addr
defined	addr/range.hpp	/^      const bool defined() const { return extent_ > 0; }$/;"	f	class:openvpn::IP::RangeType
defined	applecrypto/cf/cf.hpp	/^      bool defined() const { return obj_ != nullptr; }$/;"	f	class:openvpn::CF::Wrap
defined	auth/authcert.hpp	/^      bool defined() const$/;"	f	struct:openvpn::AuthCert
defined	auth/authcreds.hpp	/^      bool defined() const$/;"	f	class:openvpn::AuthCreds
defined	buffer/bufcomplete.hpp	/^    bool defined() const$/;"	f	class:openvpn::BufferComplete
defined	buffer/buffer.hpp	/^    bool defined() const { return size_ > 0; }$/;"	f	class:openvpn::BufferType
defined	client/remotelist.hpp	/^    bool defined() const { return list.size() > 0; }$/;"	f	class:openvpn::RemoteList
defined	common/circ_list.hpp	/^    bool defined() const$/;"	f	class:openvpn::CircList
defined	common/hostlist.hpp	/^      bool defined() const$/;"	f	struct:openvpn::HostList::Host
defined	common/redir.hpp	/^      bool defined() const$/;"	f	class:openvpn::RedirectPipe::SD
defined	common/scoped_asio_stream.hpp	/^    bool defined() const$/;"	f	class:openvpn::ScopedAsioStream
defined	common/scoped_fd.hpp	/^    bool defined() const$/;"	f	class:openvpn::ScopedFD
defined	crypto/cipher.hpp	/^    bool defined() const { return ctx.is_initialized(); }$/;"	f	class:openvpn::CipherContext
defined	crypto/crypto_aead.hpp	/^      virtual unsigned int defined() const$/;"	f	class:openvpn::AEAD::Crypto
defined	crypto/crypto_chm.hpp	/^    virtual unsigned int defined() const$/;"	f	class:openvpn::CryptoCHM
defined	crypto/cryptoalgs.hpp	/^    inline bool defined(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
defined	crypto/ovpnhmac.hpp	/^    bool defined() const { return ctx.is_initialized(); }$/;"	f	class:openvpn::OvpnHMAC
defined	crypto/static_key.hpp	/^    bool defined() const { return key_data_.defined(); }$/;"	f	class:openvpn::OpenVPNStaticKey
defined	log/logperiod.hpp	/^    bool defined() const$/;"	f	class:openvpn::LogPeriod
defined	log/logthread.hpp	/^      static bool defined()$/;"	f	struct:openvpn::Log::Context
defined	openssl/pki/crl.hpp	/^      bool defined() const { return !empty(); }$/;"	f	class:openvpn::OpenSSLPKI::CRLList
defined	openssl/pki/crl.hpp	/^      bool defined() const { return crl_ != nullptr; }$/;"	f	class:openvpn::OpenSSLPKI::CRL
defined	openssl/pki/dh.hpp	/^      bool defined() const { return dh_ != nullptr; }$/;"	f	class:openvpn::OpenSSLPKI::DH
defined	openssl/pki/pkey.hpp	/^      bool defined() const { return pkey_ != nullptr; }$/;"	f	class:openvpn::OpenSSLPKI::PKey
defined	openssl/pki/x509.hpp	/^      bool defined() const { return !empty(); }$/;"	f	class:openvpn::OpenSSLPKI::X509List
defined	openssl/pki/x509.hpp	/^      bool defined() const { return x509_ != nullptr; }$/;"	f	class:openvpn::OpenSSLPKI::X509Base
defined	reliable/relcommon.hpp	/^    bool defined() const { return bool(packet); }$/;"	f	class:openvpn::ReliableMessageBase
defined	server/servproto.hpp	/^      virtual bool defined() const$/;"	f	class:openvpn::ServerProto::Session
defined	server/vpnservnetblock.hpp	/^      bool defined() const { return net.defined(); }$/;"	f	struct:openvpn::VPNServerNetblock::Netblock
defined	server/vpnservpool.hpp	/^      bool defined() const$/;"	f	struct:openvpn::VPNServerPool::IP46
defined	ssl/psid.hpp	/^    bool defined() const { return defined_; }$/;"	f	class:openvpn::ProtoSessionID
defined	time/time.hpp	/^      bool defined() const { return duration_ != T(0); }$/;"	f	class:openvpn::TimeType::Duration
defined	time/time.hpp	/^    bool defined() const { return time_ != 0; }$/;"	f	class:openvpn::TimeType
defined	transport/protocol.hpp	/^    bool defined() const { return type_ != NONE; }$/;"	f	class:openvpn::Protocol
defined	tun/builder/capture.hpp	/^      bool defined() const {$/;"	f	class:openvpn::TunBuilderCapture::ProxyAutoConfigURL
defined	tun/builder/capture.hpp	/^      bool defined() const {$/;"	f	class:openvpn::TunBuilderCapture::ProxyHostPort
defined	tun/builder/capture.hpp	/^      bool defined() const$/;"	f	class:openvpn::TunBuilderCapture::ProxyBypass
defined	tun/builder/capture.hpp	/^      bool defined() const$/;"	f	class:openvpn::TunBuilderCapture::RemoteAddress
defined	tun/layer.hpp	/^    bool defined() const$/;"	f	class:openvpn::Layer
defined	tun/mac/macgw.hpp	/^      bool defined() const {$/;"	f	struct:openvpn::MacGWInfo::Variant
defined	tun/win/tunutil.hpp	/^	bool defined() const$/;"	f	class:openvpn::TunWin::Util::DefaultGateway
defined	tun/win/tunutil.hpp	/^	bool defined;$/;"	m	class:openvpn::TunWin::Util::TAPDriverVersion
defined	tun/win/wfp.hpp	/^	bool defined() const$/;"	f	class:openvpn::TunWin::WFP::WFPEngine
defined	win/handle.hpp	/^      inline bool defined(HANDLE handle)$/;"	f	namespace:openvpn::Win::Handle
defined	win/reg.hpp	/^      bool defined() const { return key != nullptr; }$/;"	f	class:openvpn::Win::RegKey
defined	win/scoped_handle.hpp	/^      bool defined() const$/;"	f	class:openvpn::Win::ScopedHANDLE
defined_	server/servproto.hpp	/^      bool defined_() const$/;"	f	class:openvpn::ServerProto::Session
defined_	ssl/psid.hpp	/^    bool defined_;$/;"	m	class:openvpn::ProtoSessionID
defined_static	common/scoped_asio_stream.hpp	/^    static bool defined_static(STREAM* obj)$/;"	f	class:openvpn::ScopedAsioStream
defined_static	common/scoped_fd.hpp	/^    static bool defined_static(int fd)$/;"	f	class:openvpn::ScopedFD
del	common/argv.hpp	/^    void del()$/;"	f	class:openvpn::ArgvWrapper
del	common/tempfile.hpp	/^    bool del;$/;"	m	class:openvpn::TempFile
delete_	buffer/buffer.hpp	/^    static void delete_(T* data, const size_t size, const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
delete_file	common/tempfile.hpp	/^    void delete_file()$/;"	f	class:openvpn::TempFile
delete_rule	tun/win/nrpt.hpp	/^      static bool delete_rule()$/;"	f	class:openvpn::TunWin::NRPT
delete_value	tun/mac/macdns.hpp	/^      CF::String delete_value() const$/;"	f	class:openvpn::MacDNS::DSDict
delta	common/action.hpp	/^      size_t delta;$/;"	m	class:openvpn::ActionList::Iter
delta	time/time.hpp	/^    long delta(const TimeType& t) const$/;"	f	class:openvpn::TimeType
delta_prec	time/time.hpp	/^    long delta_prec(const TimeType& t) const$/;"	f	class:openvpn::TimeType
depth	pki/x509track.hpp	/^      int depth = 0;$/;"	m	struct:openvpn::X509Track::KeyValue
depth_match	pki/x509track.hpp	/^      bool depth_match(const int depth) const$/;"	f	struct:openvpn::X509Track::Config
descend	addr/routeinv.hpp	/^      void descend(const RouteList& in, const Addr::Version ver, const Route& route)$/;"	f	class:openvpn::IP::RouteInverter
description	applecrypto/cf/cf.hpp	/^    inline std::string description(CFTypeRef obj)$/;"	f	namespace:openvpn::CF
dest	ip/udp.hpp	/^    std::uint16_t   dest;$/;"	m	struct:openvpn::UDPHeader
dest_mac	ip/eth.hpp	/^    std::uint8_t   dest_mac[6];$/;"	m	struct:openvpn::EthHeader
destruct	common/function.hpp	/^      static void destruct(void *ptr)$/;"	f	class:openvpn::Function::Intern
destruct	common/function.hpp	/^      void (*destruct)(void *);$/;"	m	struct:openvpn::Function::Methods
destruct_	tun/persist/tunwrap.hpp	/^    DestructorBase::Ptr destruct_;$/;"	m	class:openvpn::TunWrapTemplate
destructor_defined	tun/persist/tunwrap.hpp	/^    bool destructor_defined() const$/;"	f	class:openvpn::TunWrapTemplate
detect_multiline_breakout	common/options.hpp	/^    static void detect_multiline_breakout(const std::string& opt, const std::string& tag)$/;"	f	class:openvpn::OptionList
detect_multiline_breakout_nothrow	common/options.hpp	/^    static bool detect_multiline_breakout_nothrow(const std::string& opt, const std::string& tag)$/;"	f	class:openvpn::OptionList
dev_name	tun/linux/client/tuncli.hpp	/^      std::string dev_name;$/;"	m	class:openvpn::TunLinux::ClientConfig
dev_type	tun/layer.hpp	/^    const char *dev_type() const$/;"	f	class:openvpn::Layer
dev_urandom	random/devurand.hpp	/^    ScopedFD dev_urandom;$/;"	m	class:openvpn::DevURand
dh	openssl/ssl/sslctx.hpp	/^      OpenSSLPKI::DH dh;                \/\/ diffie-hellman parameters (only needed in server mode)$/;"	m	class:openvpn::OpenSSLContext::Config
dh	polarssl/ssl/sslctx.hpp	/^      PolarSSLPKI::DH::Ptr dh;               \/\/ diffie-hellman parameters (only needed in server mode)$/;"	m	class:openvpn::PolarSSLContext::Config
dh_	openssl/pki/dh.hpp	/^      ::DH *dh_;$/;"	m	class:openvpn::OpenSSLPKI::DH
dhc	polarssl/pki/dh.hpp	/^      dhm_context *dhc;$/;"	m	class:openvpn::PolarSSLPKI::DH
dhcp	ip/dhcp.hpp	/^    DHCP dhcp;$/;"	m	struct:openvpn::DHCPPacket
dhcp_capture	tun/win/client/tuncli.hpp	/^      std::unique_ptr<DHCPCapture> dhcp_capture;$/;"	m	class:openvpn::TunWin::Client
dhcp_inspect	tun/win/client/tuncli.hpp	/^      void dhcp_inspect(Buffer& buf)$/;"	f	class:openvpn::TunWin::Client
dhcp_message_type	tun/client/dhcp_capture.hpp	/^    static int dhcp_message_type(const DHCPPacket* dhcp, const unsigned int optlen)$/;"	f	class:openvpn::DHCPCapture
dhcp_release	tun/win/tunutil.hpp	/^      inline void dhcp_release(const InterfaceInfoList& ii,$/;"	f	namespace:openvpn::TunWin::Util
dhcp_renew	tun/win/tunutil.hpp	/^      inline void dhcp_renew(const InterfaceInfoList& ii,$/;"	f	namespace:openvpn::TunWin::Util
dhcp_serv_addr	tun/win/tunutil.hpp	/^	IPv4::Addr dhcp_serv_addr = IPv4::Addr::from_zero();$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
dict	applecrypto/cf/cf.hpp	/^    inline Dict dict(const SrcList& keys, const SrcList& values)$/;"	f	namespace:openvpn::CF
dict	applecrypto/cf/cf.hpp	/^    inline Dict dict(const void **keys, const void **values, CFIndex numValues)$/;"	f	namespace:openvpn::CF
dict	tun/mac/macdns.hpp	/^      const CF::Dict dict;$/;"	m	class:openvpn::MacDNS::DSDict
dict_get_bool	applecrypto/cf/cfhelper.hpp	/^    inline bool dict_get_bool(const DICT& dict, const KEY& key, const bool default_value)$/;"	f	namespace:openvpn::CF
dict_get_create	applecrypto/cf/cfhelper.hpp	/^    inline CFTypeRef dict_get_create(CFMutableDictionaryRef base,$/;"	f	namespace:openvpn::CF
dict_get_create_array	applecrypto/cf/cfhelper.hpp	/^    inline MutableArray dict_get_create_array(MutableDict& base, const KEY& key)$/;"	f	namespace:openvpn::CF
dict_get_create_dict	applecrypto/cf/cfhelper.hpp	/^    inline MutableDict dict_get_create_dict(MutableDict& base, const KEY& key)$/;"	f	namespace:openvpn::CF
dict_get_int	applecrypto/cf/cfhelper.hpp	/^    inline int dict_get_int(const DICT& dict, const KEY& key, const int default_value)$/;"	f	namespace:openvpn::CF
dict_get_obj	applecrypto/cf/cfhelper.hpp	/^    inline CFTypeRef dict_get_obj(const DICT& dict, const KEY& key)$/;"	f	namespace:openvpn::CF
dict_get_str	applecrypto/cf/cfhelper.hpp	/^    inline std::string dict_get_str(const DICT& dict, const KEY& key)$/;"	f	namespace:openvpn::CF
dict_get_str	applecrypto/cf/cfhelper.hpp	/^    inline std::string dict_get_str(const DICT& dict, const KEY& key, const std::string& default_value)$/;"	f	namespace:openvpn::CF
dict_index	applecrypto/cf/cf.hpp	/^    inline CFTypeRef dict_index(const DICT& dict, const KEY& key)$/;"	f	namespace:openvpn::CF
dict_len	applecrypto/cf/cf.hpp	/^    inline CFIndex dict_len(const DICT& dict)$/;"	f	namespace:openvpn::CF
dict_set_bool	applecrypto/cf/cfhelper.hpp	/^    inline void dict_set_bool(MutableDict& dict, const KEY& key, bool value)$/;"	f	namespace:openvpn::CF
dict_set_index	applecrypto/cf/cfhelper.hpp	/^    inline void dict_set_index(MutableDict& dict, const KEY& key, CFIndex value)$/;"	f	namespace:openvpn::CF
dict_set_int	applecrypto/cf/cfhelper.hpp	/^    inline void dict_set_int(MutableDict& dict, const KEY& key, int value)$/;"	f	namespace:openvpn::CF
dict_set_int32	applecrypto/cf/cfhelper.hpp	/^    inline void dict_set_int32(MutableDict& dict, const KEY& key, SInt32 value)$/;"	f	namespace:openvpn::CF
dict_set_long_long	applecrypto/cf/cfhelper.hpp	/^    inline void dict_set_long_long(MutableDict& dict, const KEY& key, long long value)$/;"	f	namespace:openvpn::CF
dict_set_obj	applecrypto/cf/cfhelper.hpp	/^    inline void dict_set_obj(MutableDict& dict, const KEY& key, CFTypeRef value)$/;"	f	namespace:openvpn::CF
dict_set_str	applecrypto/cf/cfhelper.hpp	/^    inline void dict_set_str(MutableDict& dict, const KEY& key, const VALUE& value)$/;"	f	namespace:openvpn::CF
dictionarySetValue	applecrypto/cf/cfhelper.hpp	/^    inline void dictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)$/;"	f	namespace:openvpn::CF
did_client_halt_restart	server/servproto.hpp	/^      bool did_client_halt_restart;$/;"	m	class:openvpn::ServerProto::Session
did_push	server/servproto.hpp	/^      bool did_push;$/;"	m	class:openvpn::ServerProto::Session
did_redirect_gw	netconf/linux/route.hpp	/^    bool did_redirect_gw;$/;"	m	class:openvpn::RouteListLinux
did_replace_password_with_session_id	client/clicreds.hpp	/^    bool did_replace_password_with_session_id;$/;"	m	class:openvpn::ClientCreds
digest	crypto/crypto_chm.hpp	/^    CryptoAlgs::Type digest;$/;"	m	class:openvpn::CryptoCHM
digest	crypto/crypto_chm.hpp	/^    CryptoAlgs::Type digest;$/;"	m	class:openvpn::CryptoContextCHM
digest	crypto/cryptodc.hpp	/^    CryptoAlgs::Type digest() const { return digest_; }$/;"	f	class:openvpn::CryptoDCSettings
digest	crypto/digestapi.hpp	/^    CryptoAlgs::Type digest;$/;"	m	class:openvpn::CryptoDigestContext
digest	crypto/ovpnhmac.hpp	/^    CryptoAlgs::Type digest;$/;"	m	class:openvpn::CryptoOvpnHMACContext
digest	crypto/ovpnhmac.hpp	/^    typename CryptoAlgs::Type digest;$/;"	m	class:openvpn::CryptoOvpnHMACInstance
digest_	crypto/cryptodc.hpp	/^    CryptoAlgs::Type digest_;$/;"	m	class:openvpn::CryptoDCSettings
digest_alg	applecrypto/crypto/digest.hpp	/^      const DigestAlgorithm* digest_alg() const { return digest_alg_; }$/;"	f	class:openvpn::AppleCrypto::DigestInfo
digest_alg_	applecrypto/crypto/digest.hpp	/^      const DigestAlgorithm* digest_alg_;$/;"	m	class:openvpn::AppleCrypto::DigestInfo
digest_auth	transport/client/httpcli.hpp	/^      void digest_auth(HTTPProxy::ProxyAuthenticate& pa)$/;"	f	class:openvpn::HTTPProxyTransport::Client
digest_factory	transport/altproxy.hpp	/^      DigestFactory::Ptr digest_factory;$/;"	m	struct:openvpn::AltProxy::Config
digest_factory	transport/client/httpcli.hpp	/^      DigestFactory::Ptr digest_factory; \/\/ needed by proxy auth methods$/;"	m	class:openvpn::HTTPProxyTransport::ClientConfig
digest_size_	applecrypto/crypto/hmac.hpp	/^      size_t digest_size_;$/;"	m	class:openvpn::AppleCrypto::HMACContext
digest_type	applecrypto/crypto/digest.hpp	/^      static const DigestInfo *digest_type(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::AppleCrypto::DigestContext
digest_type	openssl/crypto/digest.hpp	/^      static const EVP_MD *digest_type(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
digest_type	polarssl/crypto/digest.hpp	/^      static const md_info_t *digest_type(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
directive	server/listenlist.hpp	/^      std::string directive;$/;"	m	struct:openvpn::Listen::Item
directives	client/remotelist.hpp	/^    Directives directives;$/;"	m	class:openvpn::RemoteList
dirname	common/path.hpp	/^    inline std::string dirname(const std::string& path)$/;"	f	namespace:openvpn::path
dirsep	common/path.hpp	/^      const char dirsep[] = "\\\\\/"; \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::path::__anon22
dirty	crypto/cryptodc.hpp	/^    bool dirty;$/;"	m	class:openvpn::CryptoDCSettings
dirty	ssl/proto.hpp	/^      bool dirty;$/;"	m	class:openvpn::ProtoContext::KeyContext
dirty	tun/mac/macdns.hpp	/^      bool dirty() const$/;"	f	class:openvpn::MacDNS::DSDict
disable_client_cert	client/cliopt.hpp	/^      bool disable_client_cert = false;$/;"	m	struct:openvpn::ClientOptions::Config
disable_keepalive	client/cliproto.hpp	/^      virtual void disable_keepalive(unsigned int& keepalive_ping,$/;"	f	class:openvpn::ClientProto::Session
disable_keepalive	server/servproto.hpp	/^      virtual void disable_keepalive(unsigned int& keepalive_ping,$/;"	f	class:openvpn::ServerProto::Session
disable_keepalive	ssl/proto.hpp	/^    void disable_keepalive(unsigned int& keepalive_ping,$/;"	f	class:openvpn::ProtoContext
disable_nbt	tun/win/tunutil.hpp	/^	bool disable_nbt = false;      \/\/ DISABLE_NBT (43, Vendor option 001)$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
disarm	common/autoreset.hpp	/^    void disarm()$/;"	f	class:openvpn::AutoReset
disconnect	ssl/proto.hpp	/^    void disconnect(const Error::Type reason)$/;"	f	class:openvpn::ProtoContext
disconnect	tun/persist/tunpersist.hpp	/^    bool disconnect;$/;"	m	class:openvpn::TunPersistTemplate
disconnect_at	server/servproto.hpp	/^      Time disconnect_at;$/;"	m	class:openvpn::ServerProto::Session
disconnect_in	server/servproto.hpp	/^      void disconnect_in(const Time::Duration& dur)$/;"	f	class:openvpn::ServerProto::Session
div	addr/ipv6.hpp	/^      static void div(const Addr& n, const Addr& d, Addr& q, Addr& r)$/;"	f	class:openvpn::IPv6::Addr
dns	tun/mac/macdns.hpp	/^      DSDict dns;  \/\/ we may modify$/;"	m	class:openvpn::MacDNS::Info
dns	tun/win/tunutil.hpp	/^	std::vector<IPv4::Addr> dns;   \/\/ DNS (6)$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
dns_servers	tun/builder/capture.hpp	/^    std::vector<DNSServer> dns_servers;    \/\/ VPN DNS servers$/;"	m	class:openvpn::TunBuilderCapture
dns_servers	tun/mac/macdns.hpp	/^      CF::Array dns_servers;$/;"	m	class:openvpn::MacDNS::Config
dns_servers	tun/win/nrpt.hpp	/^	const std::vector<std::string> dns_servers;$/;"	m	class:openvpn::TunWin::NRPT::ActionCreate
do_compress	compress/lz4.hpp	/^    bool do_compress(BufferAllocated& buf)$/;"	f	class:openvpn::CompressLZ4Base
do_decompress	compress/lz4.hpp	/^    bool do_decompress(BufferAllocated& buf)$/;"	f	class:openvpn::CompressLZ4Base
do_encrypt	ssl/proto.hpp	/^      bool do_encrypt(BufferAllocated& buf, const bool compress_hint)$/;"	f	class:openvpn::ProtoContext::KeyContext
do_parse	proxy/proxyauth.hpp	/^      void do_parse(const std::string& line)$/;"	f	class:openvpn::HTTPProxy::ProxyAuthenticate
do_resolve_	transport/client/httpcli.hpp	/^      void do_resolve_(const asio::error_code& error,$/;"	f	class:openvpn::HTTPProxyTransport::Client
do_resolve_	transport/client/tcpcli.hpp	/^      void do_resolve_(const asio::error_code& error,$/;"	f	class:openvpn::TCPTransport::Client
do_resolve_	transport/client/udpcli.hpp	/^      void do_resolve_(const asio::error_code& error,$/;"	f	class:openvpn::UDPTransport::Client
do_send	transport/udplink.hpp	/^      int do_send(const Buffer& buf, const AsioEndpoint* endpoint)$/;"	f	class:openvpn::UDPTransport::Link
do_swap	compress/compress.hpp	/^    void do_swap(Buffer& buf, unsigned char op)$/;"	f	class:openvpn::Compress
do_test_add	crypto/packet_id.hpp	/^    Error::Type do_test_add(const PacketID& pin,$/;"	f	class:openvpn::PacketIDReceiveType
do_unswap	compress/compress.hpp	/^    void do_unswap(Buffer& buf)$/;"	f	class:openvpn::Compress
doinit	client/rgopt.hpp	/^    void doinit(const OptionList& opt, const std::string& directive, const bool redirect_gateway)$/;"	f	class:openvpn::RedirectGatewayFlags
domain	tun/builder/capture.hpp	/^      std::string domain;$/;"	m	class:openvpn::TunBuilderCapture::SearchDomain
domain	tun/win/tunutil.hpp	/^	std::string domain;            \/\/ DOMAIN (15)$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
dont_restart	client/cliconnect.hpp	/^    void dont_restart()$/;"	f	class:openvpn::ClientConnect
dont_restart_	client/cliconnect.hpp	/^    bool dont_restart_;$/;"	m	class:openvpn::ClientConnect
down_stack_app	ssl/protostack.hpp	/^    void down_stack_app()$/;"	f	class:openvpn::ProtoStackBase
down_stack_raw	ssl/protostack.hpp	/^    void down_stack_raw()$/;"	f	class:openvpn::ProtoStackBase
drain_content_length	transport/client/httpcli.hpp	/^      size_t drain_content_length;$/;"	m	class:openvpn::HTTPProxyTransport::Client
drain_html	transport/client/httpcli.hpp	/^      void drain_html(BufferAllocated& buf)$/;"	f	class:openvpn::HTTPProxyTransport::Client
ds_create	tun/mac/macdns.hpp	/^    CF::DynamicStore ds_create() const$/;"	f	class:openvpn::MacDNS
dskey	tun/mac/macdns.hpp	/^      const std::string dskey;$/;"	m	class:openvpn::MacDNS::DSDict
dskey_array	tun/mac/macdns.hpp	/^    CF::Array dskey_array() const$/;"	f	class:openvpn::MacDNS
dstore	apple/maclife.hpp	/^    CF::DynamicStore dstore;$/;"	m	class:openvpn::MacLifeCycle
dump	ssl/tlsprf.hpp	/^    std::string dump(const char *title)$/;"	f	class:openvpn::TLSPRF
dump_hex	common/hexstr.hpp	/^  inline std::string dump_hex(const V& data)$/;"	f	namespace:openvpn
dump_hex	common/hexstr.hpp	/^  inline std::string dump_hex(const std::string& str)$/;"	f	namespace:openvpn
dump_hex	common/hexstr.hpp	/^  inline std::string dump_hex(const unsigned char *data, size_t size)$/;"	f	namespace:openvpn
dump_packet	ssl/proto.hpp	/^    std::string dump_packet(const Buffer& buf)$/;"	f	class:openvpn::ProtoContext
dup	openssl/pki/crl.hpp	/^      static X509_CRL *dup(const X509_CRL *crl)$/;"	f	class:openvpn::OpenSSLPKI::CRL
dup	openssl/pki/dh.hpp	/^      inline ::DH *dup(const ::DH *dh)$/;"	f	namespace:openvpn::OpenSSLPKI::DH_private
dup	openssl/pki/pkey.hpp	/^      static EVP_PKEY *dup(const EVP_PKEY *pkey)$/;"	f	class:openvpn::OpenSSLPKI::PKey
dup	openssl/pki/x509.hpp	/^      static ::X509 *dup(const ::X509 *x509)$/;"	f	class:openvpn::OpenSSLPKI::X509Base
dur	transport/gremlin.hpp	/^      Time::Duration dur;$/;"	m	struct:openvpn::Gremlin::DelayedQueue
duration	time/asiotimer.hpp	/^    typedef std::chrono::duration<rep, period> duration;$/;"	t	struct:openvpn::AsioClock
duration_	time/time.hpp	/^      T duration_;$/;"	m	class:openvpn::TimeType::Duration
dwMilliseconds	win/sleep.hpp	/^    DWORD dwMilliseconds;$/;"	m	class:openvpn::WinSleep
dynamic_challenge	client/clicreds.hpp	/^    ChallengeResponse::Ptr dynamic_challenge;$/;"	m	class:openvpn::ClientCreds
e	crypto/crypto_aead.hpp	/^      Encrypt e;$/;"	m	class:openvpn::AEAD::Crypto
e16	common/endian.hpp	/^    inline size_t e16(const size_t v)$/;"	f	namespace:openvpn::Endian
e16rev	common/endian.hpp	/^    inline size_t e16rev(const size_t v)$/;"	f	namespace:openvpn::Endian
e2	common/endian.hpp	/^    inline size_t e2(const size_t v)$/;"	f	namespace:openvpn::Endian
e2rev	common/endian.hpp	/^    inline size_t e2rev(const size_t v)$/;"	f	namespace:openvpn::Endian
e4	common/endian.hpp	/^    inline size_t e4(const size_t v)$/;"	f	namespace:openvpn::Endian
e4rev	common/endian.hpp	/^    inline size_t e4rev(const size_t v)$/;"	f	namespace:openvpn::Endian
echo	auth/cr.hpp	/^    bool echo;$/;"	m	class:openvpn::ChallengeResponse
echo	client/cliopt.hpp	/^      bool echo = false;$/;"	m	struct:openvpn::ClientOptions::Config
echo	client/cliopt.hpp	/^    bool echo;$/;"	m	class:openvpn::ClientOptions
echo	client/cliproto.hpp	/^	bool echo = false;$/;"	m	struct:openvpn::ClientProto::Session::Config
echo	client/cliproto.hpp	/^      bool echo;$/;"	m	class:openvpn::ClientProto::Session
echo	ip/icmp.hpp	/^      } echo;$/;"	m	union:openvpn::ICMP::__anon48	typeref:struct:openvpn::ICMP::__anon48::__anon49
eer_factory	tun/builder/client.hpp	/^      EmulateExcludeRouteFactory::Ptr eer_factory;$/;"	m	class:openvpn::TunBuilderClient::ClientConfig
ei	applecrypto/util/iosactiveiface.hpp	/^    EnumIface ei;$/;"	m	class:openvpn::iOSActiveInterface
eku	openssl/ssl/sslctx.hpp	/^      std::string eku;              \/\/ if defined, peer cert X509 extended key usage must match this OID\/string$/;"	m	class:openvpn::OpenSSLContext::Config
eku	polarssl/ssl/sslctx.hpp	/^      std::string eku;              \/\/ if defined, peer cert X509 extended key usage must match this OID\/string$/;"	m	class:openvpn::PolarSSLContext::Config
element_type	common/rc.hpp	/^    typedef T element_type;$/;"	t	class:openvpn::RCPtr
element_type	common/rc.hpp	/^    typedef T element_type;$/;"	t	class:openvpn::RCWeakPtr
elgible	ssl/datalimit.hpp	/^    State elgible(const Mode mode, const State state)$/;"	f	class:openvpn::DataLimit
embeddedPassword	client/cliopthelper.hpp	/^    const std::string& embeddedPassword() const { return embeddedPassword_; }$/;"	f	class:openvpn::ParseClientConfig
embeddedPassword_	client/cliopthelper.hpp	/^    std::string embeddedPassword_;$/;"	m	class:openvpn::ParseClientConfig
embedded_null	common/string.hpp	/^    inline bool embedded_null(const char *str, size_t len)$/;"	f	namespace:openvpn::string
empty	buffer/buffer.hpp	/^    bool empty() const { return !size_; }$/;"	f	class:openvpn::BufferType
empty	buffer/memq.hpp	/^    bool empty() const$/;"	f	class:openvpn::MemQBase
empty	buffer/safestr.hpp	/^    const bool empty() const$/;"	f	class:openvpn::SafeString
empty	common/options.hpp	/^    bool empty() const { return data.empty(); }$/;"	f	class:openvpn::Option
empty	reliable/relack.hpp	/^    bool empty() const         { return data.empty(); }$/;"	f	class:openvpn::ReliableAck
empty_dict	applecrypto/cf/cf.hpp	/^    inline Dict empty_dict()$/;"	f	namespace:openvpn::CF
emulate	client/cliemuexr.hpp	/^    virtual void emulate(TunBuilderBase* tb, IPVerFlags& ipv, const IP::Addr& server_addr) const$/;"	f	class:openvpn::EmulateExcludeRouteImpl
enable	tun/win/wfp.hpp	/^      const bool enable;$/;"	m	class:openvpn::TunWin::ActionWFP
enable_cache	client/remotelist.hpp	/^    bool enable_cache;$/;"	m	class:openvpn::RemoteList
enable_destroy	common/action.hpp	/^    void enable_destroy(const bool state)$/;"	f	class:openvpn::ActionList
enable_destroy_	common/action.hpp	/^    bool enable_destroy_ = false;$/;"	m	class:openvpn::ActionList
enable_log_history	common/runcontext.hpp	/^    void enable_log_history()$/;"	f	class:openvpn::RunContext
enable_op32	ssl/proto.hpp	/^      bool enable_op32 = false;$/;"	m	class:openvpn::ProtoContext::Config
enable_op32	ssl/proto.hpp	/^      bool enable_op32;$/;"	m	class:openvpn::ProtoContext::KeyContext
enable_password_cache	client/clicreds.hpp	/^    void enable_password_cache(const bool value)$/;"	f	class:openvpn::ClientCreds
enable_persistence_	tun/persist/tunpersist.hpp	/^    const bool enable_persistence_;$/;"	m	class:openvpn::TunPersistTemplate
enable_renegotiation	openssl/ssl/sslctx.hpp	/^      bool enable_renegotiation;$/;"	m	class:openvpn::OpenSSLContext::Config
enable_renegotiation	polarssl/ssl/sslctx.hpp	/^      bool enable_renegotiation;$/;"	m	class:openvpn::PolarSSLContext::Config
enabled	client/cliemuexr.hpp	/^    virtual bool enabled(const IPVerFlags& ipv) const$/;"	f	class:openvpn::EmulateExcludeRouteImpl
enabled	time/time.hpp	/^      bool enabled() const { return defined() && !is_infinite(); }$/;"	f	class:openvpn::TimeType::Duration
enabled	tun/win/client/tunsetup.hpp	/^	static bool enabled(const TunBuilderCapture::DNSServer& ds,$/;"	f	class:openvpn::TunWin::Setup::UseDNS
enc	common/base64.hpp	/^    unsigned char enc[64];$/;"	m	class:openvpn::Base64
encap_overhead	crypto/crypto_aead.hpp	/^      virtual size_t encap_overhead() const$/;"	f	class:openvpn::AEAD::CryptoContext
encap_overhead	crypto/crypto_chm.hpp	/^    virtual size_t encap_overhead() const$/;"	f	class:openvpn::CryptoContextCHM
encapsulate	ssl/proto.hpp	/^      void encapsulate(id_t id, Packet& pkt) \/\/ called by ProtoStackBase$/;"	f	class:openvpn::ProtoContext::KeyContext
encode	common/base64.hpp	/^    std::string encode(const V& data) const$/;"	f	class:openvpn::Base64
encode	common/base64.hpp	/^    std::string encode(const unsigned char *data, size_t size) const$/;"	f	class:openvpn::Base64
encode	http/urlencode.hpp	/^    inline std::string encode(const std::string& str)$/;"	f	namespace:openvpn::URL
encode_size_max	common/base64.hpp	/^    static size_t encode_size_max(const size_t decode_size)$/;"	f	class:openvpn::Base64
encrypt	crypto/cipher.hpp	/^    size_t encrypt(const unsigned char *iv,$/;"	f	class:openvpn::CipherContext
encrypt	crypto/crypto_aead.hpp	/^      virtual bool encrypt(BufferAllocated& buf, const PacketID::time_t now, const unsigned char *op32)$/;"	f	class:openvpn::AEAD::Crypto
encrypt	crypto/crypto_chm.hpp	/^    virtual bool encrypt(BufferAllocated& buf, const PacketID::time_t now, const unsigned char *op32)$/;"	f	class:openvpn::CryptoCHM
encrypt	crypto/encrypt_chm.hpp	/^    void encrypt(BufferAllocated& buf, const PacketID::time_t now)$/;"	f	class:openvpn::EncryptCHM
encrypt	openssl/crypto/ciphergcm.hpp	/^      void encrypt(const unsigned char *input,$/;"	f	class:openvpn::OpenSSLCrypto::CipherContextGCM
encrypt	openssl/util/tokenencrypt.hpp	/^    TokenEncrypt encrypt;$/;"	m	struct:openvpn::TokenEncryptDecrypt
encrypt	polarssl/crypto/ciphergcm.hpp	/^      void encrypt(const unsigned char *input,$/;"	f	class:openvpn::PolarSSLCrypto::CipherContextGCM
encrypt	ssl/datalimit.hpp	/^    Component encrypt;$/;"	m	class:openvpn::DataLimit
encrypt	ssl/proto.hpp	/^      void encrypt(BufferAllocated& buf)$/;"	f	class:openvpn::ProtoContext::KeyContext
encrypt_	crypto/crypto_chm.hpp	/^    EncryptCHM<CRYPTO_API> encrypt_;$/;"	m	class:openvpn::CryptoCHM
encrypt_decrypt	crypto/cipher.hpp	/^    size_t encrypt_decrypt(const unsigned char *iv,$/;"	f	class:openvpn::CipherContext
encrypt_red_limit	ssl/datalimit.hpp	/^      size_type encrypt_red_limit = 0;$/;"	m	struct:openvpn::DataLimit::Parameters
end	buffer/asiobuf.hpp	/^    const asio::const_buffer* end() const { return buf + 2; }$/;"	f	class:openvpn::AsioConstBufferSeq2
end	common/action.hpp	/^      size_t end;$/;"	m	class:openvpn::ActionList::Iter
end_	log/logperiod.hpp	/^    olong end_;$/;"	m	class:openvpn::LogPeriod
endpoint_available	client/remotelist.hpp	/^    bool endpoint_available(std::string* server_host, std::string* server_port, Protocol* transport_protocol) const$/;"	f	class:openvpn::RemoteList
ends_with	common/string.hpp	/^    inline bool ends_with(const std::string& str, const char *suffix)$/;"	f	namespace:openvpn::string
ends_with	common/string.hpp	/^    inline bool ends_with(const std::string& str, const char c)$/;"	f	namespace:openvpn::string
ends_with	common/string.hpp	/^    inline bool ends_with(const std::string& str, const std::string& suffix)$/;"	f	namespace:openvpn::string
ends_with_newline	common/string.hpp	/^    inline bool ends_with_newline(const std::string& str)$/;"	f	namespace:openvpn::string
engineHandle	tun/win/wfp.hpp	/^      WFPEngine engineHandle;$/;"	m	class:openvpn::TunWin::WFP
entropy_poll	polarssl/util/rand.hpp	/^    static int entropy_poll(void *data, unsigned char *output, size_t len)$/;"	f	class:openvpn::PolarSSLRandom
enum_dir	common/enumdir.hpp	/^  inline std::vector<std::string> enum_dir(const std::string& dirname,$/;"	f	namespace:openvpn
epki	openssl/ssl/sslctx.hpp	/^    ExternalPKIImpl* epki;$/;"	m	class:openvpn::OpenSSLContext
epki_decrypt	polarssl/ssl/sslctx.hpp	/^    static int epki_decrypt(void *arg,$/;"	f	class:openvpn::PolarSSLContext
epki_key_len	polarssl/ssl/sslctx.hpp	/^    static size_t epki_key_len(void *arg)$/;"	f	class:openvpn::PolarSSLContext
epki_sign	polarssl/ssl/sslctx.hpp	/^    static int epki_sign(void *arg,$/;"	f	class:openvpn::PolarSSLContext
equal	common/base64.hpp	/^    unsigned char equal;$/;"	m	class:openvpn::Base64
equals	client/remotelist.hpp	/^      bool equals(const Index& other) const$/;"	f	class:openvpn::RemoteList::Index
erase	applecrypto/crypto/cipher.hpp	/^      void erase()$/;"	f	class:openvpn::AppleCrypto::CipherContext
erase	crypto/static_key.hpp	/^    void erase() { key_data_.clear(); }$/;"	f	class:openvpn::StaticKey
erase	crypto/static_key.hpp	/^    void erase()$/;"	f	class:openvpn::OpenVPNStaticKey
erase	openssl/crypto/cipher.hpp	/^      void erase()$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
erase	openssl/crypto/ciphergcm.hpp	/^      void erase()$/;"	f	class:openvpn::OpenSSLCrypto::CipherContextGCM
erase	openssl/crypto/digest.hpp	/^      void erase()$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
erase	openssl/crypto/hmac.hpp	/^      void erase()$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
erase	openssl/pki/crl.hpp	/^      void erase()$/;"	f	class:openvpn::OpenSSLPKI::CRL
erase	openssl/pki/dh.hpp	/^      void erase()$/;"	f	class:openvpn::OpenSSLPKI::DH
erase	openssl/pki/pkey.hpp	/^      void erase()$/;"	f	class:openvpn::OpenSSLPKI::PKey
erase	openssl/pki/x509.hpp	/^      void erase()$/;"	f	class:openvpn::OpenSSLPKI::X509
erase	openssl/ssl/sslctx.hpp	/^    void erase()$/;"	f	class:openvpn::OpenSSLContext
erase	polarssl/crypto/cipher.hpp	/^      void erase()$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
erase	polarssl/crypto/ciphergcm.hpp	/^      void erase()$/;"	f	class:openvpn::PolarSSLCrypto::CipherContextGCM
erase	polarssl/crypto/digest.hpp	/^      void erase()$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
erase	polarssl/crypto/hmac.hpp	/^      void erase()$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
erase	polarssl/ssl/sslctx.hpp	/^      void erase()$/;"	f	class:openvpn::PolarSSLContext::SSL
erase	polarssl/ssl/sslctx.hpp	/^    void erase()$/;"	f	class:openvpn::PolarSSLContext
erase	reliable/relcommon.hpp	/^    void erase()$/;"	f	class:openvpn::ReliableMessageBase
erase	ssl/tlsprf.hpp	/^    virtual void erase()$/;"	f	class:openvpn::CryptoTLSPRFInstance
erase	ssl/tlsprf.hpp	/^    void erase()$/;"	f	class:openvpn::TLSPRF
erase_	buffer/buffer.hpp	/^    void erase_()$/;"	f	class:openvpn::BufferAllocatedType
erased	reliable/relcommon.hpp	/^    bool erased() const { return erased_; }$/;"	f	class:openvpn::ReliableMessageBase
erased_	reliable/relcommon.hpp	/^    bool erased_;$/;"	m	class:openvpn::ReliableMessageBase
err	common/options.hpp	/^      const std::string err;$/;"	m	class:openvpn::OptionList::Limits
err	common/persistfile.hpp	/^    void err(const char *type)$/;"	f	class:openvpn::PersistentFile
err	common/redir.hpp	/^      std::string err;$/;"	m	struct:openvpn::RedirectPipe::InOut
err	common/redir.hpp	/^    ScopedFD err;$/;"	m	struct:openvpn::RedirectStdFD
err_	common/exception.hpp	/^    Exception(const std::string& err) noexcept : err_(err) {}$/;"	f	class:openvpn::Exception
err_	common/exception.hpp	/^    std::string err_;$/;"	m	class:openvpn::Exception
err_	error/excode.hpp	/^    std::string err_;$/;"	m	class:openvpn::ErrorCode
err_ref	common/options.hpp	/^    std::string err_ref() const$/;"	f	class:openvpn::Option
errinfo	common/asioerr.hpp	/^  inline std::string errinfo(ErrorCode err)$/;"	f	namespace:openvpn
errnum	polarssl/util/error.hpp	/^    int errnum;$/;"	m	class:openvpn::PolarSSLException
error	addr/addrpair.hpp	/^      static void error(const std::exception& e, const std::string& s, const char *title)$/;"	f	struct:openvpn::IP::AddrMaskPair
error	applecrypto/cf/cf.hpp	/^    inline Error error(CFStringRef domain, CFIndex code, CFDictionaryRef userInfo)$/;"	f	namespace:openvpn::CF
error	client/cliopthelper.hpp	/^    bool error() const { return error_; }$/;"	f	class:openvpn::ParseClientConfig
error	common/getopt.hpp	/^    inline void error(const char *prefix, const char *arg)$/;"	f	namespace:openvpn::getopt_private
error	common/getopt.hpp	/^    inline void error(const char *prefix, int arg)$/;"	f	namespace:openvpn::getopt_private
error	common/options.hpp	/^      void error()$/;"	f	class:openvpn::OptionList::Limits
error	common/pthreadcond.hpp	/^    void error()$/;"	f	class:openvpn::PThreadBarrier
error	compress/compress.hpp	/^    void error(BufferAllocated& buf)$/;"	f	class:openvpn::Compress
error	http/webexcept.hpp	/^      const std::string& error() const { return error_; }$/;"	f	class:openvpn::HTTP::WebException
error	log/sessionstats.hpp	/^    virtual void error(const size_t type, const std::string* text=nullptr) {}$/;"	f	class:openvpn::SessionStats
error	options/merge.hpp	/^    const std::string& error() const { return error_; }$/;"	f	class:openvpn::ProfileMerge
error	server/servproto.hpp	/^      void error()$/;"	f	class:openvpn::ServerProto::Session
error	server/servproto.hpp	/^      void error(const std::exception& e)$/;"	f	class:openvpn::ServerProto::Session
error	server/servproto.hpp	/^      void error(const std::string& error)$/;"	f	class:openvpn::ServerProto::Session
error	ssl/protostack.hpp	/^    void error(const Error::Type reason)$/;"	f	class:openvpn::ProtoStackBase
error_	client/cliopthelper.hpp	/^    bool error_;$/;"	m	class:openvpn::ParseClientConfig
error_	http/webexcept.hpp	/^      const std::string error_;$/;"	m	class:openvpn::HTTP::WebException
error_	options/merge.hpp	/^    std::string error_;$/;"	m	class:openvpn::ProfileMerge
errors	auth/authcert.hpp	/^	std::vector<std::string> errors;  \/\/ human-readable cert errors by depth$/;"	m	class:openvpn::AuthCert::Fail
errstack	openssl/util/error.hpp	/^    unsigned long errstack[MAX_ERRORS];$/;"	m	class:openvpn::OpenSSLException
errtxt	applecrypto/cf/error.hpp	/^    std::string errtxt;$/;"	m	class:openvpn::CFException
errtxt	openssl/util/error.hpp	/^    std::string errtxt;$/;"	m	class:openvpn::OpenSSLException
errtxt	polarssl/util/error.hpp	/^    std::string errtxt;$/;"	m	class:openvpn::PolarSSLException
escape	common/options.hpp	/^    std::string escape() const$/;"	f	class:openvpn::Option
escape_string	common/options.hpp	/^    static void escape_string(std::ostream& out, const std::string& term, const bool must_quote)$/;"	f	class:openvpn::Option
eth	ip/dhcp.hpp	/^    EthHeader eth;$/;"	m	struct:openvpn::DHCPPacket
ethertype	ip/eth.hpp	/^    std::uint16_t  ethertype;$/;"	m	struct:openvpn::EthHeader
event_loop_wait_barrier	common/waitbarrier.hpp	/^  inline void event_loop_wait_barrier(THREAD_COMMON& tc,$/;"	f	namespace:openvpn
event_name	client/clievent.hpp	/^    inline const char *event_name(const Type type)$/;"	f	namespace:openvpn::ClientEvent
event_pending	ssl/proto.hpp	/^      bool event_pending()$/;"	f	class:openvpn::ProtoContext::KeyContext
event_type_string	ssl/proto.hpp	/^      static const char *event_type_string(const EventType et)$/;"	f	class:openvpn::ProtoContext::KeyContext
events	client/cliopt.hpp	/^    ClientEvent::Queue& events() { return *cli_events; }$/;"	f	class:openvpn::ClientOptions
events	transport/gremlin.hpp	/^      std::deque<std::unique_ptr<EventBase>> events;$/;"	m	struct:openvpn::Gremlin::DelayedQueue
exact_args	common/options.hpp	/^    void exact_args(const size_t n) const$/;"	f	class:openvpn::Option
exclude	client/cliemuexr.hpp	/^    IP::RouteList exclude;$/;"	m	class:openvpn::EmulateExcludeRouteImpl
exclude_routes	tun/builder/capture.hpp	/^    std::vector<Route> exclude_routes;     \/\/ routes that should be excluded from tunnel$/;"	m	class:openvpn::TunBuilderCapture
exclude_server_address_	client/cliemuexr.hpp	/^    const bool exclude_server_address_;$/;"	m	class:openvpn::EmulateExcludeRouteFactoryImpl
exclude_server_address_	client/cliemuexr.hpp	/^    const bool exclude_server_address_;$/;"	m	class:openvpn::EmulateExcludeRouteImpl
execute	common/action.hpp	/^    virtual void execute(std::ostream& os)$/;"	f	class:openvpn::ActionList
execute	tun/mac/macdns_watchdog.hpp	/^      virtual void execute(std::ostream& os)$/;"	f	class:openvpn::MacDNSWatchdog::DNSAction
execute_log	common/action.hpp	/^    void execute_log()$/;"	f	class:openvpn::ActionList
exists	addr/addrlist.hpp	/^      bool exists(const IP::Addr& a) const$/;"	f	class:openvpn::IP::AddrList
exists	common/action.hpp	/^    bool exists(const Action::Ptr& action) const$/;"	f	class:openvpn::ActionList
exists	common/options.hpp	/^    bool exists(const std::string& name) const$/;"	f	class:openvpn::OptionList
exists	pki/x509track.hpp	/^      bool exists(const Type t) const$/;"	f	struct:openvpn::X509Track::ConfigSet
exists_unique	common/options.hpp	/^    bool exists_unique(const std::string& name) const$/;"	f	class:openvpn::OptionList
exit_sock	common/runcontext.hpp	/^    std::unique_ptr<asio::posix::stream_descriptor> exit_sock;$/;"	m	class:openvpn::RunContext
exit_timer	common/runcontext.hpp	/^    AsioTimer exit_timer;$/;"	m	class:openvpn::RunContext
expand_profile	options/merge.hpp	/^    void expand_profile(const std::string& orig_profile_content,$/;"	f	class:openvpn::ProfileMerge
expecting_newline_1	http/reply.hpp	/^	  expecting_newline_1,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
expecting_newline_1	http/request.hpp	/^	  expecting_newline_1,$/;"	e	enum:openvpn::HTTP::RequestParser::state
expecting_newline_2	http/reply.hpp	/^	  expecting_newline_2,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
expecting_newline_2	http/request.hpp	/^	  expecting_newline_2,$/;"	e	enum:openvpn::HTTP::RequestParser::state
expecting_newline_3	http/reply.hpp	/^	  expecting_newline_3$/;"	e	enum:openvpn::HTTP::ReplyParser::state
expecting_newline_3	http/request.hpp	/^	  expecting_newline_3$/;"	e	enum:openvpn::HTTP::RequestParser::state
expire	crypto/packet_id.hpp	/^    PacketID::time_t expire;        \/\/ expiration of history$/;"	m	class:openvpn::PacketIDReceiveType
expire	ssl/proto.hpp	/^      Time::Duration expire;           \/\/ KeyContext expires at this time$/;"	m	class:openvpn::ProtoContext::Config
expires_at	time/asiotimer.hpp	/^    std::size_t expires_at(const Time& t)$/;"	f	class:openvpn::AsioTimer
expires_in	log/logperiod.hpp	/^    unsigned int expires_in(const time_t now)$/;"	f	class:openvpn::LogPeriod
explicit_exit_notify	crypto/cryptodc.hpp	/^    virtual void explicit_exit_notify() {}$/;"	f	class:openvpn::CryptoDCInstance
explicit_exit_notify_message	ssl/proto.hpp	/^      const unsigned char explicit_exit_notify_message[] = {    \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::proto_context_private::__anon77
ext	common/path.hpp	/^    inline std::string ext(const std::string& basename)$/;"	f	namespace:openvpn::path
extend	common/options.hpp	/^    unsigned int extend(const OptionList& other, const std::string& name)$/;"	f	class:openvpn::OptionList
extend	common/options.hpp	/^    void extend(const OptionList& other, FilterBase* filt)$/;"	f	class:openvpn::OptionList
extend_nonexistent	common/options.hpp	/^    void extend_nonexistent(const OptionList& other)$/;"	f	class:openvpn::OptionList
extent	addr/range.hpp	/^      size_t extent() const { return extent_; }$/;"	f	class:openvpn::IP::RangeType
extent	addr/route.hpp	/^      size_t extent() const$/;"	f	struct:openvpn::IP::RouteType
extent	crypto/packet_id.hpp	/^    unsigned int extent;            \/\/ extent (in bits) of deque in history$/;"	m	class:openvpn::PacketIDReceiveType
extent_	addr/range.hpp	/^      size_t extent_;$/;"	m	class:openvpn::IP::RangeType
extent_from_netmask	addr/ip.hpp	/^      Addr extent_from_netmask() const$/;"	f	class:openvpn::IP::Addr
extent_from_netmask	addr/ipv4.hpp	/^      Addr extent_from_netmask() const$/;"	f	class:openvpn::IPv4::Addr
extent_from_netmask	addr/ipv6.hpp	/^      Addr extent_from_netmask() const$/;"	f	class:openvpn::IPv6::Addr
extent_from_netmask_uint32	addr/ipv4.hpp	/^      std::uint32_t extent_from_netmask_uint32() const$/;"	f	class:openvpn::IPv4::Addr
externalPki	client/cliopthelper.hpp	/^    bool externalPki() const { return externalPki_; }$/;"	f	class:openvpn::ParseClientConfig
externalPki_	client/cliopthelper.hpp	/^    bool externalPki_;$/;"	m	class:openvpn::ParseClientConfig
external_pki	client/cliopt.hpp	/^      ExternalPKIBase* external_pki = nullptr;$/;"	m	struct:openvpn::ClientOptions::Config
external_pki	openssl/ssl/sslctx.hpp	/^      ExternalPKIBase* external_pki;$/;"	m	class:openvpn::OpenSSLContext::Config
external_pki	openssl/ssl/sslctx.hpp	/^      ExternalPKIBase* external_pki;$/;"	m	class:openvpn::OpenSSLContext::ExternalPKIImpl
external_pki	polarssl/ssl/sslctx.hpp	/^      ExternalPKIBase* external_pki;$/;"	m	class:openvpn::PolarSSLContext::Config
extra_bytes_per_opt	common/options.hpp	/^      const size_t extra_bytes_per_opt;$/;"	m	class:openvpn::OptionList::Limits
extra_bytes_per_term	common/options.hpp	/^      const size_t extra_bytes_per_term;$/;"	m	class:openvpn::OptionList::Limits
extra_certs	openssl/ssl/sslctx.hpp	/^      OpenSSLPKI::X509List extra_certs; \/\/ from OpenVPN "extra-certs" option$/;"	m	class:openvpn::OpenSSLContext::Config
extra_payload_bytes	compress/compress.hpp	/^    unsigned int extra_payload_bytes() const$/;"	f	class:openvpn::CompressContext
extra_peer_info	client/cliopt.hpp	/^      PeerInfo::Set::Ptr extra_peer_info;$/;"	m	struct:openvpn::ClientOptions::Config
extra_peer_info	ssl/proto.hpp	/^      PeerInfo::Set::Ptr extra_peer_info;$/;"	m	class:openvpn::ProtoContext::Config
extra_transport_bytes	transport/protocol.hpp	/^    unsigned int extra_transport_bytes() const$/;"	f	class:openvpn::Protocol
extract_auth_token	client/cliproto.hpp	/^      void extract_auth_token(const OptionList& opt)$/;"	f	class:openvpn::ClientProto::Session
extract_router	tun/client/dhcp_capture.hpp	/^    static IPv4::Addr extract_router(DHCPPacket* dhcp, const unsigned int optlen)$/;"	f	class:openvpn::DHCPCapture
extract_size	transport/pktstream.hpp	/^    void extract_size(Buffer& buf, const Frame::Context& frame_context)$/;"	f	class:openvpn::PacketStream
extraneous_err	common/options.hpp	/^    static void extraneous_err(const int line_num, const char *type, const Option& opt)$/;"	f	class:openvpn::OptionList
factory	crypto/cryptodc.hpp	/^    CryptoDCFactory::Ptr factory() const { return factory_; }$/;"	f	class:openvpn::CryptoDCSettings
factory_	crypto/cryptodc.hpp	/^    CryptoDCFactory::Ptr factory_;$/;"	m	class:openvpn::CryptoDCSettings
fail	auth/authcert.hpp	/^      std::unique_ptr<Fail> fail;$/;"	m	struct:openvpn::AuthCert
fail	http/reply.hpp	/^	fail,$/;"	e	enum:openvpn::HTTP::ReplyParser::status
fail	http/request.hpp	/^	fail,$/;"	e	enum:openvpn::HTTP::RequestParser::status
fatal	client/cliproto.hpp	/^      Error::Type fatal() const { return fatal_; }$/;"	f	class:openvpn::ClientProto::Session
fatal	error/excode.hpp	/^    bool fatal() const { return (code_ & FATAL_FLAG) != 0; }$/;"	f	class:openvpn::ExceptionCode
fatal_	client/cliproto.hpp	/^      Error::Type fatal_ = Error::UNDEF;$/;"	m	class:openvpn::ClientProto::Session
fatal_reason	client/cliproto.hpp	/^      const std::string& fatal_reason() const { return fatal_reason_; }$/;"	f	class:openvpn::ClientProto::Session
fatal_reason_	client/cliproto.hpp	/^      std::string fatal_reason_;$/;"	m	class:openvpn::ClientProto::Session
fd	common/persistfile.hpp	/^    ScopedFD fd;$/;"	m	class:openvpn::PersistentFile
fd	common/scoped_fd.hpp	/^    int fd;$/;"	m	class:openvpn::ScopedFD
fd	common/tempfile.hpp	/^    ScopedFD fd;$/;"	m	class:openvpn::TempFile
fetch_buffer	buffer/bufcomplete.hpp	/^    bool fetch_buffer()$/;"	f	class:openvpn::BufferComplete
fi	common/format.hpp	/^    std::string::const_iterator fi;$/;"	m	class:openvpn::PrintFormatted
file	ip/dhcp.hpp	/^    std::uint8_t  file[128];  \/* boot file name *\/$/;"	m	struct:openvpn::DHCP
file_exists	common/stat.hpp	/^  inline bool file_exists(const std::string& filename)$/;"	f	namespace:openvpn
file_mod_time	common/stat.hpp	/^  inline time_t file_mod_time(const std::string& filename)$/;"	f	namespace:openvpn
filename	common/tempfile.hpp	/^    std::string filename() const$/;"	f	class:openvpn::TempFile
fill	random/randbytestore.hpp	/^    void fill(T& obj, RAND_TYPE& rng)$/;"	f	class:openvpn::RandomByteStore
filt	client/optfilt.hpp	/^    bool filt(const Option& opt)$/;"	f	class:openvpn::PushedOptionsFilter
filter	client/optfilt.hpp	/^    virtual bool filter(const Option& opt)$/;"	f	class:openvpn::PushedOptionsFilter
final	applecrypto/crypto/cipher.hpp	/^      bool final(unsigned char *out, const size_t max_out_size, size_t& out_acc)$/;"	f	class:openvpn::AppleCrypto::CipherContext
final	applecrypto/crypto/digest.hpp	/^      size_t final(unsigned char *out)$/;"	f	class:openvpn::AppleCrypto::DigestContext
final	applecrypto/crypto/hmac.hpp	/^      size_t final(unsigned char *out)$/;"	f	class:openvpn::AppleCrypto::HMACContext
final	crypto/digestapi.hpp	/^    virtual size_t final(unsigned char *out)$/;"	f	class:openvpn::CryptoDigestInstance
final	crypto/digestapi.hpp	/^    virtual size_t final(unsigned char *out)$/;"	f	class:openvpn::CryptoHMACInstance
final	crypto/hashstr.hpp	/^    BufferPtr final()$/;"	f	class:openvpn::HashString
final	openssl/crypto/cipher.hpp	/^      bool final(unsigned char *out, const size_t max_out_size, size_t& out_acc)$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
final	openssl/crypto/digest.hpp	/^      size_t final(unsigned char *out)$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
final	openssl/crypto/hmac.hpp	/^      size_t final(unsigned char *out)$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
final	polarssl/crypto/cipher.hpp	/^      bool final(unsigned char *out, const size_t max_out_size, size_t& out_acc)$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
final	polarssl/crypto/digest.hpp	/^      size_t final(unsigned char *out)$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
final	polarssl/crypto/hmac.hpp	/^      size_t final(unsigned char *out)$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
final_hex	crypto/hashstr.hpp	/^    std::string final_hex()$/;"	f	class:openvpn::HashString
finalize	client/cliopt.hpp	/^    void finalize(const bool disconnected)$/;"	f	class:openvpn::ClientOptions
finalize	tun/builder/client.hpp	/^      virtual void finalize(const bool disconnected)$/;"	f	class:openvpn::TunBuilderClient::ClientConfig
finalize	tun/client/tunbase.hpp	/^    virtual void finalize(const bool disconnected) {}$/;"	f	struct:openvpn::TunClientFactory
finalize	tun/mac/client/tuncli.hpp	/^      virtual void finalize(const bool disconnected)$/;"	f	class:openvpn::TunMac::ClientConfig
find	addr/routeinv.hpp	/^      static Type find(const RouteList& in, const Route& route)$/;"	f	class:openvpn::IP::RouteInverter
find	common/process.hpp	/^    std::string find(const std::string& name) const$/;"	f	class:openvpn::Environ
find_first_set	common/ffs.hpp	/^  inline int find_first_set(unsigned int v)$/;"	f	namespace:openvpn
find_index	common/process.hpp	/^    int find_index(const std::string& name) const$/;"	f	class:openvpn::Environ
find_last_set	common/ffs.hpp	/^  inline int find_last_set(unsigned int v)$/;"	f	namespace:openvpn
fire	transport/gremlin.hpp	/^	Time fire;$/;"	m	struct:openvpn::Gremlin::DelayedQueue::Event
fire_time	transport/gremlin.hpp	/^	virtual const Time& fire_time()$/;"	f	struct:openvpn::Gremlin::DelayedQueue::Event
firstByteMark	common/unicode-impl.hpp	/^    const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	m	namespace:openvpn::Unicode
firstRemoteListItem	client/cliopthelper.hpp	/^    const RemoteItem& firstRemoteListItem() const { return firstRemoteListItem_; }$/;"	f	class:openvpn::ParseClientConfig
firstRemoteListItem_	client/cliopthelper.hpp	/^    RemoteItem firstRemoteListItem_;$/;"	m	class:openvpn::ParseClientConfig
first_item	client/remotelist.hpp	/^    const Item* first_item() const$/;"	f	class:openvpn::RemoteList
first_packet_received	client/cliproto.hpp	/^      bool first_packet_received() const { return first_packet_received_; }$/;"	f	class:openvpn::ClientProto::Session
first_packet_received_	client/cliproto.hpp	/^      bool first_packet_received_ = false;$/;"	m	class:openvpn::ClientProto::Session
first_server_host	client/remotelist.hpp	/^    std::string first_server_host() const$/;"	f	class:openvpn::RemoteList
flag	common/getopt.hpp	/^    int *flag;$/;"	m	struct:openvpn::option
flags	applecrypto/util/reachable.hpp	/^    SCNetworkReachabilityFlags flags() const$/;"	f	class:openvpn::ReachabilityBase
flags	crypto/cryptoalgs.hpp	/^      unsigned int flags() const { return flags_; }      \/\/ contains Mode and AlgFlags$/;"	f	class:openvpn::CryptoAlgs::Alg
flags	ip/dhcp.hpp	/^    std::uint16_t flags;$/;"	m	struct:openvpn::DHCP
flags	openssl/ssl/sslctx.hpp	/^      unsigned int flags;           \/\/ defined in sslconsts.hpp$/;"	m	class:openvpn::OpenSSLContext::Config
flags	polarssl/ssl/sslctx.hpp	/^      unsigned int flags;           \/\/ defined in sslconsts.hpp$/;"	m	class:openvpn::PolarSSLContext::Config
flags	ssl/datalimit.hpp	/^    unsigned int flags = 0;$/;"	m	class:openvpn::DataLimit
flags	ssl/proto.hpp	/^      unsigned int flags;$/;"	m	class:openvpn::ProtoContext::PacketType
flags	tun/builder/capture.hpp	/^      unsigned int flags = 0;$/;"	m	class:openvpn::TunBuilderCapture::RerouteGW
flags	tun/mac/gwv4.hpp	/^    unsigned int flags() const { return flags_; }$/;"	f	class:openvpn::MacGatewayInfoV4
flags	tun/mac/macdns_watchdog.hpp	/^      const unsigned int flags;$/;"	m	class:openvpn::MacDNSWatchdog::DNSAction
flags_	buffer/buffer.hpp	/^    unsigned int flags_;$/;"	m	class:openvpn::BufferAllocatedType
flags_	client/rgopt.hpp	/^    unsigned int flags_;$/;"	m	class:openvpn::RedirectGatewayFlags
flags_	common/signal.hpp	/^    unsigned int flags_;$/;"	m	class:openvpn::Signal
flags_	crypto/cryptoalgs.hpp	/^      unsigned int flags_;$/;"	m	class:openvpn::CryptoAlgs::Alg
flags_	tun/mac/gwv4.hpp	/^    unsigned int flags_;$/;"	m	class:openvpn::MacGatewayInfoV4
flip	transport/gremlin.hpp	/^      bool flip(const unsigned int prob)$/;"	f	class:openvpn::Gremlin::SendRecvQueue
float_notify	server/servproto.hpp	/^      virtual void float_notify(const PeerAddr::Ptr& addr)$/;"	f	class:openvpn::ServerProto::Session
flush	ssl/proto.hpp	/^      void flush()$/;"	f	class:openvpn::ProtoContext::KeyContext
flush	ssl/proto.hpp	/^    void flush(const bool control_channel)$/;"	f	class:openvpn::ProtoContext
flush	ssl/protostack.hpp	/^    void flush()$/;"	f	class:openvpn::ProtoStackBase
flush_arp	tun/win/tunutil.hpp	/^      inline void flush_arp(const DWORD adapter_index,$/;"	f	namespace:openvpn::TunWin::Util
flush_cache	tun/mac/macdns.hpp	/^    void flush_cache()$/;"	f	class:openvpn::MacDNS
fmt	common/format.hpp	/^    const std::string& fmt;$/;"	m	class:openvpn::PrintFormatted
fmt_polarssl_verify_flags	polarssl/ssl/sslctx.hpp	/^    static std::string fmt_polarssl_verify_flags(const int flags)$/;"	f	class:openvpn::PolarSSLContext
fn	common/persistfile.hpp	/^    std::string fn;$/;"	m	class:openvpn::PersistentFile
fn	common/tempfile.hpp	/^    std::unique_ptr<char[]> fn;$/;"	m	class:openvpn::TempFile
force_aes_cbc_ciphersuites	client/cliopt.hpp	/^      bool force_aes_cbc_ciphersuites = false;$/;"	m	struct:openvpn::ClientOptions::Config
force_aes_cbc_ciphersuites	openssl/ssl/sslctx.hpp	/^      bool force_aes_cbc_ciphersuites;$/;"	m	class:openvpn::OpenSSLContext::Config
force_aes_cbc_ciphersuites	polarssl/ssl/sslctx.hpp	/^      bool force_aes_cbc_ciphersuites;$/;"	m	class:openvpn::PolarSSLContext::Config
force_aes_cbc_ciphersuites	ssl/proto.hpp	/^      bool force_aes_cbc_ciphersuites = false;$/;"	m	class:openvpn::ProtoContext::Config
force_canonical	addr/route.hpp	/^      void force_canonical()$/;"	f	struct:openvpn::IP::RouteType
form	crypto/packet_id.hpp	/^    int form;                       \/\/ PacketID::LONG_FORM or PacketID::SHORT_FORM$/;"	m	class:openvpn::PacketIDReceiveType
form_	crypto/packet_id.hpp	/^    int form_;$/;"	m	class:openvpn::PacketIDSend
format_components	http/urlparse.hpp	/^      std::string format_components() const$/;"	f	class:openvpn::URL::Parse
format_error	addr/iperr.hpp	/^      inline std::string format_error(const std::string& ipstr, const char *title, const char *ipver, const asio::error_code& ec)$/;"	f	namespace:openvpn::IP::internal
format_error	addr/iperr.hpp	/^      inline std::string format_error(const std::string& ipstr, const char *title, const char *ipver, const char *message)$/;"	f	namespace:openvpn::IP::internal
formatted	http/webexcept.hpp	/^      const std::string formatted;$/;"	m	class:openvpn::HTTP::WebException
fractional_binary_ms	time/time.hpp	/^    T fractional_binary_ms() const { return time_ % prec; }$/;"	f	class:openvpn::TimeType
frag_off	ip/ip.hpp	/^    std::uint16_t   frag_off;$/;"	m	struct:openvpn::IPHeader
frame	applecrypto/ssl/sslctx.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::AppleSSLContext::Config
frame	applecrypto/ssl/sslctx.hpp	/^    const Frame::Ptr& frame() const { return config_->frame; }$/;"	f	class:openvpn::AppleSSLContext
frame	client/cliopt.hpp	/^    Frame::Ptr frame;$/;"	m	class:openvpn::ClientOptions
frame	compress/compress.hpp	/^    Frame::Ptr frame;$/;"	m	class:openvpn::Compress
frame	crypto/crypto_aead.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::AEAD::Crypto
frame	crypto/crypto_aead.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::AEAD::CryptoContext
frame	crypto/crypto_chm.hpp	/^    Frame::Ptr frame;$/;"	m	class:openvpn::CryptoCHM
frame	crypto/crypto_chm.hpp	/^    Frame::Ptr frame;$/;"	m	class:openvpn::CryptoContextCHM
frame	crypto/cryptodcsel.hpp	/^    Frame::Ptr frame;$/;"	m	class:openvpn::CryptoDCSelect
frame	crypto/decrypt_chm.hpp	/^    Frame::Ptr frame;$/;"	m	class:openvpn::DecryptCHM
frame	crypto/encrypt_chm.hpp	/^    Frame::Ptr frame;$/;"	m	class:openvpn::EncryptCHM
frame	openssl/ssl/sslctx.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::OpenSSLContext::Config
frame	polarssl/ssl/sslctx.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::PolarSSLContext::Config
frame	ssl/proto.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::ProtoContext::Config
frame	ssl/proto.hpp	/^    const Frame& frame() const { return *config->frame; }$/;"	f	class:openvpn::ProtoContext
frame	transport/altproxy.hpp	/^      Frame::Ptr frame;$/;"	m	struct:openvpn::AltProxy::Config
frame	transport/client/httpcli.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::HTTPProxyTransport::ClientConfig
frame	transport/client/tcpcli.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::TCPTransport::ClientConfig
frame	transport/client/udpcli.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::UDPTransport::ClientConfig
frame	transport/dco.hpp	/^      Frame::Ptr frame;$/;"	m	struct:openvpn::DCO::TransportConfig
frame	tun/builder/client.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::TunBuilderClient::ClientConfig
frame	tun/client/tunnull.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::TunNull::ClientConfig
frame	tun/linux/client/tuncli.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::TunLinux::ClientConfig
frame	tun/mac/client/tuncli.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::TunMac::ClientConfig
frame	tun/tunio.hpp	/^    const Frame::Ptr frame;$/;"	m	class:openvpn::TunIO
frame	tun/win/client/tuncli.hpp	/^      Frame::Ptr frame;$/;"	m	class:openvpn::TunWin::ClientConfig
frame_	frame/memq_dgram.hpp	/^    Frame::Ptr frame_;$/;"	m	class:openvpn::MemQDgram
frame_	frame/memq_stream.hpp	/^    Frame::Ptr frame_;$/;"	m	class:openvpn::MemQStream
frame_	ssl/protostack.hpp	/^    Frame::Ptr frame_;$/;"	m	class:openvpn::ProtoStackBase
frame_context	transport/tcplink.hpp	/^      Frame::Context frame_context;$/;"	m	class:openvpn::TCPTransport::Link
frame_context	transport/udplink.hpp	/^      Frame::Context frame_context;$/;"	m	class:openvpn::UDPTransport::Link
frame_context	tun/tunio.hpp	/^    const Frame::Context& frame_context;$/;"	m	class:openvpn::TunIO
frame_init	frame/frame_init.hpp	/^  inline Frame::Ptr frame_init(const bool align_adjust_3_1,$/;"	f	namespace:openvpn
frame_init_context_simple	frame/frame_init.hpp	/^  inline Frame::Context frame_init_context_simple(const size_t payload)$/;"	f	namespace:openvpn
frame_init_simple	frame/frame_init.hpp	/^  inline Frame::Ptr frame_init_simple(const size_t payload)$/;"	f	namespace:openvpn
frame_prepare	ssl/proto.hpp	/^      void frame_prepare(const Frame& frame, const unsigned int context)$/;"	f	class:openvpn::ProtoContext::Packet
frameptr	ssl/proto.hpp	/^    const Frame::Ptr& frameptr() const { return config->frame; }$/;"	f	class:openvpn::ProtoContext
free_if_addrs	netconf/enumiface.hpp	/^      static void free_if_addrs(ifaddrs* p)$/;"	f	class:openvpn::EnumIface
free_list	transport/tcplink.hpp	/^      Queue free_list;  \/\/ recycled free buffers for send queue$/;"	m	class:openvpn::TCPTransport::Link
free_list_max_size	transport/altproxy.hpp	/^      size_t free_list_max_size;$/;"	m	struct:openvpn::AltProxy::Config
free_list_max_size	transport/client/httpcli.hpp	/^      size_t free_list_max_size;$/;"	m	class:openvpn::HTTPProxyTransport::ClientConfig
free_list_max_size	transport/client/tcpcli.hpp	/^      size_t free_list_max_size;$/;"	m	class:openvpn::TCPTransport::ClientConfig
free_list_max_size	transport/tcplink.hpp	/^      const size_t free_list_max_size;$/;"	m	class:openvpn::TCPTransport::Link
freelist	addr/pool.hpp	/^      std::deque<ADDR> freelist;$/;"	m	class:openvpn::IP::PoolType
friendlyName	client/cliopthelper.hpp	/^      std::string friendlyName;$/;"	m	struct:openvpn::ParseClientConfig::ServerEntry
friendlyName	client/cliopthelper.hpp	/^    const std::string& friendlyName() const { return friendlyName_; }$/;"	f	class:openvpn::ParseClientConfig
friendlyName_	client/cliopthelper.hpp	/^    std::string friendlyName_;$/;"	m	class:openvpn::ParseClientConfig
from_addr	addr/ipv4.hpp	/^      static Addr from_addr(const Addr& addr)$/;"	f	class:openvpn::IPv4::Addr
from_addr	addr/ipv6.hpp	/^      static Addr from_addr(const Addr& addr)$/;"	f	class:openvpn::IPv6::Addr
from_argv	common/string.hpp	/^    inline std::vector<std::string> from_argv(int argc, char *argv[], const bool skip_first)$/;"	f	namespace:openvpn::string
from_asio	addr/ip.hpp	/^      static Addr from_asio(const asio::ip::address& addr)$/;"	f	class:openvpn::IP::Addr
from_asio	addr/ipv4.hpp	/^      static Addr from_asio(const asio::ip::address_v4& asio_addr)$/;"	f	class:openvpn::IPv4::Addr
from_asio	addr/ipv6.hpp	/^      static Addr from_asio(const asio::ip::address_v6& asio_addr)$/;"	f	class:openvpn::IPv6::Addr
from_byte_string	addr/ip.hpp	/^      static Addr from_byte_string(const unsigned char *bytestr)$/;"	f	class:openvpn::IP::Addr
from_byte_string	addr/ipv6.hpp	/^      static Addr from_byte_string(const unsigned char *bytestr)$/;"	f	class:openvpn::IPv6::Addr
from_bytes	addr/ipv4.hpp	/^      static Addr from_bytes(const unsigned char *bytes) \/\/ host byte order$/;"	f	class:openvpn::IPv4::Addr
from_bytes_net	addr/ipv4.hpp	/^      static Addr from_bytes_net(const unsigned char *bytes) \/\/ network byte order$/;"	f	class:openvpn::IPv4::Addr
from_components	http/urlparse.hpp	/^      static Parse from_components(const bool https,$/;"	f	class:openvpn::URL::Parse
from_file	pki/cclist.hpp	/^    static void from_file(const std::string filename, CertList* cert_list, CRLList* crl_list = nullptr)$/;"	f	class:openvpn::CertCRLListTemplate
from_generic	applecrypto/cf/cf.hpp	/^      static Wrap from_generic(CFTypeRef obj, const Own own=OWN)$/;"	f	class:openvpn::CF::Wrap
from_hex	addr/ip.hpp	/^      static Addr from_hex(Version v, const std::string& s)$/;"	f	class:openvpn::IP::Addr
from_hex	addr/ipv4.hpp	/^      static Addr from_hex(const std::string& s)$/;"	f	class:openvpn::IPv4::Addr
from_hex	addr/ipv6.hpp	/^      static Addr from_hex(const std::string& s)$/;"	f	class:openvpn::IPv6::Addr
from_in6_addr	addr/ipv6.hpp	/^      static Addr from_in6_addr(const struct in6_addr *in6)$/;"	f	class:openvpn::IPv6::Addr
from_in_addr	addr/ipv4.hpp	/^      static Addr from_in_addr(const struct in_addr *in4)$/;"	f	class:openvpn::IPv4::Addr
from_ipv4	addr/ip.hpp	/^      static Addr from_ipv4(const IPv4::Addr& addr)$/;"	f	class:openvpn::IP::Addr
from_ipv6	addr/ip.hpp	/^      static Addr from_ipv6(const IPv6::Addr& addr)$/;"	f	class:openvpn::IP::Addr
from_istream	pki/cclist.hpp	/^    static void from_istream(std::istream& in, const std::string& title, CertList* cert_list, CRLList* crl_list)$/;"	f	class:openvpn::CertCRLListTemplate
from_json	tun/builder/capture.hpp	/^      void from_json(const Json::Value& root, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture::DNSServer
from_json	tun/builder/capture.hpp	/^      void from_json(const Json::Value& root, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture::ProxyAutoConfigURL
from_json	tun/builder/capture.hpp	/^      void from_json(const Json::Value& root, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture::ProxyBypass
from_json	tun/builder/capture.hpp	/^      void from_json(const Json::Value& root, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture::ProxyHostPort
from_json	tun/builder/capture.hpp	/^      void from_json(const Json::Value& root, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture::RemoteAddress
from_json	tun/builder/capture.hpp	/^      void from_json(const Json::Value& root, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture::RerouteGW
from_json	tun/builder/capture.hpp	/^      void from_json(const Json::Value& root, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture::RouteBase
from_json	tun/builder/capture.hpp	/^      void from_json(const Json::Value& root, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture::SearchDomain
from_json	tun/builder/capture.hpp	/^      void from_json(const Json::Value& root, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture::WINSServer
from_json	tun/builder/capture.hpp	/^    static TunBuilderCapture::Ptr from_json(const Json::Value& root)$/;"	f	class:openvpn::TunBuilderCapture
from_list	common/options.hpp	/^    void from_list(T first, Args... args)$/;"	f	class:openvpn::Option
from_list	common/options.hpp	/^    void from_list(const char *arg)$/;"	f	class:openvpn::Option
from_list	common/options.hpp	/^    void from_list(std::string arg)$/;"	f	class:openvpn::Option
from_long	addr/ip.hpp	/^      static Addr from_long(Version v, long ul)$/;"	f	class:openvpn::IP::Addr
from_long	addr/ipv4.hpp	/^      static Addr from_long(long ul)$/;"	f	class:openvpn::IPv4::Addr
from_long	addr/ipv6.hpp	/^      static Addr from_long(long ul)$/;"	f	class:openvpn::IPv6::Addr
from_one	addr/ip.hpp	/^      static Addr from_one(Version v)$/;"	f	class:openvpn::IP::Addr
from_one	addr/ipv4.hpp	/^      static Addr from_one()$/;"	f	class:openvpn::IPv4::Addr
from_one	addr/ipv6.hpp	/^      static Addr from_one()$/;"	f	class:openvpn::IPv6::Addr
from_sockaddr	addr/ip.hpp	/^      static Addr from_sockaddr(const struct sockaddr *sa)$/;"	f	class:openvpn::IP::Addr
from_sockaddr	addr/ipv4.hpp	/^      static Addr from_sockaddr(const struct sockaddr_in *sa)$/;"	f	class:openvpn::IPv4::Addr
from_sockaddr	addr/ipv6.hpp	/^      static Addr from_sockaddr(const struct sockaddr_in6 *sa)$/;"	f	class:openvpn::IPv6::Addr
from_str	tun/layer.hpp	/^    static Layer from_str(const std::string& str)$/;"	f	class:openvpn::Layer
from_string	addr/addrpair.hpp	/^      static AddrMaskPair from_string(const StringPair& pair, const char *title = nullptr)$/;"	f	struct:openvpn::IP::AddrMaskPair
from_string	addr/addrpair.hpp	/^      static AddrMaskPair from_string(const std::string& s, const char *title = nullptr)$/;"	f	struct:openvpn::IP::AddrMaskPair
from_string	addr/addrpair.hpp	/^      static AddrMaskPair from_string(const std::string& s1, const std::string& s2, const char *title = nullptr)$/;"	f	struct:openvpn::IP::AddrMaskPair
from_string	addr/ip.hpp	/^      static Addr from_string(const std::string& ipstr, const char *title = nullptr, Version required_version = UNSPEC)$/;"	f	class:openvpn::IP::Addr
from_string	addr/ipv4.hpp	/^      static Addr from_string(const std::string& ipstr, const char *title = nullptr)$/;"	f	class:openvpn::IPv4::Addr
from_string	addr/ipv6.hpp	/^      static Addr from_string(const std::string& ipstr, const char *title = nullptr)$/;"	f	class:openvpn::IPv6::Addr
from_string	addr/route.hpp	/^      static RouteType from_string(const std::string& rtstr, const char *title = nullptr)$/;"	f	struct:openvpn::IP::RouteType
from_string	pki/cclist.hpp	/^    static void from_string(const std::string content, const std::string& title, CertList* cert_list, CRLList* crl_list = nullptr)$/;"	f	class:openvpn::CertCRLListTemplate
from_string_impl	addr/addrpair.hpp	/^      static AddrMaskPair from_string_impl(const StringPair& pair, const char *title = nullptr)$/;"	f	struct:openvpn::IP::AddrMaskPair
from_uint32	addr/ipv4.hpp	/^      static Addr from_uint32(const base_type addr) \/\/ host byte order$/;"	f	class:openvpn::IPv4::Addr
from_uint32_net	addr/ipv4.hpp	/^      static Addr from_uint32_net(const base_type addr) \/\/ addr in net byte order$/;"	f	class:openvpn::IPv4::Addr
from_ulong	addr/ip.hpp	/^      static Addr from_ulong(Version v, unsigned long ul)$/;"	f	class:openvpn::IP::Addr
from_ulong	addr/ipv4.hpp	/^      static Addr from_ulong(unsigned long ul)$/;"	f	class:openvpn::IPv4::Addr
from_ulong	addr/ipv6.hpp	/^      static Addr from_ulong(unsigned long ul)$/;"	f	class:openvpn::IPv6::Addr
from_utf8	common/wstring.hpp	/^    inline std::wstring from_utf8(const std::string& str)$/;"	f	namespace:openvpn::wstring
from_value	tun/layer.hpp	/^    static Layer from_value(const int value)$/;"	f	class:openvpn::Layer
from_zero	addr/ip.hpp	/^      static Addr from_zero(Version v)$/;"	f	class:openvpn::IP::Addr
from_zero	addr/ipv4.hpp	/^      static Addr from_zero()$/;"	f	class:openvpn::IPv4::Addr
from_zero	addr/ipv6.hpp	/^      static Addr from_zero()$/;"	f	class:openvpn::IPv6::Addr
from_zero_complement	addr/ip.hpp	/^      static Addr from_zero_complement(Version v)$/;"	f	class:openvpn::IP::Addr
from_zero_complement	addr/ipv4.hpp	/^      static Addr from_zero_complement()$/;"	f	class:openvpn::IPv4::Addr
from_zero_complement	addr/ipv6.hpp	/^      static Addr from_zero_complement()$/;"	f	class:openvpn::IPv6::Addr
front	buffer/buffer.hpp	/^    T front()$/;"	f	class:openvpn::BufferType
front	reliable/relack.hpp	/^    id_t front() const         { return data.front(); }$/;"	f	class:openvpn::ReliableAck
full_chain	pki/x509track.hpp	/^      bool full_chain;$/;"	m	struct:openvpn::X509Track::Config
func	transport/gremlin.hpp	/^	F func;$/;"	m	struct:openvpn::Gremlin::DelayedQueue::Event
functor_	common/function.hpp	/^      T functor_;$/;"	m	class:openvpn::Function::Intern
gateway	tun/builder/capture.hpp	/^      std::string gateway; \/\/ optional$/;"	m	class:openvpn::TunBuilderCapture::RouteBase
gateway_	tun/mac/gwv4.hpp	/^    IP::AddrMaskPair gateway_;$/;"	m	class:openvpn::MacGatewayInfoV4
gateway_addr	tun/mac/gwv4.hpp	/^    const IP::Addr& gateway_addr() const { return gateway_.addr; }$/;"	f	class:openvpn::MacGatewayInfoV4
gateway_addr_str	tun/mac/gwv4.hpp	/^    std::string gateway_addr_str() const { return gateway_addr().to_string(); }$/;"	f	class:openvpn::MacGatewayInfoV4
gateway_address	tun/win/tunutil.hpp	/^	const std::string& gateway_address() const$/;"	f	class:openvpn::TunWin::Util::DefaultGateway
gateway_netmask	tun/mac/gwv4.hpp	/^    const IP::Addr& gateway_netmask() const { return gateway_.netmask; }$/;"	f	class:openvpn::MacGatewayInfoV4
gateway_netmask_str	tun/mac/gwv4.hpp	/^    std::string gateway_netmask_str() const { return gateway_netmask().to_string(); }$/;"	f	class:openvpn::MacGatewayInfoV4
gen_exp	ssl/tlsprf.hpp	/^    static void gen_exp(OpenVPNStaticKey& dest, const TLSPRF& client, const ProtoSessionID& psid_client,$/;"	f	class:openvpn::TLSPRF
gen_head	ssl/proto.hpp	/^      void gen_head(const unsigned int opcode, Buffer& buf)$/;"	f	class:openvpn::ProtoContext::KeyContext
gen_headers	transport/client/httpcli.hpp	/^      void gen_headers(std::ostringstream& os)$/;"	f	class:openvpn::HTTPProxyTransport::Client
gen_seed	random/mtrandapi.hpp	/^    static rand_type::result_type gen_seed()$/;"	f	class:openvpn::MTRand
gen_seed	random/mtrandapi.hpp	/^    static rand_type::result_type gen_seed(RandomAPI& seed)$/;"	f	class:openvpn::MTRand
generate_ack	ssl/proto.hpp	/^      void generate_ack(Packet& pkt) \/\/ called by ProtoStackBase$/;"	f	class:openvpn::ProtoContext::KeyContext
generate_dynamic_challenge	auth/cr.hpp	/^    static std::string generate_dynamic_challenge(const std::string& session_token,$/;"	f	class:openvpn::ChallengeResponse
generate_key_expansion	ssl/tlsprf.hpp	/^    virtual void generate_key_expansion(OpenVPNStaticKey& dest,$/;"	f	class:openvpn::CryptoTLSPRFInstance
generate_key_expansion	ssl/tlsprf.hpp	/^    void generate_key_expansion(OpenVPNStaticKey& dest, const TLSPRF& peer,$/;"	f	class:openvpn::TLSPRF
generate_session_keys	ssl/proto.hpp	/^      void generate_session_keys()$/;"	f	class:openvpn::ProtoContext::KeyContext
generation	client/cliconnect.hpp	/^    unsigned int generation;$/;"	m	class:openvpn::ClientConnect
generic	applecrypto/cf/cf.hpp	/^      CFTypeRef generic() const { return (CFTypeRef)obj_; }$/;"	f	class:openvpn::CF::Wrap
generic_cast	applecrypto/cf/cf.hpp	/^    inline Generic generic_cast(CFTypeRef obj)$/;"	f	namespace:openvpn::CF
generic_release	applecrypto/cf/cf.hpp	/^      CFTypeRef generic_release()$/;"	f	class:openvpn::CF::Wrap
get	buffer/bufcomplete.hpp	/^    bool get(std::uint8_t& c)$/;"	f	class:openvpn::BufferComplete
get	buffer/bufcomposed.hpp	/^      BufferPtr get()$/;"	f	class:openvpn::BufferComposed::Complete
get	common/lex.hpp	/^    int get() const { return ch; }$/;"	f	class:openvpn::NullLex
get	common/lex.hpp	/^    int get() const { return ch; }$/;"	f	class:openvpn::StandardLex
get	common/options.hpp	/^      int get() const { return ch; }$/;"	f	class:openvpn::OptionList::LexComment
get	common/options.hpp	/^    const Option& get(const std::string& name) const$/;"	f	class:openvpn::OptionList
get	common/options.hpp	/^    const std::string& get(const size_t index, const size_t max_len) const$/;"	f	class:openvpn::Option
get	common/options.hpp	/^    const std::string& get(const std::string& name, size_t index, const size_t max_len) const$/;"	f	class:openvpn::OptionList
get	common/unicode.hpp	/^      bool get(Char &c)$/;"	f	class:openvpn::Unicode::UTF8Iterator
get	crypto/cryptoalgs.hpp	/^    inline const Alg& get(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
get	http/header.hpp	/^      Header* get(const std::string& key)$/;"	f	struct:openvpn::HTTP::HeaderList
get	http/header.hpp	/^      const Header* get(const std::string& key) const$/;"	f	struct:openvpn::HTTP::HeaderList
get	http/urlparm.hpp	/^      const Parm* get(const std::string& key) const$/;"	f	class:openvpn::URL::ParmList
get	polarssl/pki/dh.hpp	/^      dhm_context* get() const$/;"	f	class:openvpn::PolarSSLPKI::DH
get	polarssl/pki/pkctx.hpp	/^      pk_context* get() const$/;"	f	class:openvpn::PolarSSLPKI::PKContext
get	polarssl/pki/x509cert.hpp	/^      x509_crt* get() const$/;"	f	class:openvpn::PolarSSLPKI::X509Cert
get	polarssl/pki/x509crl.hpp	/^      x509_crl* get() const$/;"	f	class:openvpn::PolarSSLPKI::X509CRL
get	transport/pktstream.hpp	/^    void get(BufferAllocated& ret)$/;"	f	class:openvpn::PacketStream
get	win/console.hpp	/^	unsigned int get()$/;"	f	class:openvpn::Win::Console::Input
get_app_id_blob	tun/win/wfp.hpp	/^      static unique_ptr_del<FWP_BYTE_BLOB> get_app_id_blob(const std::wstring& app_path)$/;"	f	class:openvpn::TunWin::WFP
get_byte	random/randbytestore.hpp	/^    unsigned char get_byte(RAND_TYPE& rng)$/;"	f	class:openvpn::RandomByteStore
get_bytes	common/options.hpp	/^      std::uint64_t get_bytes() const$/;"	f	class:openvpn::OptionList::Limits
get_challenge_text	auth/cr.hpp	/^    const std::string& get_challenge_text() const { return challenge_text; }$/;"	f	class:openvpn::ChallengeResponse
get_cn	auth/authcert.hpp	/^      const std::string& get_cn() const$/;"	f	struct:openvpn::AuthCert
get_code	auth/authcert.hpp	/^	Type get_code() const$/;"	f	class:openvpn::AuthCert::Fail
get_consistent	common/options.hpp	/^    const Option* get_consistent(const std::string& name) const$/;"	f	class:openvpn::OptionList
get_default	common/options.hpp	/^    std::string get_default(const size_t index, const size_t max_len, const std::string& default_value) const$/;"	f	class:openvpn::Option
get_default	common/options.hpp	/^    std::string get_default(const std::string& name,$/;"	f	class:openvpn::OptionList
get_default_gateway_v4	netconf/linux/route.hpp	/^    static IP::Addr get_default_gateway_v4()$/;"	f	class:openvpn::RouteListLinux
get_default_gateway_v4	tun/linux/client/tuncli.hpp	/^    inline IP::Addr get_default_gateway_v4()$/;"	f	namespace:openvpn::TunLinux
get_default_relaxed	common/options.hpp	/^    std::string get_default_relaxed(const std::string& name,$/;"	f	class:openvpn::OptionList
get_dns	tun/client/dhcp_capture.hpp	/^    static std::vector<IPv4::Addr> get_dns(const DHCPPacket* dhcp, const unsigned int optlen)$/;"	f	class:openvpn::DHCPCapture
get_dns_servers	tun/mac/macdns.hpp	/^      static CF::Array get_dns_servers(const TunBuilderCapture& settings)$/;"	f	class:openvpn::MacDNS::Config
get_echo	auth/cr.hpp	/^    bool get_echo() const { return echo; }$/;"	f	class:openvpn::ChallengeResponse
get_enable_cache	client/remotelist.hpp	/^    bool get_enable_cache() const$/;"	f	class:openvpn::RemoteList
get_endpoint	client/remotelist.hpp	/^      bool get_endpoint(EP& endpoint, const size_t index) const$/;"	f	struct:openvpn::RemoteList::Item
get_endpoint	client/remotelist.hpp	/^    void get_endpoint(EP& endpoint) const$/;"	f	class:openvpn::RemoteList
get_errnum	polarssl/util/error.hpp	/^    int get_errnum() const { return errnum; }$/;"	f	class:openvpn::PolarSSLException
get_event	ssl/proto.hpp	/^      EventType get_event() const { return current_event; }$/;"	f	class:openvpn::ProtoContext::KeyContext
get_fail	auth/authcert.hpp	/^      const Fail* get_fail() const$/;"	f	struct:openvpn::AuthCert
get_hwaddr	netconf/hwaddr.hpp	/^  inline std::string get_hwaddr()$/;"	f	namespace:openvpn
get_index	common/options.hpp	/^    const IndexList& get_index(const std::string& name) const$/;"	f	class:openvpn::OptionList
get_index	crypto/cryptoalgs.hpp	/^    inline const Alg& get_index(const size_t i)$/;"	f	namespace:openvpn::CryptoAlgs
get_index_ptr	common/options.hpp	/^    const IndexList* get_index_ptr(const std::string& name) const$/;"	f	class:openvpn::OptionList
get_index_ptr	crypto/cryptoalgs.hpp	/^    inline const Alg* get_index_ptr(const size_t i)$/;"	f	namespace:openvpn::CryptoAlgs
get_item	client/remotelist.hpp	/^    const Item& get_item(const size_t index) const$/;"	f	class:openvpn::RemoteList
get_management	server/servproto.hpp	/^      bool get_management()$/;"	f	class:openvpn::ServerProto::Session
get_max_line_len	common/options.hpp	/^      size_t get_max_line_len() const$/;"	f	class:openvpn::OptionList::Limits
get_mem	compress/lzoasym_impl.hpp	/^    inline T get_mem(const void *p)$/;"	f	namespace:openvpn::lzo_asym_impl
get_mode	applecrypto/ssl/sslctx.hpp	/^      virtual const Mode& get_mode() const$/;"	f	class:openvpn::AppleSSLContext::Config
get_mode	openssl/ssl/sslctx.hpp	/^      virtual const Mode& get_mode() const$/;"	f	class:openvpn::OpenSSLContext::Config
get_mode	polarssl/ssl/sslctx.hpp	/^      virtual const Mode& get_mode() const$/;"	f	class:openvpn::PolarSSLContext::Config
get_n_errors	openssl/ssl/sslctx.hpp	/^      unsigned int get_n_errors() const { return n_errors; }$/;"	f	class:openvpn::OpenSSLContext::ExternalPKIImpl
get_netmask	tun/client/dhcp_capture.hpp	/^    static IPv4::Addr get_netmask(const DHCPPacket* dhcp, const unsigned int optlen)$/;"	f	class:openvpn::DHCPCapture
get_next_timeout	openssl/bio/bio_memq_dgram.hpp	/^      const struct timeval *get_next_timeout(void) const { return &next_timeout; }$/;"	f	class:openvpn::bmq_dgram::MemQ
get_ntlm_phase_2_response	transport/client/httpcli.hpp	/^      std::string get_ntlm_phase_2_response()$/;"	f	class:openvpn::HTTPProxyTransport::Client
get_num	common/options.hpp	/^    T get_num(const size_t idx) const$/;"	f	class:openvpn::Option
get_num	common/options.hpp	/^    T get_num(const size_t idx, const T default_value) const$/;"	f	class:openvpn::Option
get_num	common/options.hpp	/^    T get_num(const size_t idx, const T default_value, const T min_value, const T max_value) const$/;"	f	class:openvpn::Option
get_num	common/options.hpp	/^    T get_num(const std::string& name, const size_t idx, const T default_value) const$/;"	f	class:openvpn::OptionList
get_num	common/options.hpp	/^    T get_num(const std::string& name, const size_t idx, const T default_value,$/;"	f	class:openvpn::OptionList
get_optional	common/options.hpp	/^    std::string get_optional(const size_t index, const size_t max_len) const$/;"	f	class:openvpn::Option
get_optional	common/options.hpp	/^    std::string get_optional(const std::string& name, size_t index, const size_t max_len) const$/;"	f	class:openvpn::OptionList
get_optional_noexcept	common/options.hpp	/^    std::string get_optional_noexcept(const std::string& name, size_t index, const size_t max_len) const$/;"	f	class:openvpn::OptionList
get_optional_relaxed	common/options.hpp	/^    std::string get_optional_relaxed(const std::string& name, size_t index, const size_t max_len) const$/;"	f	class:openvpn::OptionList
get_password	client/clicreds.hpp	/^    std::string get_password() const$/;"	f	class:openvpn::ClientCreds
get_password	common/getpw.hpp	/^  inline std::string get_password(const char *prompt)$/;"	f	namespace:openvpn
get_props	tun/client/dhcp_capture.hpp	/^    const TunBuilderCapture& get_props() const$/;"	f	class:openvpn::DHCPCapture
get_proxy_authenticate_header	transport/client/httpcli.hpp	/^      HTTPProxy::ProxyAuthenticate::Ptr get_proxy_authenticate_header(const char *type)$/;"	f	class:openvpn::HTTPProxyTransport::Client
get_ptr	common/options.hpp	/^    const Option* get_ptr(const std::string& name) const$/;"	f	class:openvpn::OptionList
get_ptr	common/options.hpp	/^    const std::string* get_ptr(const size_t index, const size_t max_len) const$/;"	f	class:openvpn::Option
get_ptr	crypto/cryptoalgs.hpp	/^    inline const Alg* get_ptr(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
get_replace_password_with_session_id	client/clicreds.hpp	/^    bool get_replace_password_with_session_id() const$/;"	f	class:openvpn::ClientCreds
get_residual	http/htmlskip.hpp	/^      void get_residual(BufferAllocated& buf) const$/;"	f	class:openvpn::HTTP::HTMLSkip
get_response_required	auth/cr.hpp	/^    bool get_response_required() const { return response_required; }$/;"	f	class:openvpn::ChallengeResponse
get_search_domains	tun/mac/macdns.hpp	/^      static CF::Array get_search_domains(const TunBuilderCapture& settings)$/;"	f	class:openvpn::MacDNS::Config
get_sn	auth/authcert.hpp	/^      long get_sn() const$/;"	f	struct:openvpn::AuthCert
get_stat	log/sessionstats.hpp	/^    count_t get_stat(const size_t type) const$/;"	f	class:openvpn::SessionStats
get_stat_fast	log/sessionstats.hpp	/^    count_t get_stat_fast(const size_t type) const$/;"	f	class:openvpn::SessionStats
get_state	ssl/datalimit.hpp	/^      State get_state() const$/;"	f	class:openvpn::DataLimit::Component
get_state_id	auth/cr.hpp	/^    const std::string& get_state_id() const { return state_id; }$/;"	f	class:openvpn::ChallengeResponse
get_tun	server/servproto.hpp	/^      bool get_tun()$/;"	f	class:openvpn::ServerProto::Session
get_u16	compress/lzoasym_impl.hpp	/^    inline size_t get_u16(const unsigned char *p)$/;"	f	namespace:openvpn::lzo_asym_impl
get_unique_ptr	common/options.hpp	/^    const Option* get_unique_ptr(const std::string& name) const$/;"	f	class:openvpn::OptionList
get_username	auth/cr.hpp	/^    const std::string& get_username() const { return username; }$/;"	f	class:openvpn::ChallengeResponse
get_username	client/clicreds.hpp	/^    std::string get_username() const$/;"	f	class:openvpn::ClientCreds
get_value	http/header.hpp	/^      const std::string get_value(const std::string& key) const$/;"	f	struct:openvpn::HTTP::HeaderList
get_value	http/urlparm.hpp	/^      std::string get_value(const std::string& key) const$/;"	f	class:openvpn::URL::ParmList
get_value_required	http/urlparm.hpp	/^      const std::string& get_value_required(const std::string& key) const$/;"	f	class:openvpn::URL::ParmList
get_value_trim	http/header.hpp	/^      const std::string get_value_trim(const std::string& key) const$/;"	f	struct:openvpn::HTTP::HeaderList
getopt_internal	common/getopt.hpp	/^    inline int getopt_internal(int nargc, char * const *nargv, const char *ostr)$/;"	f	namespace:openvpn::getopt_private
getopt_long	common/getopt.hpp	/^  inline int getopt_long(int nargc, char * const *nargv, const char *options,$/;"	f	namespace:openvpn
getopt_private	common/getopt.hpp	/^  namespace getopt_private {$/;"	n	namespace:openvpn
giaddr	ip/dhcp.hpp	/^    std::uint32_t giaddr;     \/* relay agent IP address *\/$/;"	m	struct:openvpn::DHCP
gid	common/peercred.hpp	/^      int gid;$/;"	m	struct:openvpn::SockOpt::Creds
glob_	common/glob.hpp	/^    ::glob_t glob_;$/;"	m	class:openvpn::Glob
global_log	log/logthread.hpp	/^    OPENVPN_EXTERN OPENVPN_LOG_CLASS* global_log; \/\/ GLOBAL$/;"	m	namespace:openvpn::Log
google_dns_fallback	client/cliopt.hpp	/^      bool google_dns_fallback = false;$/;"	m	struct:openvpn::ClientOptions::Config
google_dns_fallback	tun/client/tunprop.hpp	/^      bool google_dns_fallback = false;$/;"	m	struct:openvpn::TunProp::Config
gr	common/usergroup.hpp	/^    struct group *gr;$/;"	m	class:openvpn::SetUserGroup	typeref:struct:openvpn::SetUserGroup::group
graceful_stop	client/cliconnect.hpp	/^    void graceful_stop()$/;"	f	class:openvpn::ClientConnect
gremlin	transport/tcplink.hpp	/^      std::unique_ptr<Gremlin::SendRecvQueue> gremlin;$/;"	m	class:openvpn::TCPTransport::Link
gremlin	transport/udplink.hpp	/^      std::unique_ptr<Gremlin::SendRecvQueue> gremlin;$/;"	m	class:openvpn::UDPTransport::Link
gremlin_config	client/cliopt.hpp	/^      Gremlin::Config::Ptr gremlin_config;$/;"	m	struct:openvpn::ClientOptions::Config
gremlin_config	client/cliopt.hpp	/^    Gremlin::Config::Ptr gremlin_config;$/;"	m	class:openvpn::ClientOptions
gremlin_config	transport/client/tcpcli.hpp	/^      Gremlin::Config::Ptr gremlin_config;$/;"	m	class:openvpn::TCPTransport::ClientConfig
gremlin_config	transport/client/udpcli.hpp	/^      Gremlin::Config::Ptr gremlin_config;$/;"	m	class:openvpn::UDPTransport::ClientConfig
gremlin_config	transport/tcplink.hpp	/^      void gremlin_config(const Gremlin::Config::Ptr& config)$/;"	f	class:openvpn::TCPTransport::Link
gremlin_config	transport/udplink.hpp	/^      void gremlin_config(const Gremlin::Config::Ptr& config)$/;"	f	class:openvpn::UDPTransport::Link
gremlin_queue_send_buffer	transport/tcplink.hpp	/^      void gremlin_queue_send_buffer(BufferPtr& buf)$/;"	f	class:openvpn::TCPTransport::Link
gremlin_recv	transport/tcplink.hpp	/^      bool gremlin_recv(BufferAllocated& buf)$/;"	f	class:openvpn::TCPTransport::Link
gremlin_recv	transport/udplink.hpp	/^      void gremlin_recv(PacketFrom::SPtr& pfp)$/;"	f	class:openvpn::UDPTransport::Link
gremlin_send	transport/udplink.hpp	/^      void gremlin_send(const Buffer& buf, const AsioEndpoint* endpoint)$/;"	f	class:openvpn::UDPTransport::Link
group_name	common/usergroup.hpp	/^    std::string group_name;$/;"	m	class:openvpn::SetUserGroup
grow	common/msgwin.hpp	/^    void grow(const id_t id)$/;"	f	class:openvpn::MessageWindow
gtc_base	time/time.hpp	/^    static time_t gtc_base;$/;"	m	class:openvpn::TimeType
gtc_base	time/time.hpp	/^  template <typename T> time_t TimeType<T>::gtc_base;$/;"	m	class:openvpn::TimeType
gtc_last	time/time.hpp	/^    static DWORD gtc_last;$/;"	m	class:openvpn::TimeType
gtc_last	time/time.hpp	/^  template <typename T> DWORD TimeType<T>::gtc_last;$/;"	m	class:openvpn::TimeType
gui_version	client/cliopt.hpp	/^      std::string gui_version;$/;"	m	struct:openvpn::ClientOptions::Config
gui_version	ssl/proto.hpp	/^      std::string gui_version;$/;"	m	class:openvpn::ProtoContext::Config
guid	tun/win/tunutil.hpp	/^	std::string guid;$/;"	m	struct:openvpn::TunWin::Util::TapNameGuidPair
guid_from_name	tun/win/tunutil.hpp	/^	std::string guid_from_name(const std::string& name) const$/;"	f	struct:openvpn::TunWin::Util::TapNameGuidPairList
halfBase	common/unicode-impl.hpp	/^    const UTF32 halfBase = 0x0010000UL;$/;"	m	namespace:openvpn::Unicode
halfMask	common/unicode-impl.hpp	/^    const UTF32 halfMask = 0x3FFUL;$/;"	m	namespace:openvpn::Unicode
halfShift	common/unicode-impl.hpp	/^    const int halfShift  = 10; \/* used for shifting by 10 bits *\/$/;"	m	namespace:openvpn::Unicode
halt	client/cliconnect.hpp	/^    bool halt;$/;"	m	class:openvpn::ClientConnect
halt	client/cliproto.hpp	/^      bool halt = false;$/;"	m	class:openvpn::ClientProto::Session
halt	common/action.hpp	/^    void halt()$/;"	f	class:openvpn::ActionList
halt	common/asiosignal.hpp	/^    bool halt;$/;"	m	class:openvpn::ASIOSignals
halt	common/runcontext.hpp	/^    volatile bool halt = false;$/;"	m	class:openvpn::RunContext
halt	server/servproto.hpp	/^      bool halt;$/;"	m	class:openvpn::ServerProto::Session
halt	transport/client/httpcli.hpp	/^      bool halt;$/;"	m	class:openvpn::HTTPProxyTransport::Client
halt	transport/client/tcpcli.hpp	/^      bool halt;$/;"	m	class:openvpn::TCPTransport::Client
halt	transport/client/udpcli.hpp	/^      bool halt;$/;"	m	class:openvpn::UDPTransport::Client
halt	transport/tcplink.hpp	/^      bool halt;$/;"	m	class:openvpn::TCPTransport::Link
halt	transport/udplink.hpp	/^      bool halt;$/;"	m	class:openvpn::UDPTransport::Link
halt	tun/builder/client.hpp	/^      bool halt;$/;"	m	class:openvpn::TunBuilderClient::Client
halt	tun/linux/client/tuncli.hpp	/^      bool halt;$/;"	m	class:openvpn::TunLinux::Client
halt	tun/mac/client/tuncli.hpp	/^      bool halt;$/;"	m	class:openvpn::TunMac::Client
halt	tun/tunio.hpp	/^    bool halt;$/;"	m	class:openvpn::TunIO
halt	tun/win/client/tuncli.hpp	/^      bool halt;$/;"	m	class:openvpn::TunWin::Client
halt_	common/action.hpp	/^    volatile bool halt_ = false;$/;"	m	class:openvpn::ActionList
handle	common/asiopolysock.hpp	/^      asio::windows::stream_handle handle;$/;"	m	struct:openvpn::AsioPolySock::NamedPipe
handle	tun/win/wfp.hpp	/^	HANDLE handle = NULL;$/;"	m	class:openvpn::TunWin::WFP::WFPEngine
handle	win/scoped_handle.hpp	/^      HANDLE handle;$/;"	m	class:openvpn::Win::ScopedHANDLE
handle_proto_override	client/remotelist.hpp	/^    void handle_proto_override(const Protocol& proto_override, const bool tcp_proxy_enabled)$/;"	f	class:openvpn::RemoteList
handle_read	transport/udplink.hpp	/^      void handle_read(PacketFrom *udpfrom, const asio::error_code& error, const size_t bytes_recvd)$/;"	f	class:openvpn::UDPTransport::Link
handle_read	tun/tunio.hpp	/^    void handle_read(PacketFrom *tunfrom, const asio::error_code& error, const size_t bytes_recvd)$/;"	f	class:openvpn::TunIO
handle_recv	transport/tcplink.hpp	/^      void handle_recv(PacketFrom *tcpfrom, const asio::error_code& error, const size_t bytes_recvd)$/;"	f	class:openvpn::TCPTransport::Link
handle_send	transport/tcplink.hpp	/^      void handle_send(const asio::error_code& error, const size_t bytes_sent)$/;"	f	class:openvpn::TCPTransport::Link
handler_t	common/signal.hpp	/^    typedef void (*handler_t)(int signum);$/;"	t	class:openvpn::Signal
handshake_window	ssl/proto.hpp	/^      Time::Duration handshake_window; \/\/ SSL\/TLS negotiation must complete by this time$/;"	m	class:openvpn::ProtoContext::Config
hasEmbeddedPassword	client/cliopthelper.hpp	/^    bool hasEmbeddedPassword() const { return hasEmbeddedPassword_; }$/;"	f	class:openvpn::ParseClientConfig
hasEmbeddedPassword_	client/cliopthelper.hpp	/^    bool hasEmbeddedPassword_;$/;"	m	class:openvpn::ParseClientConfig
has_arg	common/getopt.hpp	/^    int has_arg;$/;"	m	struct:openvpn::option
hash	ssl/tlsprf.hpp	/^    static void hash (const CryptoAlgs::Type md,$/;"	f	class:openvpn::TLSPRF
hash_value	addr/route.hpp	/^      std::size_t hash_value() const$/;"	f	struct:openvpn::IP::RouteType
hashval	addr/ip.hpp	/^      std::size_t hashval() const$/;"	f	class:openvpn::IP::Addr
hashval	addr/ipv4.hpp	/^      std::size_t hashval() const$/;"	f	class:openvpn::IPv4::Addr
hashval	addr/ipv6.hpp	/^      std::size_t hashval() const$/;"	f	class:openvpn::IPv6::Addr
hd	ip/icmp.hpp	/^    } hd;$/;"	m	struct:openvpn::ICMP	typeref:union:openvpn::ICMP::__anon48
head	common/rc.hpp	/^      typename RCImpl::template ListHead<NotifyBase> head;$/;"	m	class:openvpn::RCWeak::NotifyListHead
head	ip/icmp.hpp	/^    struct IPHeader head;$/;"	m	struct:openvpn::ICMP	typeref:struct:openvpn::ICMP::IPHeader
head_	common/circ_list.hpp	/^    size_t head_;$/;"	m	class:openvpn::CircList
head_defined	common/msgwin.hpp	/^    bool head_defined() const$/;"	f	class:openvpn::MessageWindow
head_id	common/msgwin.hpp	/^    id_t head_id() const { return head_id_; }$/;"	f	class:openvpn::MessageWindow
head_id	reliable/relsend.hpp	/^    id_t head_id() const { return window_.head_id(); }$/;"	f	class:openvpn::ReliableSendTemplate
head_id_	common/msgwin.hpp	/^    id_t head_id_; \/\/ id of msgs[0]$/;"	m	class:openvpn::MessageWindow
header_line_start	http/reply.hpp	/^	  header_line_start,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
header_line_start	http/request.hpp	/^	  header_line_start,$/;"	e	enum:openvpn::HTTP::RequestParser::state
header_lws	http/reply.hpp	/^	  header_lws,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
header_lws	http/request.hpp	/^	  header_lws,$/;"	e	enum:openvpn::HTTP::RequestParser::state
header_name	http/reply.hpp	/^	  header_name,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
header_name	http/request.hpp	/^	  header_name,$/;"	e	enum:openvpn::HTTP::RequestParser::state
header_value	http/reply.hpp	/^	  header_value,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
header_value	http/request.hpp	/^	  header_value,$/;"	e	enum:openvpn::HTTP::RequestParser::state
headers	http/reply.hpp	/^      HeaderList headers;$/;"	m	struct:openvpn::HTTP::Reply
headers	http/request.hpp	/^      HeaderList headers;$/;"	m	struct:openvpn::HTTP::Request
headers	transport/client/httpcli.hpp	/^      CustomHeaderList headers;$/;"	m	class:openvpn::HTTPProxyTransport::Options
headroom	frame/frame.hpp	/^      size_t headroom() const { return adj_headroom_; }$/;"	f	class:openvpn::Frame::Context
headroom_	frame/frame.hpp	/^      size_t headroom_;$/;"	m	class:openvpn::Frame::Context
history	crypto/packet_id.hpp	/^    std::uint8_t history[REPLAY_WINDOW_BYTES]; \/* "sliding window" bitmask of recent packet IDs received *\/$/;"	m	class:openvpn::PacketIDReceiveType
hlen	ip/dhcp.hpp	/^    std::uint8_t  hlen;       \/* hardware address length (e.g. '6' for 10Mb Ethernet) *\/$/;"	m	struct:openvpn::DHCP
hmac	crypto/decrypt_chm.hpp	/^    OvpnHMAC<CRYPTO_API> hmac;$/;"	m	class:openvpn::DecryptCHM
hmac	crypto/encrypt_chm.hpp	/^    OvpnHMAC<CRYPTO_API> hmac;$/;"	m	class:openvpn::EncryptCHM
hmac	crypto/ovpnhmac.hpp	/^    void hmac(unsigned char *out, const size_t out_size,$/;"	f	class:openvpn::OvpnHMAC
hmac_alg	applecrypto/crypto/digest.hpp	/^      CCHmacAlgorithm hmac_alg() const { return hmac_alg_; }$/;"	f	class:openvpn::AppleCrypto::DigestInfo
hmac_alg	applecrypto/crypto/hmac.hpp	/^      CCHmacAlgorithm hmac_alg;$/;"	m	class:openvpn::AppleCrypto::HMACContext
hmac_alg	crypto/cryptodc.hpp	/^      CryptoAlgs::Type hmac_alg;$/;"	m	struct:openvpn::CryptoDCContext::Info
hmac_alg_	applecrypto/crypto/digest.hpp	/^      CCHmacAlgorithm hmac_alg_;$/;"	m	class:openvpn::AppleCrypto::DigestInfo
hmac_size	ssl/proto.hpp	/^    size_t hmac_size;$/;"	m	class:openvpn::ProtoContext
hops	ip/dhcp.hpp	/^    std::uint8_t  hops;       \/* client sets to 0, may be used by relay agents *\/$/;"	m	struct:openvpn::DHCP
host	client/cliopthelper.hpp	/^      std::string host;$/;"	m	struct:openvpn::ParseClientConfig::RemoteItem
host	common/hostlist.hpp	/^      std::string host;$/;"	m	struct:openvpn::HostList::Host
host	http/urlparse.hpp	/^      std::string host;$/;"	m	class:openvpn::URL::Parse
host	tun/builder/capture.hpp	/^      std::string host;$/;"	m	class:openvpn::TunBuilderCapture::ProxyHostPort
host_len	addr/ip.hpp	/^      unsigned int host_len() const$/;"	f	class:openvpn::IP::Addr
host_len	addr/ipv4.hpp	/^      unsigned int host_len() const$/;"	f	class:openvpn::IPv4::Addr
host_len	addr/ipv6.hpp	/^      unsigned int host_len() const$/;"	f	class:openvpn::IPv6::Addr
host_to_network_order	addr/ipv6.hpp	/^      static void host_to_network_order(union ipv6addr *dest, const union ipv6addr *src)$/;"	f	class:openvpn::IPv6::Addr
housekeeping	ssl/proto.hpp	/^    void housekeeping()$/;"	f	class:openvpn::ProtoContext
housekeeping_callback	client/cliproto.hpp	/^      void housekeeping_callback(const asio::error_code& e)$/;"	f	class:openvpn::ClientProto::Session
housekeeping_callback	server/servproto.hpp	/^      void housekeeping_callback(const asio::error_code& e)$/;"	f	class:openvpn::ServerProto::Session
housekeeping_schedule	client/cliproto.hpp	/^      CoarseTime housekeeping_schedule;$/;"	m	class:openvpn::ClientProto::Session
housekeeping_schedule	server/servproto.hpp	/^      CoarseTime housekeeping_schedule;$/;"	m	class:openvpn::ServerProto::Session
housekeeping_timer	client/cliproto.hpp	/^      AsioTimer housekeeping_timer;$/;"	m	class:openvpn::ClientProto::Session
housekeeping_timer	server/servproto.hpp	/^      AsioTimer housekeeping_timer;$/;"	m	class:openvpn::ServerProto::Session
html_skip	transport/client/httpcli.hpp	/^      std::unique_ptr<HTTP::HTMLSkip> html_skip;$/;"	m	class:openvpn::HTTPProxyTransport::Client
http_parser	transport/client/httpcli.hpp	/^      HTTP::ReplyParser http_parser;$/;"	m	class:openvpn::HTTPProxyTransport::Client
http_proxy	tun/builder/capture.hpp	/^    ProxyHostPort http_proxy;$/;"	m	class:openvpn::TunBuilderCapture
http_proxy_options	client/cliopt.hpp	/^      HTTPProxyTransport::Options::Ptr http_proxy_options;$/;"	m	struct:openvpn::ClientOptions::Config
http_proxy_options	client/cliopt.hpp	/^    HTTPProxyTransport::Options::Ptr http_proxy_options;$/;"	m	class:openvpn::ClientOptions
http_proxy_options	transport/client/httpcli.hpp	/^      Options::Ptr http_proxy_options;$/;"	m	class:openvpn::HTTPProxyTransport::ClientConfig
http_proxy_send	transport/client/httpcli.hpp	/^      void http_proxy_send()$/;"	f	class:openvpn::HTTPProxyTransport::Client
http_reply	transport/client/httpcli.hpp	/^      HTTP::Reply http_reply;$/;"	m	class:openvpn::HTTPProxyTransport::Client
http_reply_status	transport/client/httpcli.hpp	/^      HTTP::ReplyParser::status http_reply_status;$/;"	m	class:openvpn::HTTPProxyTransport::Client
http_request	transport/client/httpcli.hpp	/^      std::string http_request;$/;"	m	class:openvpn::HTTPProxyTransport::Client
http_version	transport/client/httpcli.hpp	/^      std::string http_version;$/;"	m	class:openvpn::HTTPProxyTransport::Options
http_version_h	http/reply.hpp	/^	  http_version_h,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
http_version_h	http/request.hpp	/^	  http_version_h,$/;"	e	enum:openvpn::HTTP::RequestParser::state
http_version_major	http/reply.hpp	/^	  http_version_major,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
http_version_major	http/reply.hpp	/^      int http_version_major;$/;"	m	struct:openvpn::HTTP::Reply
http_version_major	http/request.hpp	/^	  http_version_major,$/;"	e	enum:openvpn::HTTP::RequestParser::state
http_version_major	http/request.hpp	/^      int http_version_major;$/;"	m	struct:openvpn::HTTP::Request
http_version_major_start	http/reply.hpp	/^	  http_version_major_start,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
http_version_major_start	http/request.hpp	/^	  http_version_major_start,$/;"	e	enum:openvpn::HTTP::RequestParser::state
http_version_minor	http/reply.hpp	/^	  http_version_minor,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
http_version_minor	http/reply.hpp	/^      int http_version_minor;$/;"	m	struct:openvpn::HTTP::Reply
http_version_minor	http/request.hpp	/^	  http_version_minor,$/;"	e	enum:openvpn::HTTP::RequestParser::state
http_version_minor	http/request.hpp	/^      int http_version_minor;$/;"	m	struct:openvpn::HTTP::Request
http_version_minor_start	http/reply.hpp	/^	  http_version_minor_start,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
http_version_minor_start	http/request.hpp	/^	  http_version_minor_start,$/;"	e	enum:openvpn::HTTP::RequestParser::state
http_version_p	http/reply.hpp	/^	  http_version_p,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
http_version_p	http/request.hpp	/^	  http_version_p,$/;"	e	enum:openvpn::HTTP::RequestParser::state
http_version_slash	http/reply.hpp	/^	  http_version_slash,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
http_version_slash	http/request.hpp	/^	  http_version_slash,$/;"	e	enum:openvpn::HTTP::RequestParser::state
http_version_t_1	http/reply.hpp	/^	  http_version_t_1,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
http_version_t_1	http/request.hpp	/^	  http_version_t_1,$/;"	e	enum:openvpn::HTTP::RequestParser::state
http_version_t_2	http/reply.hpp	/^	  http_version_t_2,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
http_version_t_2	http/request.hpp	/^	  http_version_t_2,$/;"	e	enum:openvpn::HTTP::RequestParser::state
https_proxy	tun/builder/capture.hpp	/^    ProxyHostPort https_proxy;$/;"	m	class:openvpn::TunBuilderCapture
htype	ip/dhcp.hpp	/^    std::uint8_t  htype;      \/* hardware address type (e.g. '1' = 10Mb Ethernet) *\/$/;"	m	struct:openvpn::DHCP
hwaddr	tun/mac/gwv4.hpp	/^    const MACAddr& hwaddr() const { return hwaddr_; }$/;"	f	class:openvpn::MacGatewayInfoV4
hwaddr_	tun/mac/gwv4.hpp	/^    MACAddr hwaddr_;$/;"	m	class:openvpn::MacGatewayInfoV4
hwaddr_defined	tun/mac/gwv4.hpp	/^    bool hwaddr_defined() const$/;"	f	class:openvpn::MacGatewayInfoV4
iOSActiveInterface	applecrypto/util/iosactiveiface.hpp	/^  class iOSActiveInterface : public ReachabilityInterface$/;"	c	namespace:openvpn
id	client/clievent.hpp	/^      Type id() const { return id_; }$/;"	f	class:openvpn::ClientEvent::Base
id	common/asioboundsock.hpp	/^      static asio::detail::service_id<SocketService> id; \/\/ register the service$/;"	m	struct:openvpn::AsioBoundSocket::SocketService
id	common/asioboundsock.hpp	/^    OPENVPN_EXTERN asio::detail::service_id<SocketService> SocketService::id;$/;"	m	class:openvpn::AsioBoundSocket::SocketService
id	crypto/packet_id.hpp	/^    id_t id;       \/\/ legal values are 1 through 2^32-1$/;"	m	struct:openvpn::PacketID
id	ip/icmp.hpp	/^	std::uint16_t id;$/;"	m	struct:openvpn::ICMP::__anon48::__anon49
id	ip/ip.hpp	/^    std::uint16_t   id;$/;"	m	struct:openvpn::IPHeader
id	reliable/relcommon.hpp	/^    id_t id() const { return id_; }$/;"	f	class:openvpn::ReliableMessageBase
id_	client/clievent.hpp	/^      Type id_;$/;"	m	class:openvpn::ClientEvent::Base
id_	reliable/relcommon.hpp	/^    id_t id_;$/;"	m	class:openvpn::ReliableMessageBase
id_	ssl/psid.hpp	/^    unsigned char id_[SIZE];$/;"	m	class:openvpn::ProtoSessionID
id_floor	crypto/packet_id.hpp	/^    PacketID::id_t id_floor;        \/\/ we will only accept backtrack IDs > id_floor$/;"	m	class:openvpn::PacketIDReceiveType
id_high	crypto/packet_id.hpp	/^    PacketID::id_t id_high;         \/\/ highest sequence number received$/;"	m	class:openvpn::PacketIDReceiveType
id_t	crypto/packet_id.hpp	/^    typedef std::uint32_t id_t;$/;"	t	struct:openvpn::PacketID
id_t	reliable/relack.hpp	/^    typedef reliable::id_t id_t;$/;"	t	class:openvpn::ReliableAck
id_t	reliable/relcommon.hpp	/^    typedef PacketID::id_t id_t;    $/;"	t	namespace:openvpn::reliable
id_t	reliable/relcommon.hpp	/^    typedef reliable::id_t id_t;$/;"	t	class:openvpn::ReliableMessageBase
id_t	reliable/relrecv.hpp	/^    typedef reliable::id_t id_t;$/;"	t	class:openvpn::ReliableRecvTemplate
id_t	reliable/relsend.hpp	/^    typedef reliable::id_t id_t;$/;"	t	class:openvpn::ReliableSendTemplate
id_t	ssl/protostack.hpp	/^    typedef reliable::id_t id_t;$/;"	t	class:openvpn::ProtoStackBase
identity	applecrypto/ssl/sslctx.hpp	/^      CF::Array identity; \/\/ as returned by load_identity$/;"	m	class:openvpn::AppleSSLContext::Config
identity	applecrypto/ssl/sslctx.hpp	/^    const CF::Array& identity() const { return config_->identity; }$/;"	f	class:openvpn::AppleSSLContext
idx	common/action.hpp	/^      size_t idx;$/;"	m	class:openvpn::ActionList::Iter
iface	apple/maclife.hpp	/^      std::string iface;$/;"	m	struct:openvpn::MacLifeCycle::State
iface	tun/mac/gwv4.hpp	/^    std::string iface() const { return iface_; }$/;"	f	class:openvpn::MacGatewayInfoV4
iface	tun/mac/macgw.hpp	/^      std::string iface;$/;"	m	struct:openvpn::MacGWInfo::Variant
iface	tun/win/tunutil.hpp	/^	IP_ADAPTER_INDEX_MAP* iface(const DWORD index) const$/;"	f	struct:openvpn::TunWin::Util::InterfaceInfoList
iface_	tun/mac/gwv4.hpp	/^    char iface_[16];$/;"	m	class:openvpn::MacGatewayInfoV4
iface_addr_defined	tun/mac/gwv4.hpp	/^    bool iface_addr_defined() const$/;"	f	class:openvpn::MacGatewayInfoV4
iface_config	tun/linux/client/tuncli.hpp	/^    inline void iface_config(const std::string& iface_name,$/;"	f	namespace:openvpn::TunLinux
iface_index	tun/win/tunutil.hpp	/^	const DWORD iface_index;$/;"	m	class:openvpn::TunWin::Util::ActionDeleteAllRoutesOnInterface
iface_name	tun/client/tunprop.hpp	/^      std::string iface_name;$/;"	m	struct:openvpn::TunProp::State
iface_name	tun/mac/client/tunsetup.hpp	/^	std::string iface_name;$/;"	m	struct:openvpn::TunMac::Setup::Config
iface_up	netconf/enumiface.hpp	/^      bool iface_up(const char *iface) const$/;"	f	class:openvpn::EnumIface
iface_up	tun/linux/client/tuncli.hpp	/^    inline void iface_up(const std::string& iface_name,$/;"	f	namespace:openvpn::TunLinux
iface_watch	apple/maclife.hpp	/^    void iface_watch()$/;"	f	class:openvpn::MacLifeCycle
iface_watch_callback	apple/maclife.hpp	/^    void iface_watch_callback(SCDynamicStoreRef store, CFArrayRef changedKeys)$/;"	f	class:openvpn::MacLifeCycle
iface_watch_callback_static	apple/maclife.hpp	/^    static void iface_watch_callback_static(SCDynamicStoreRef store, CFArrayRef changedKeys, void *arg)$/;"	f	class:openvpn::MacLifeCycle
ifinfo	netconf/enumiface.hpp	/^      std::unique_ptr<ifaddrs, decltype(&free_if_addrs)> ifinfo;$/;"	m	class:openvpn::EnumIface
ignore_line	common/options.hpp	/^    static bool ignore_line(const std::string& line)$/;"	f	class:openvpn::OptionList
impl	crypto/crypto_aead.hpp	/^	typename CRYPTO_API::CipherContextGCM impl;$/;"	m	struct:openvpn::AEAD::Crypto::Decrypt
impl	crypto/crypto_aead.hpp	/^	typename CRYPTO_API::CipherContextGCM impl;$/;"	m	struct:openvpn::AEAD::Crypto::Encrypt
impl	crypto/digestapi.hpp	/^    typename CRYPTO_API::DigestContext impl;$/;"	m	class:openvpn::CryptoDigestInstance
impl	crypto/digestapi.hpp	/^    typename CRYPTO_API::HMACContext impl;$/;"	m	class:openvpn::CryptoHMACInstance
impl	transport/client/httpcli.hpp	/^      LinkImpl::Ptr impl;$/;"	m	class:openvpn::HTTPProxyTransport::Client
impl	transport/client/tcpcli.hpp	/^      LinkImpl::Ptr impl;$/;"	m	class:openvpn::TCPTransport::Client
impl	transport/client/udpcli.hpp	/^      LinkImpl::Ptr impl;$/;"	m	class:openvpn::UDPTransport::Client
impl	tun/builder/client.hpp	/^      TunImpl::Ptr impl;$/;"	m	class:openvpn::TunBuilderClient::Client
impl	tun/linux/client/tuncli.hpp	/^      TunImpl::Ptr impl;$/;"	m	class:openvpn::TunLinux::Client
impl	tun/mac/client/tuncli.hpp	/^      TunImpl::Ptr impl;$/;"	m	class:openvpn::TunMac::Client
impl	tun/win/client/tuncli.hpp	/^      TunImpl::Ptr impl;$/;"	m	class:openvpn::TunWin::Client
implementation_type	common/asioboundsock.hpp	/^      struct implementation_type : public SocketServiceBase::implementation_type$/;"	s	struct:openvpn::AsioBoundSocket::SocketService
in	common/redir.hpp	/^      std::string in;$/;"	m	struct:openvpn::RedirectPipe::InOut
in	common/redir.hpp	/^    ScopedFD in;$/;"	m	struct:openvpn::RedirectStdFD
in_comment	common/options.hpp	/^      bool in_comment;$/;"	m	class:openvpn::OptionList::LexComment
in_quote	common/lex.hpp	/^    bool in_quote() const { return false; }$/;"	f	class:openvpn::NullLex
in_quote	common/lex.hpp	/^    bool in_quote() const { return in_quote_; }$/;"	f	class:openvpn::StandardLex
in_quote	common/options.hpp	/^      bool in_quote() const { return in_quote_; }$/;"	f	class:openvpn::OptionList::LexComment
in_quote_	common/lex.hpp	/^    bool in_quote_;$/;"	m	class:openvpn::StandardLex
in_quote_	common/options.hpp	/^      bool in_quote_;$/;"	m	class:openvpn::OptionList::LexComment
in_window	common/msgwin.hpp	/^    bool in_window(const id_t id) const$/;"	f	class:openvpn::MessageWindow
inactive_bytes	client/cliproto.hpp	/^      unsigned int inactive_bytes = 0;$/;"	m	class:openvpn::ClientProto::Session
inactive_callback	client/cliproto.hpp	/^      void inactive_callback(const asio::error_code& e) \/\/ fixme for DCO$/;"	f	class:openvpn::ClientProto::Session
inactive_duration	client/cliproto.hpp	/^      Time::Duration inactive_duration;$/;"	m	class:openvpn::ClientProto::Session
inactive_last_sample	client/cliproto.hpp	/^      count_t inactive_last_sample = 0;$/;"	m	class:openvpn::ClientProto::Session
inactive_timer	client/cliproto.hpp	/^      AsioTimer inactive_timer;$/;"	m	class:openvpn::ClientProto::Session
inc_size	buffer/buffer.hpp	/^    void inc_size(const size_t delta)$/;"	f	class:openvpn::BufferType
inc_stat	log/sessionstats.hpp	/^    void inc_stat(const size_t type, const count_t value)$/;"	f	class:openvpn::SessionStats
include	client/cliemuexr.hpp	/^    IP::RouteList include;$/;"	m	class:openvpn::EmulateExcludeRouteImpl
increment	client/remotelist.hpp	/^      bool increment(const size_t pri_len, const size_t sec_len)$/;"	f	class:openvpn::RemoteList::Index
incremental_copy	compress/lzoasym_impl.hpp	/^    inline void incremental_copy(unsigned char *dest, const unsigned char *src, ssize_t len)$/;"	f	namespace:openvpn::lzo_asym_impl
incremental_copy_fast	compress/lzoasym_impl.hpp	/^    inline void incremental_copy_fast(unsigned char *dest, const unsigned char *src, ssize_t len)$/;"	f	namespace:openvpn::lzo_asym_impl
indent	common/string.hpp	/^    inline std::string indent(const std::string& str, const int first, const int remaining)$/;"	f	namespace:openvpn::string
index	buffer/buffer.hpp	/^    T* index(const size_t index)$/;"	f	class:openvpn::BufferType
index	client/remotelist.hpp	/^      size_t index;$/;"	m	class:openvpn::RemoteList::PreResolve
index	client/remotelist.hpp	/^    Index index;$/;"	m	class:openvpn::RemoteList
index	common/action.hpp	/^      size_t index() const$/;"	f	class:openvpn::ActionList::Iter
index	common/asiopolysock.hpp	/^      size_t index() const { return index_; }$/;"	f	class:openvpn::AsioPolySock::Base
index	common/hostlist.hpp	/^      int index;$/;"	m	class:openvpn::HostList::Iterator
index	common/splitlines.hpp	/^    size_t index = 0;$/;"	m	class:openvpn::SplitLinesType
index	common/stop.hpp	/^      int index;$/;"	m	class:openvpn::Stop::Scope
index	tun/win/tunutil.hpp	/^	DWORD index;$/;"	m	class:openvpn::TunWin::Util::DefaultGateway
index	tun/win/tunutil.hpp	/^	DWORD index;$/;"	m	struct:openvpn::TunWin::Util::TapNameGuidPair
index_	common/asiopolysock.hpp	/^      size_t index_;$/;"	m	class:openvpn::AsioPolySock::Base
index_defined	tun/win/tunutil.hpp	/^	bool index_defined() const { return index != DWORD(-1); }$/;"	f	struct:openvpn::TunWin::Util::TapNameGuidPair
index_or_name	tun/win/tunutil.hpp	/^	std::string index_or_name() const$/;"	f	struct:openvpn::TunWin::Util::TapNameGuidPair
indices	tun/win/client/tunsetup.hpp	/^	int indices[2] = {0, 0};$/;"	m	class:openvpn::TunWin::Setup::UseDNS
infinite	time/time.hpp	/^      static Duration infinite() { return Duration(std::numeric_limits<T>::max()); }$/;"	f	class:openvpn::TimeType::Duration
infinite	time/time.hpp	/^    static TimeType infinite() { return TimeType(std::numeric_limits<T>::max()); }$/;"	f	class:openvpn::TimeType
info	applecrypto/crypto/digest.hpp	/^      const DigestInfo *info;$/;"	m	class:openvpn::AppleCrypto::DigestContext
info	applecrypto/crypto/hmac.hpp	/^      const DigestInfo *info;$/;"	m	class:openvpn::AppleCrypto::HMACContext
info	client/cliopt.hpp	/^      bool info = false;$/;"	m	struct:openvpn::ClientOptions::Config
info	client/cliopt.hpp	/^    bool info;$/;"	m	class:openvpn::ClientOptions
info	client/cliproto.hpp	/^	bool info = false;$/;"	m	struct:openvpn::ClientProto::Session::Config
info	client/cliproto.hpp	/^      bool info;$/;"	m	class:openvpn::ClientProto::Session
info	frame/frame.hpp	/^      std::string info() const$/;"	f	class:openvpn::Frame::Context
info	tun/mac/gwv4.hpp	/^    std::string info() const$/;"	f	class:openvpn::MacGatewayInfoV4
info	tun/mac/macdns.hpp	/^      DSDict info; \/\/ we may modify$/;"	m	class:openvpn::MacDNS::Info
info	tun/win/tunutil.hpp	/^	ULONG info[3];$/;"	m	class:openvpn::TunWin::Util::TAPDriverVersion
info_callback	openssl/ssl/sslctx.hpp	/^    static void info_callback (const ::SSL *s, int where, int ret)$/;"	f	class:openvpn::OpenSSLContext
info_hold	client/cliproto.hpp	/^      std::unique_ptr<std::vector<ClientEvent::Base::Ptr>> info_hold;$/;"	m	class:openvpn::ClientProto::Session
info_hold_callback	client/cliproto.hpp	/^      void info_hold_callback(const asio::error_code& e)$/;"	f	class:openvpn::ClientProto::Session
info_hold_timer	client/cliproto.hpp	/^      AsioTimer info_hold_timer;$/;"	m	class:openvpn::ClientProto::Session
init	apple/ver.hpp	/^    void init(const std::string& verstr)$/;"	f	class:openvpn::AppleVersion
init	applecrypto/crypto/cipher.hpp	/^      void init(const CryptoAlgs::Type alg, const unsigned char *key, const int mode)$/;"	f	class:openvpn::AppleCrypto::CipherContext
init	applecrypto/crypto/digest.hpp	/^      void init(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::AppleCrypto::DigestContext
init	applecrypto/crypto/hmac.hpp	/^      void init(const CryptoAlgs::Type digest, const unsigned char *key, const size_t key_size)$/;"	f	class:openvpn::AppleCrypto::HMACContext
init	auth/cr.hpp	/^    void init(const std::string& cookie)$/;"	f	class:openvpn::ChallengeResponse
init	buffer/buffer.hpp	/^    void init(const T* data, const size_t size, const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
init	buffer/buffer.hpp	/^    void init(const size_t capacity, const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
init	client/remotelist.hpp	/^      void init(const std::string& connection_tag)$/;"	f	struct:openvpn::RemoteList::Directives
init	client/remotelist.hpp	/^    void init(const std::string& connection_tag)$/;"	f	class:openvpn::RemoteList
init	client/rgopt.hpp	/^    void init(const OptionList& opt)$/;"	f	class:openvpn::RedirectGatewayFlags
init	common/circ_list.hpp	/^    void init(const size_t capacity)$/;"	f	class:openvpn::CircList
init	common/msgwin.hpp	/^    void init(const id_t starting_head_id, const id_t span)$/;"	f	class:openvpn::MessageWindow
init	crypto/cipher.hpp	/^    void init(const CryptoAlgs::Type cipher, const StaticKey& key, const int mode)$/;"	f	class:openvpn::CipherContext
init	crypto/ovpnhmac.hpp	/^    virtual void init(const StaticKey& key)$/;"	f	class:openvpn::CryptoOvpnHMACInstance
init	crypto/ovpnhmac.hpp	/^    void init(const CryptoAlgs::Type digest, const StaticKey& key)$/;"	f	class:openvpn::OvpnHMAC
init	crypto/packet_id.hpp	/^    void init(const int form) \/\/ PacketID::LONG_FORM or PacketID::SHORT_FORM$/;"	f	class:openvpn::PacketIDSend
init	crypto/packet_id.hpp	/^    void init(const int mode_arg,$/;"	f	class:openvpn::PacketIDReceiveType
init	init/initprocess.hpp	/^    inline void init()$/;"	f	namespace:openvpn::InitProcess
init	openssl/crypto/cipher.hpp	/^      void init(const CryptoAlgs::Type alg, const unsigned char *key, const int mode)$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
init	openssl/crypto/ciphergcm.hpp	/^      void init(const CryptoAlgs::Type alg,$/;"	f	class:openvpn::OpenSSLCrypto::CipherContextGCM
init	openssl/crypto/digest.hpp	/^      void init(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
init	openssl/crypto/hmac.hpp	/^      void init(const CryptoAlgs::Type digest, const unsigned char *key, const size_t key_size)$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
init	openssl/pki/x509store.hpp	/^      void init()$/;"	f	class:openvpn::OpenSSLPKI::X509Store
init	polarssl/crypto/cipher.hpp	/^      void init(const CryptoAlgs::Type alg, const unsigned char *key, const int mode)$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
init	polarssl/crypto/ciphergcm.hpp	/^      void init(const CryptoAlgs::Type alg,$/;"	f	class:openvpn::PolarSSLCrypto::CipherContextGCM
init	polarssl/crypto/digest.hpp	/^      void init(const CryptoAlgs::Type alg)$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
init	polarssl/crypto/hmac.hpp	/^      void init(const CryptoAlgs::Type digest, const unsigned char *key, const size_t key_size)$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
init	reliable/relrecv.hpp	/^    void init(const id_t span)$/;"	f	class:openvpn::ReliableRecvTemplate
init	reliable/relsend.hpp	/^    void init(const id_t span)$/;"	f	class:openvpn::ReliableSendTemplate
init	time/coarsetime.hpp	/^    void init(const Time::Duration& pre, const Time::Duration& post)$/;"	f	class:openvpn::CoarseTime
init_cipher	crypto/crypto_aead.hpp	/^      virtual void init_cipher(StaticKey&& encrypt_key,$/;"	f	class:openvpn::AEAD::Crypto
init_cipher	crypto/crypto_chm.hpp	/^    virtual void init_cipher(StaticKey&& encrypt_key,$/;"	f	class:openvpn::CryptoCHM
init_data_channel	ssl/proto.hpp	/^      void init_data_channel()$/;"	f	class:openvpn::ProtoContext::KeyContext
init_data_channel	ssl/proto.hpp	/^    void init_data_channel()$/;"	f	class:openvpn::ProtoContext
init_error	openssl/util/error.hpp	/^    void init_error(const char *error_text)$/;"	f	class:openvpn::OpenSSLException
init_from_capture	tun/win/tunutil.hpp	/^	void init_from_capture(const TunBuilderCapture& pull)$/;"	f	class:openvpn::TunWin::Util::TAPDHCPMasquerade
init_headroom	buffer/buffer.hpp	/^    void init_headroom(const size_t headroom)$/;"	f	class:openvpn::BufferType
init_hmac	crypto/crypto_aead.hpp	/^      virtual void init_hmac(StaticKey&& encrypt_key,$/;"	f	class:openvpn::AEAD::Crypto
init_hmac	crypto/crypto_chm.hpp	/^    virtual void init_hmac(StaticKey&& encrypt_key,$/;"	f	class:openvpn::CryptoCHM
init_openssl	init/engineinit.hpp	/^  inline void init_openssl(const std::string& engine)$/;"	f	namespace:openvpn
init_pid	crypto/crypto_aead.hpp	/^      virtual void init_pid(const int send_form,$/;"	f	class:openvpn::AEAD::Crypto
init_pid	crypto/crypto_chm.hpp	/^    virtual void init_pid(const int send_form,$/;"	f	class:openvpn::CryptoCHM
init_snb_from_opt	server/vpnservpool.hpp	/^      static VPNServerNetblock init_snb_from_opt(const OptionList& opt)$/;"	f	class:openvpn::VPNServerPool::Pool
init_ssl_error	openssl/util/error.hpp	/^    void init_ssl_error(const int ssl_error, const char *error_text)$/;"	f	class:openvpn::OpenSSLException
init_static	compress/compress.hpp	/^    static void init_static()$/;"	f	class:openvpn::CompressContext
init_static	compress/lzo.hpp	/^    static void init_static()$/;"	f	class:openvpn::CompressLZO
init_static	compress/lzoasym.hpp	/^    static void init_static()$/;"	f	class:openvpn::CompressLZOAsym
init_static	openssl/ssl/sslctx.hpp	/^      static void init_static()$/;"	f	class:openvpn::OpenSSLContext::SSL
initial_op	ssl/proto.hpp	/^      unsigned int initial_op(const bool sender) const$/;"	f	class:openvpn::ProtoContext::KeyContext
initialized	applecrypto/crypto/digest.hpp	/^      bool initialized;$/;"	m	class:openvpn::AppleCrypto::DigestContext
initialized	crypto/packet_id.hpp	/^    bool initialized() const$/;"	f	class:openvpn::PacketIDReceiveType
initialized	openssl/crypto/cipher.hpp	/^      bool initialized;$/;"	m	class:openvpn::OpenSSLCrypto::CipherContext
initialized	openssl/crypto/ciphergcm.hpp	/^      bool initialized;$/;"	m	class:openvpn::OpenSSLCrypto::CipherContextGCM
initialized	openssl/crypto/digest.hpp	/^      bool initialized;$/;"	m	class:openvpn::OpenSSLCrypto::DigestContext
initialized	openssl/crypto/hmac.hpp	/^      bool initialized;$/;"	m	class:openvpn::OpenSSLCrypto::HMACContext
initialized	polarssl/crypto/cipher.hpp	/^      bool initialized;$/;"	m	class:openvpn::PolarSSLCrypto::CipherContext
initialized	polarssl/crypto/ciphergcm.hpp	/^      bool initialized;$/;"	m	class:openvpn::PolarSSLCrypto::CipherContextGCM
initialized	polarssl/crypto/digest.hpp	/^      bool initialized;$/;"	m	class:openvpn::PolarSSLCrypto::DigestContext
initialized	polarssl/crypto/hmac.hpp	/^      bool initialized;$/;"	m	class:openvpn::PolarSSLCrypto::HMACContext
initialized_	crypto/packet_id.hpp	/^    bool initialized_;$/;"	m	class:openvpn::PacketIDReceiveType
initialized_	ssl/tlsprf.hpp	/^    bool initialized_;$/;"	m	class:openvpn::TLSPRF
inject	transport/tcplink.hpp	/^      void inject(const Buffer& src)$/;"	f	class:openvpn::TCPTransport::Link
interface_change	tun/mac/macdns.hpp	/^      bool interface_change(Info* other) const$/;"	f	class:openvpn::MacDNS::Info
interface_change_cleanup	tun/mac/macdns.hpp	/^    void interface_change_cleanup(Info* info)$/;"	f	class:openvpn::MacDNS
interface_index	tun/win/tunutil.hpp	/^	DWORD interface_index() const$/;"	f	class:openvpn::TunWin::Util::DefaultGateway
interim_finalize	client/cliconnect.hpp	/^    void interim_finalize()$/;"	f	class:openvpn::ClientConnect
internal	addr/iperr.hpp	/^    namespace internal {$/;"	n	namespace:openvpn::IP
internet	applecrypto/util/reachable.hpp	/^    std::unique_ptr<ReachabilityViaInternet> internet;$/;"	m	class:openvpn::Reachability
internet_callback_static	applecrypto/util/reachable.hpp	/^    static void internet_callback_static(SCNetworkReachabilityRef target,$/;"	f	class:openvpn::ReachabilityTracker
invalidate	common/usergroup.hpp	/^    void invalidate()$/;"	f	class:openvpn::SetUserGroup
invalidate	ssl/proto.hpp	/^      void invalidate(const Error::Type reason)$/;"	f	class:openvpn::ProtoContext::KeyContext
invalidate	ssl/protostack.hpp	/^    void invalidate(const Error::Type reason)$/;"	f	class:openvpn::ProtoStackBase
invalidate	tun/persist/tunpersist.hpp	/^    void invalidate()$/;"	f	class:openvpn::TunPersistTemplate
invalidate_callback	ssl/proto.hpp	/^      void invalidate_callback() \/\/ called by ProtoStackBase when session is invalidated$/;"	f	class:openvpn::ProtoContext::KeyContext
invalidated	ssl/proto.hpp	/^      bool invalidated() const { return Base::invalidated(); }$/;"	f	class:openvpn::ProtoContext::KeyContext
invalidated	ssl/proto.hpp	/^    bool invalidated() const { return primary->invalidated(); }$/;"	f	class:openvpn::ProtoContext
invalidated	ssl/protostack.hpp	/^    bool invalidated() const { return invalidated_; }$/;"	f	class:openvpn::ProtoStackBase
invalidated_	ssl/protostack.hpp	/^    bool invalidated_;$/;"	m	class:openvpn::ProtoStackBase
invalidation_error	server/servproto.hpp	/^      void invalidation_error(const Error::Type err)$/;"	f	class:openvpn::ServerProto::Session
invalidation_reason	ssl/proto.hpp	/^      Error::Type invalidation_reason() const { return Base::invalidation_reason(); }$/;"	f	class:openvpn::ProtoContext::KeyContext
invalidation_reason	ssl/proto.hpp	/^    Error::Type invalidation_reason() const { return primary->invalidation_reason(); }$/;"	f	class:openvpn::ProtoContext
invalidation_reason	ssl/protostack.hpp	/^    Error::Type invalidation_reason() const { return invalidation_reason_; }$/;"	f	class:openvpn::ProtoStackBase
invalidation_reason_	ssl/protostack.hpp	/^    Error::Type invalidation_reason_;$/;"	m	class:openvpn::ProtoStackBase
invoke	common/function.hpp	/^      R (*invoke)(void *, A...);$/;"	m	struct:openvpn::Function::Methods
invoke	common/function.hpp	/^      static R invoke(void *ptr, A... args)$/;"	f	class:openvpn::Function::Intern
io_context	client/cliconnect.hpp	/^    asio::io_context& io_context;$/;"	m	class:openvpn::ClientConnect
io_context	client/cliproto.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::ClientProto::Session
io_context	client/remotelist.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::RemoteList::PreResolve
io_context	common/actionthread.hpp	/^    asio::io_context& io_context;$/;"	m	class:openvpn::ActionThread
io_context	server/servproto.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::ServerProto::Factory
io_context	server/servproto.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::ServerProto::Session
io_context	transport/client/httpcli.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::HTTPProxyTransport::Client
io_context	transport/client/tcpcli.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::TCPTransport::Client
io_context	transport/client/udpcli.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::UDPTransport::Client
io_context	tun/builder/client.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::TunBuilderClient::Client
io_context	tun/client/tunnull.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::TunNull::Client
io_context	tun/linux/client/tuncli.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::TunLinux::Client
io_context	tun/mac/client/tuncli.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::TunMac::Client
io_context	tun/win/client/tuncli.hpp	/^      asio::io_context& io_context;$/;"	m	class:openvpn::TunWin::Client
ioctl	tun/win/tunutil.hpp	/^	void ioctl(HANDLE th) const$/;"	f	class:openvpn::TunWin::Util::TAPDHCPMasquerade
ip	ip/dhcp.hpp	/^    IPHeader ip;$/;"	m	struct:openvpn::DHCPPacket
ip	tun/win/tunutil.hpp	/^	IPv4::Addr ip = IPv4::Addr::from_zero();$/;"	m	struct:openvpn::TunWin::Util::IPNetmask4
ip4	server/vpnservpool.hpp	/^      IP::Addr ip4;$/;"	m	struct:openvpn::VPNServerPool::IP46
ip6	server/vpnservpool.hpp	/^      IP::Addr ip6;$/;"	m	struct:openvpn::VPNServerPool::IP46
ip_checksum	ip/ip.hpp	/^  inline std::uint16_t ip_checksum(const void *ip, unsigned int size)$/;"	f	namespace:openvpn
ip_hole_punch	client/cliproto.hpp	/^      virtual void ip_hole_punch(const IP::Addr& addr)$/;"	f	class:openvpn::ClientProto::Session
ip_hole_punch	tun/client/tunbase.hpp	/^    virtual void ip_hole_punch(const IP::Addr& addr) {}$/;"	f	struct:openvpn::TunClientFactory
ip_ver_flags	client/ipverflags.hpp	/^    IP::Addr::VersionMask ip_ver_flags() const$/;"	f	class:openvpn::IPVerFlags
ip_ver_flags_	client/ipverflags.hpp	/^    const IP::Addr::VersionMask ip_ver_flags_;$/;"	m	class:openvpn::IPVerFlags
ipv4	tun/builder/capture.hpp	/^      bool ipv4 = false;$/;"	m	class:openvpn::TunBuilderCapture::RerouteGW
ipv4	tun/mac/macdns.hpp	/^      DSDict ipv4;$/;"	m	class:openvpn::MacDNS::Info
ipv4	tun/win/client/tunsetup.hpp	/^	int ipv4() const { return indices[0]; }$/;"	f	class:openvpn::TunWin::Setup::UseDNS
ipv6	client/cliopt.hpp	/^      IPv6Setting ipv6;$/;"	m	struct:openvpn::ClientOptions::Config
ipv6	tun/builder/capture.hpp	/^      bool ipv6 = false;$/;"	m	class:openvpn::TunBuilderCapture::DNSServer
ipv6	tun/builder/capture.hpp	/^      bool ipv6 = false;$/;"	m	class:openvpn::TunBuilderCapture::RemoteAddress
ipv6	tun/builder/capture.hpp	/^      bool ipv6 = false;$/;"	m	class:openvpn::TunBuilderCapture::RerouteGW
ipv6	tun/builder/capture.hpp	/^      bool ipv6 = false;$/;"	m	class:openvpn::TunBuilderCapture::RouteBase
ipv6	tun/tunspec.hpp	/^    bool ipv6;$/;"	m	struct:openvpn::ParseTunSpec
ipv6	tun/win/client/tunsetup.hpp	/^	int ipv6() const { return indices[1]; }$/;"	f	class:openvpn::TunWin::Setup::UseDNS
ipv6addr	addr/ipv6.hpp	/^      union ipv6addr {$/;"	u	class:openvpn::IPv6::Addr
isLegalUTF8	common/unicode-impl.hpp	/^    inline bool isLegalUTF8(const UTF8 *source, int length) {$/;"	f	namespace:openvpn::Unicode
isLegalUTF8Sequence	common/unicode-impl.hpp	/^    inline bool isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {$/;"	f	namespace:openvpn::Unicode
is_aligned	common/memneq.hpp	/^    inline bool is_aligned(const T value)$/;"	f	namespace:openvpn::crypto
is_alpha	common/string.hpp	/^    inline bool is_alpha(const char c)$/;"	f	namespace:openvpn::string
is_autologin	client/cliopthelper.hpp	/^    static bool is_autologin(const OptionList& options,$/;"	f	class:openvpn::ParseClientConfig
is_base64_char	common/base64.hpp	/^    bool is_base64_char(const char c) const$/;"	f	class:openvpn::Base64
is_bs64_cipher	crypto/bs64_data_limit.hpp	/^  inline bool is_bs64_cipher(const CryptoAlgs::Type cipher)$/;"	f	namespace:openvpn
is_canonical	addr/addrpair.hpp	/^      bool is_canonical() const$/;"	f	struct:openvpn::IP::AddrMaskPair
is_canonical	addr/route.hpp	/^      bool is_canonical() const$/;"	f	struct:openvpn::IP::RouteType
is_char	http/parseutil.hpp	/^      inline bool is_char(const unsigned char c)$/;"	f	namespace:openvpn::HTTP::Util
is_client	common/mode.hpp	/^    bool is_client() const { return type_ == CLIENT; }$/;"	f	class:openvpn::Mode
is_client	ssl/proto.hpp	/^    bool is_client() const { return mode_.is_client(); }$/;"	f	class:openvpn::ProtoContext
is_close_meta_tag	common/options.hpp	/^    static bool is_close_meta_tag(const std::string& str, const std::string& prefix, const std::string& tag)$/;"	f	class:openvpn::OptionList
is_close_tag	common/options.hpp	/^    static bool is_close_tag(const std::string& str, const std::string& tag)$/;"	f	class:openvpn::OptionList
is_comment	common/options.hpp	/^    static bool is_comment(const char c)$/;"	f	class:openvpn::OptionList
is_comp	ssl/proto_context_options.hpp	/^    bool is_comp() const { return compression_mode != COMPRESS_NO; }$/;"	f	struct:openvpn::ProtoContextOptions
is_comp_asym	ssl/proto_context_options.hpp	/^    bool is_comp_asym() const { return compression_mode == COMPRESS_ASYM; }$/;"	f	struct:openvpn::ProtoContextOptions
is_compatible	addr/ip.hpp	/^      bool is_compatible(const Addr& other) const$/;"	f	class:openvpn::IP::Addr
is_control	ssl/proto.hpp	/^      bool is_control() const { return (flags & (CONTROL|DEFINED)) == (CONTROL|DEFINED); }$/;"	f	class:openvpn::ProtoContext::PacketType
is_ctl	http/parseutil.hpp	/^      inline bool is_ctl(const unsigned char c)$/;"	f	namespace:openvpn::HTTP::Util
is_ctrl	common/string.hpp	/^    inline bool is_ctrl(const char c)$/;"	f	namespace:openvpn::string
is_ctrl	common/string.hpp	/^    inline bool is_ctrl(const unsigned char c)$/;"	f	namespace:openvpn::string
is_current	log/logperiod.hpp	/^    bool is_current(const time_t now) const$/;"	f	class:openvpn::LogPeriod
is_daemon_alive	linux/daemon_alive.hpp	/^  inline bool is_daemon_alive(const std::string& cmd,$/;"	f	namespace:openvpn
is_data	ssl/proto.hpp	/^      bool is_data()    const { return (flags & (CONTROL|DEFINED)) == DEFINED; }$/;"	f	class:openvpn::ProtoContext::PacketType
is_decrypt_green	ssl/datalimit.hpp	/^    bool is_decrypt_green()$/;"	f	class:openvpn::DataLimit
is_defined	ssl/proto.hpp	/^      bool is_defined() const { return flags & DEFINED; }$/;"	f	class:openvpn::ProtoContext::PacketType
is_dhcp_enabled	tun/win/tunutil.hpp	/^	bool is_dhcp_enabled(const DWORD index) const$/;"	f	struct:openvpn::TunWin::Util::IPAdaptersInfo
is_digit	common/string.hpp	/^    inline bool is_digit(const char c)$/;"	f	namespace:openvpn::string
is_digit	http/parseutil.hpp	/^      inline bool is_digit(const unsigned char c)$/;"	f	namespace:openvpn::HTTP::Util
is_dirsep	common/path.hpp	/^    inline bool is_dirsep(const char c)$/;"	f	namespace:openvpn::path
is_dirty	ssl/proto.hpp	/^      bool is_dirty() const { return dirty; }$/;"	f	class:openvpn::ProtoContext::KeyContext
is_dynamic	auth/cr.hpp	/^    static bool is_dynamic(const std::string& s)$/;"	f	class:openvpn::ChallengeResponse
is_empty	common/string.hpp	/^    inline bool is_empty(const char *str)$/;"	f	namespace:openvpn::string
is_empty	common/string.hpp	/^    inline bool is_empty(const std::string& str)$/;"	f	namespace:openvpn::string
is_error	client/clievent.hpp	/^      bool is_error() const$/;"	f	class:openvpn::ClientEvent::Base
is_escaped	http/parseutil.hpp	/^      inline bool is_escaped(const unsigned char c)$/;"	f	namespace:openvpn::HTTP::Util
is_external_pki	client/cliopthelper.hpp	/^    static bool is_external_pki(const OptionList& options)$/;"	f	class:openvpn::ParseClientConfig
is_fail	auth/authcert.hpp	/^	bool is_fail() const$/;"	f	class:openvpn::AuthCert::Fail
is_fail	auth/authcert.hpp	/^      bool is_fail() const$/;"	f	struct:openvpn::AuthCert
is_fatal	client/clievent.hpp	/^      bool is_fatal() const$/;"	f	class:openvpn::ClientEvent::Base
is_fileref_directive	options/merge.hpp	/^    static bool is_fileref_directive(const std::string& d, unsigned int& flags)$/;"	f	class:openvpn::ProfileMerge
is_flat	common/path.hpp	/^    inline bool is_flat(const std::string& path)$/;"	f	namespace:openvpn::path
is_fully_qualified	common/path.hpp	/^    inline bool is_fully_qualified(const std::string& path)$/;"	f	namespace:openvpn::path
is_halt	client/clihalt.hpp	/^    static bool is_halt(const StringList& sl)$/;"	f	class:openvpn::ClientHalt
is_halt	common/action.hpp	/^    bool is_halt() const$/;"	f	class:openvpn::ActionList
is_host	addr/route.hpp	/^      bool is_host() const$/;"	f	struct:openvpn::IP::RouteType
is_infinite	time/time.hpp	/^      bool is_infinite() const { return duration_ == std::numeric_limits<T>::max(); }$/;"	f	class:openvpn::TimeType::Duration
is_infinite	time/time.hpp	/^    bool is_infinite() const { return time_ == std::numeric_limits<T>::max(); }$/;"	f	class:openvpn::TimeType
is_initialized	applecrypto/crypto/cipher.hpp	/^      bool is_initialized() const { return cinfo != nullptr; }$/;"	f	class:openvpn::AppleCrypto::CipherContext
is_initialized	applecrypto/crypto/digest.hpp	/^      bool is_initialized() const { return initialized; }$/;"	f	class:openvpn::AppleCrypto::DigestContext
is_initialized	applecrypto/crypto/hmac.hpp	/^      bool is_initialized() const$/;"	f	class:openvpn::AppleCrypto::HMACContext
is_initialized	openssl/crypto/cipher.hpp	/^      bool is_initialized() const { return initialized; }$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
is_initialized	openssl/crypto/ciphergcm.hpp	/^      bool is_initialized() const { return initialized; }$/;"	f	class:openvpn::OpenSSLCrypto::CipherContextGCM
is_initialized	openssl/crypto/digest.hpp	/^      bool is_initialized() const { return initialized; }$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
is_initialized	openssl/crypto/hmac.hpp	/^      bool is_initialized() const { return initialized; }$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
is_initialized	polarssl/crypto/cipher.hpp	/^      bool is_initialized() const { return initialized; }$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
is_initialized	polarssl/crypto/ciphergcm.hpp	/^      bool is_initialized() const { return initialized; }$/;"	f	class:openvpn::PolarSSLCrypto::CipherContextGCM
is_initialized	polarssl/crypto/digest.hpp	/^      bool is_initialized() const { return initialized; }$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
is_initialized	polarssl/crypto/hmac.hpp	/^      bool is_initialized() const { return initialized; }$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
is_ipv6	transport/protocol.hpp	/^    bool is_ipv6() const { return type_ == UDPv6 || type_ == TCPv6; }$/;"	f	class:openvpn::Protocol
is_keepalive	ssl/proto.hpp	/^      inline bool is_keepalive(const Buffer& buf)$/;"	f	namespace:openvpn::proto_context_private::__anon77
is_keepalive_enabled	client/cliproto.hpp	/^      virtual bool is_keepalive_enabled() const$/;"	f	class:openvpn::ClientProto::Session
is_keepalive_enabled	server/servproto.hpp	/^      virtual bool is_keepalive_enabled() const$/;"	f	class:openvpn::ServerProto::Session
is_keepalive_enabled	ssl/proto.hpp	/^    bool is_keepalive_enabled() const$/;"	f	class:openvpn::ProtoContext
is_local	transport/protocol.hpp	/^    bool is_local() const { return is_unix() || is_named_pipe(); }$/;"	f	class:openvpn::Protocol
is_local_type	transport/protocol.hpp	/^    static bool is_local_type(const std::string& str)$/;"	f	class:openvpn::Protocol
is_multiline	common/string.hpp	/^    inline bool is_multiline(const std::string& str)$/;"	f	namespace:openvpn::string
is_named_pipe	transport/protocol.hpp	/^    bool is_named_pipe() const { return type_ == NamedPipe; }$/;"	f	class:openvpn::Protocol
is_number	common/number.hpp	/^  inline bool is_number(const char *str)$/;"	f	namespace:openvpn
is_open_meta_tag	common/options.hpp	/^    static bool is_open_meta_tag(const std::string& str)$/;"	f	class:openvpn::OptionList
is_open_tag	common/options.hpp	/^    static bool is_open_tag(const std::string& str)$/;"	f	class:openvpn::OptionList
is_openvpn_protocol	ssl/is_openvpn_protocol.hpp	/^  inline bool is_openvpn_protocol(const unsigned char *p, const size_t len)$/;"	f	namespace:openvpn
is_printable	common/string.hpp	/^    inline bool is_printable(const char c)$/;"	f	namespace:openvpn::string
is_printable	common/string.hpp	/^    inline bool is_printable(const std::string& str)$/;"	f	namespace:openvpn::string
is_printable	common/string.hpp	/^    inline bool is_printable(const unsigned char c)$/;"	f	namespace:openvpn::string
is_raw	ssl/proto.hpp	/^      bool is_raw() const { return opcode != CONTROL_V1; }$/;"	f	class:openvpn::ProtoContext::Packet
is_raw_mode	transport/tcplink.hpp	/^      bool is_raw_mode() const {$/;"	f	class:openvpn::TCPTransport::Link
is_raw_mode_read	transport/tcplink.hpp	/^      bool is_raw_mode_read() const {$/;"	f	class:openvpn::TCPTransport::Link
is_raw_mode_write	transport/tcplink.hpp	/^      bool is_raw_mode_write() const {$/;"	f	class:openvpn::TCPTransport::Link
is_reliable	ssl/proto.hpp	/^      bool is_reliable;$/;"	m	class:openvpn::ProtoContext::KeyContext
is_reliable	transport/protocol.hpp	/^    bool is_reliable() const { return is_tcp(); }$/;"	f	class:openvpn::Protocol
is_restart	client/clihalt.hpp	/^    static bool is_restart(const StringList& sl)$/;"	f	class:openvpn::ClientHalt
is_server	common/mode.hpp	/^    bool is_server() const { return type_ == SERVER; }$/;"	f	class:openvpn::Mode
is_server	ssl/proto.hpp	/^    bool is_server() const { return mode_.is_server(); }$/;"	f	class:openvpn::ProtoContext
is_soft_reset	ssl/proto.hpp	/^      bool is_soft_reset() const { return (flags & (CONTROL|DEFINED|SECONDARY|SOFT_RESET))$/;"	f	class:openvpn::ProtoContext::PacketType
is_space	common/lex.hpp	/^    static bool is_space(char c)$/;"	f	struct:openvpn::SpaceMatch
is_space	common/string.hpp	/^    inline bool is_space(const char c)$/;"	f	namespace:openvpn::string
is_static	auth/cr.hpp	/^    static bool is_static(const std::string& s)$/;"	f	class:openvpn::ChallengeResponse
is_steady	time/asiotimer.hpp	/^    static constexpr bool is_steady()$/;"	f	struct:openvpn::AsioClock
is_tcp	ssl/proto.hpp	/^    const bool is_tcp() { return config->protocol.is_tcp(); }$/;"	f	class:openvpn::ProtoContext
is_tcp	transport/protocol.hpp	/^    bool is_tcp() const { return type_ == TCPv4 || type_ == TCPv6; }$/;"	f	class:openvpn::Protocol
is_true	common/string.hpp	/^    inline bool is_true(const std::string& str)$/;"	f	namespace:openvpn::string
is_tspecial	http/parseutil.hpp	/^      inline bool is_tspecial(const unsigned char c)$/;"	f	namespace:openvpn::HTTP::Util
is_udp	ssl/proto.hpp	/^    const bool is_udp() { return config->protocol.is_udp(); }$/;"	f	class:openvpn::ProtoContext
is_udp	transport/protocol.hpp	/^    bool is_udp() const { return type_ == UDPv4 || type_ == UDPv6; }$/;"	f	class:openvpn::Protocol
is_unix	transport/protocol.hpp	/^    bool is_unix() const { return type_ == UnixStream || type_ == UnixDGram; }$/;"	f	class:openvpn::Protocol
is_up	tun/win/tunutil.hpp	/^	bool is_up(const DWORD index, const IPNetmask4& vpn_addr) const$/;"	f	struct:openvpn::TunWin::Util::IPAdaptersInfo
is_valid	addr/ip.hpp	/^      static bool is_valid(const std::string& ipstr)$/;"	f	class:openvpn::IP::Addr
is_valid	auth/authcreds.hpp	/^      bool is_valid() const$/;"	f	class:openvpn::AuthCreds
is_valid	common/unicode.hpp	/^	const bool is_valid() const$/;"	f	struct:openvpn::Unicode::UTF8Iterator::Char
is_valid	crypto/packet_id.hpp	/^    bool is_valid() const$/;"	f	struct:openvpn::PacketID
is_valid_host	common/hostport.hpp	/^    inline bool is_valid_host(const std::string& host)$/;"	f	namespace:openvpn::HostPort
is_valid_host_char	common/hostport.hpp	/^    inline bool is_valid_host_char(const char c)$/;"	f	namespace:openvpn::HostPort
is_valid_port	common/hostport.hpp	/^    inline bool is_valid_port(const std::string& port, unsigned int *value = nullptr)$/;"	f	namespace:openvpn::HostPort
is_valid_port	common/hostport.hpp	/^    inline bool is_valid_port(const unsigned int port)$/;"	f	namespace:openvpn::HostPort
is_valid_scheme_char	http/urlparse.hpp	/^      bool is_valid_scheme_char(const char c)$/;"	f	class:openvpn::URL::Parse
is_valid_uri_char	http/urlparse.hpp	/^      bool is_valid_uri_char(const char c)$/;"	f	class:openvpn::URL::Parse
is_valid_user_pass	auth/authcreds.hpp	/^      bool is_valid_user_pass() const$/;"	f	class:openvpn::AuthCreds
is_valid_utf8	common/unicode.hpp	/^    inline bool is_valid_utf8(const STRING& str, const size_t max_len_flags=0)$/;"	f	namespace:openvpn::Unicode
is_valid_utf8_uchar_buf	common/unicode.hpp	/^    inline bool is_valid_utf8_uchar_buf(const unsigned char *source,$/;"	f	namespace:openvpn::Unicode
is_word	common/string.hpp	/^    inline bool is_word(const std::string& str)$/;"	f	namespace:openvpn::string
issuer_fp	auth/authcert.hpp	/^      unsigned char issuer_fp[20];   \/\/ issuer cert fingerprint$/;"	m	struct:openvpn::AuthCert
issuer_fp_prefix	auth/authcert.hpp	/^      T issuer_fp_prefix() const$/;"	f	struct:openvpn::AuthCert
issuer_fp_str	auth/authcert.hpp	/^      std::string issuer_fp_str(const bool openssl_fmt) const$/;"	f	struct:openvpn::AuthCert
iter	buffer/bufcomposed.hpp	/^      BufferVector::const_iterator iter;$/;"	m	class:openvpn::BufferComposed::Complete
iter_defined	buffer/bufcomposed.hpp	/^      bool iter_defined()$/;"	f	class:openvpn::BufferComposed::Complete
iterator	addr/range.hpp	/^      Iterator iterator() const { return Iterator(*this); }$/;"	f	class:openvpn::IP::RangeType
iv	crypto/crypto_aead.hpp	/^	const unsigned char *iv() const$/;"	f	class:openvpn::AEAD::Crypto::Nonce
iv_length	applecrypto/crypto/cipher.hpp	/^      size_t iv_length() const$/;"	f	class:openvpn::AppleCrypto::CipherContext
iv_length	crypto/cipher.hpp	/^    size_t iv_length() const$/;"	f	class:openvpn::CipherContext
iv_length	crypto/cryptoalgs.hpp	/^      size_t iv_length() const { return iv_length_; }    \/\/ cipher only$/;"	f	class:openvpn::CryptoAlgs::Alg
iv_length	crypto/cryptoalgs.hpp	/^    inline size_t iv_length(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
iv_length	openssl/crypto/cipher.hpp	/^      size_t iv_length() const$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
iv_length	polarssl/crypto/cipher.hpp	/^      size_t iv_length() const$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
iv_length_	crypto/cryptoalgs.hpp	/^      unsigned int iv_length_;$/;"	m	class:openvpn::CryptoAlgs::Alg
join	buffer/buflist.hpp	/^    BufferPtr join() const$/;"	f	struct:openvpn::BufferCollection
join	buffer/buflist.hpp	/^    BufferPtr join(const size_t headroom,$/;"	f	struct:openvpn::BufferCollection
join	common/path.hpp	/^    inline std::string join(const std::string& p1, const std::string& p2)$/;"	f	namespace:openvpn::path
join	common/runcontext.hpp	/^    void join()$/;"	f	class:openvpn::RunContext
join	common/string.hpp	/^    inline std::string join(const std::vector<std::string>& strings,$/;"	f	namespace:openvpn::string
join_size	buffer/buflist.hpp	/^    size_t join_size() const$/;"	f	struct:openvpn::BufferCollection
keepalive_expire	ssl/proto.hpp	/^    Time keepalive_expire;             \/\/ time in future when we must have received a packet from peer or we will timeout session$/;"	m	class:openvpn::ProtoContext
keepalive_housekeeping	ssl/proto.hpp	/^    void keepalive_housekeeping()$/;"	f	class:openvpn::ProtoContext
keepalive_message	ssl/proto.hpp	/^      const unsigned char keepalive_message[] = {    \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::proto_context_private::__anon77
keepalive_parms_modified	ssl/proto.hpp	/^    void keepalive_parms_modified()$/;"	f	class:openvpn::ProtoContext
keepalive_ping	ssl/proto.hpp	/^      Time::Duration keepalive_ping;$/;"	m	class:openvpn::ProtoContext::Config
keepalive_timeout	ssl/proto.hpp	/^      Time::Duration keepalive_timeout;$/;"	m	class:openvpn::ProtoContext::Config
keepalive_xmit	ssl/proto.hpp	/^    Time keepalive_xmit;               \/\/ time in future when we will transmit a keepalive (subject to continuous change)$/;"	m	class:openvpn::ProtoContext
kev_error	ssl/proto.hpp	/^      void kev_error(const EventType ev, const Error::Type reason)$/;"	f	class:openvpn::ProtoContext::KeyContext
key	common/options.hpp	/^      std::string key;$/;"	m	class:openvpn::OptionList::KeyValue
key	ssl/peerinfo.hpp	/^      std::string key;$/;"	m	struct:openvpn::PeerInfo::KeyValue
key	ssl/proto.hpp	/^	OpenVPNStaticKey key;$/;"	m	struct:openvpn::ProtoContext::KeyContext::DataChannelKey
key	win/reg.hpp	/^      HKEY key;$/;"	m	class:openvpn::Win::RegKey
key_	applecrypto/crypto/hmac.hpp	/^      unsigned char key_[MAX_HMAC_KEY_SIZE];$/;"	m	class:openvpn::AppleCrypto::HMACContext
key_data_	crypto/static_key.hpp	/^    key_t key_data_;$/;"	m	class:openvpn::OpenVPNStaticKey
key_data_	crypto/static_key.hpp	/^    key_t key_data_;$/;"	m	class:openvpn::StaticKey
key_direction	ssl/proto.hpp	/^      int key_direction = -1;        \/\/ 0, 1, or -1 for bidirectional$/;"	m	class:openvpn::ProtoContext::Config
key_id	ssl/proto.hpp	/^      unsigned int key_id() const { return key_id_; }$/;"	f	class:openvpn::ProtoContext::KeyContext
key_id_	ssl/proto.hpp	/^      unsigned int key_id_;$/;"	m	class:openvpn::ProtoContext::KeyContext
key_id_extract	ssl/proto.hpp	/^    static unsigned int key_id_extract(const unsigned int op)$/;"	f	class:openvpn::ProtoContext
key_len	polarssl/ssl/sslctx.hpp	/^    size_t key_len() const$/;"	f	class:openvpn::PolarSSLContext
key_length	crypto/cryptoalgs.hpp	/^      size_t key_length() const { return size_; }        \/\/ cipher key length$/;"	f	class:openvpn::CryptoAlgs::Alg
key_length	crypto/cryptoalgs.hpp	/^    inline size_t key_length(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
key_limit_reneg	ssl/proto.hpp	/^      void key_limit_reneg(const EventType ev, const Time& t)$/;"	f	class:openvpn::ProtoContext::KeyContext
key_limit_renegotiation_fired	ssl/proto.hpp	/^      bool key_limit_renegotiation_fired;$/;"	m	class:openvpn::ProtoContext::KeyContext
key_name	pki/x509track.hpp	/^      std::string key_name() const$/;"	f	struct:openvpn::X509Track::KeyValue
key_priority	common/options.hpp	/^      int key_priority;$/;"	m	class:openvpn::OptionList::KeyValue
key_size_	applecrypto/crypto/hmac.hpp	/^      size_t key_size_;$/;"	m	class:openvpn::AppleCrypto::HMACContext
key_t	crypto/static_key.hpp	/^    typedef BufferAllocatedType<unsigned char> key_t;$/;"	t	class:openvpn::StaticKey
key_t	crypto/static_key.hpp	/^    typedef StaticKey::key_t key_t;$/;"	t	class:openvpn::OpenVPNStaticKey
keyboard_ir_to_key	win/console.hpp	/^	unsigned int keyboard_ir_to_key(INPUT_RECORD *ir)$/;"	f	class:openvpn::Win::Console::Input
ku	openssl/ssl/sslctx.hpp	/^      std::vector<unsigned int> ku; \/\/ if defined, peer cert X509 key usage must match one of these values$/;"	m	class:openvpn::OpenSSLContext::Config
ku	polarssl/ssl/sslctx.hpp	/^      std::vector<unsigned int> ku; \/\/ if defined, peer cert X509 key usage must match one of these values$/;"	m	class:openvpn::PolarSSLContext::Config
l2_state	tun/win/client/tunsetup.hpp	/^      std::unique_ptr<L2State> l2_state;$/;"	m	class:openvpn::TunWin::Setup
l2_thread	tun/win/client/tunsetup.hpp	/^      std::unique_ptr<std::thread> l2_thread;$/;"	m	class:openvpn::TunWin::Setup
l2_timer	tun/win/client/tuncli.hpp	/^      AsioTimer l2_timer;$/;"	m	class:openvpn::TunWin::Client
last_packet_received	log/sessionstats.hpp	/^    const Time& last_packet_received() const { return last_packet_received_; }$/;"	f	class:openvpn::SessionStats
last_packet_received_	log/sessionstats.hpp	/^    Time last_packet_received_;$/;"	m	class:openvpn::SessionStats
layer	ssl/proto.hpp	/^      Layer layer;$/;"	m	class:openvpn::ProtoContext::Config
layer	tun/mac/client/tunsetup.hpp	/^	Layer layer;               \/\/ OSI layer$/;"	m	struct:openvpn::TunMac::Setup::Config
layer_2_schedule_timer	tun/win/client/tuncli.hpp	/^      void layer_2_schedule_timer(const unsigned int seconds)$/;"	f	class:openvpn::TunWin::Client
layer_2_supported	tun/client/tunbase.hpp	/^    virtual bool layer_2_supported() const { return false; }$/;"	f	struct:openvpn::TunClientFactory
layer_2_supported	tun/mac/client/tuncli.hpp	/^      virtual bool layer_2_supported() const$/;"	f	class:openvpn::TunMac::ClientConfig
layer_2_timer_callback	tun/win/client/tuncli.hpp	/^      void layer_2_timer_callback()$/;"	f	class:openvpn::TunWin::Client
lease_time	tun/win/tunutil.hpp	/^	unsigned int lease_time = 31536000;$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
legal_dc_cipher	crypto/cryptoalgs.hpp	/^    inline Type legal_dc_cipher(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
legal_dc_digest	crypto/cryptoalgs.hpp	/^    inline Type legal_dc_digest(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
len	common/unicode.hpp	/^	unsigned int len;$/;"	m	struct:openvpn::Unicode::UTF8Iterator::Char
len	ip/udp.hpp	/^    std::uint16_t   len;$/;"	m	struct:openvpn::UDPHeader
len	openssl/util/error.hpp	/^    size_t len() const { return n_err; }$/;"	f	class:openvpn::OpenSSLException
len_without_trailing_nulls	common/string.hpp	/^    inline size_t len_without_trailing_nulls(const char *str, size_t len)$/;"	f	namespace:openvpn::string
length	buffer/buffer.hpp	/^    size_t length() const { return size(); }$/;"	f	class:openvpn::BufferType
length	buffer/memq.hpp	/^    size_t length;$/;"	m	class:openvpn::MemQBase
length	buffer/safestr.hpp	/^    const size_t length() const$/;"	f	class:openvpn::SafeString
length	ip/ip.hpp	/^    static unsigned int length(const std::uint8_t version_len)$/;"	f	struct:openvpn::IPHeader
lenientConversion	common/unicode-impl.hpp	/^      lenientConversion$/;"	e	enum:openvpn::Unicode::__anon26
lifecycle	client/cliopt.hpp	/^    ClientLifeCycle* lifecycle() { return client_lifecycle.get(); }$/;"	f	class:openvpn::ClientOptions
lifecycle_started	client/cliconnect.hpp	/^    bool lifecycle_started;$/;"	m	class:openvpn::ClientConnect
likely	common/likely.hpp	/^# define likely(/;"	d
limit	common/pthreadcond.hpp	/^    int limit;$/;"	m	class:openvpn::PThreadBarrier
line	common/splitlines.hpp	/^    std::string line;$/;"	m	class:openvpn::SplitLinesType
line_move	common/splitlines.hpp	/^    std::string line_move()$/;"	f	class:openvpn::SplitLinesType
line_overflow	common/splitlines.hpp	/^    bool line_overflow() const$/;"	f	class:openvpn::SplitLinesType
line_ref	common/splitlines.hpp	/^    const std::string& line_ref() const$/;"	f	class:openvpn::SplitLinesType
line_ref	common/splitlines.hpp	/^    std::string& line_ref()$/;"	f	class:openvpn::SplitLinesType
line_too_long	common/options.hpp	/^    static void line_too_long(const int line_num)$/;"	f	class:openvpn::OptionList
lines_exceeded	transport/client/httpcli.hpp	/^	virtual void lines_exceeded() {$/;"	f	struct:openvpn::HTTPProxyTransport::Client::ProxyResponseLimit
link_mtu_adjust	ssl/proto.hpp	/^      unsigned int link_mtu_adjust()$/;"	f	class:openvpn::ProtoContext::Config
list	client/remotelist.hpp	/^    std::vector<Item::Ptr> list;$/;"	m	class:openvpn::RemoteList
list	tun/win/tunutil.hpp	/^	std::unique_ptr<IP_ADAPTER_INFO> list;$/;"	m	struct:openvpn::TunWin::Util::IPAdaptersInfo
list	tun/win/tunutil.hpp	/^	std::unique_ptr<IP_INTERFACE_INFO> list;$/;"	m	struct:openvpn::TunWin::Util::InterfaceInfoList
load	applecrypto/ssl/sslctx.hpp	/^      virtual void load(const OptionList& opt, const unsigned int lflags)$/;"	f	class:openvpn::AppleSSLContext::Config
load	openssl/ssl/sslctx.hpp	/^      virtual void load(const OptionList& opt, const unsigned int lflags)$/;"	f	class:openvpn::OpenSSLContext::Config
load	polarssl/ssl/sslctx.hpp	/^      virtual void load(const OptionList& opt, const unsigned int lflags)$/;"	f	class:openvpn::PolarSSLContext::Config
load	ssl/proto.hpp	/^      void load(const OptionList& opt, const ProtoContextOptions& pco,$/;"	f	class:openvpn::ProtoContext::Config
load	tun/linux/client/tuncli.hpp	/^      void load(const OptionList& opt)$/;"	f	class:openvpn::TunLinux::ClientConfig
load_ca	applecrypto/ssl/sslctx.hpp	/^      virtual void load_ca(const std::string& ca_txt, bool strict)$/;"	f	class:openvpn::AppleSSLContext::Config
load_ca	openssl/ssl/sslctx.hpp	/^      virtual void load_ca(const std::string& ca_txt, bool strict)$/;"	f	class:openvpn::OpenSSLContext::Config
load_ca	polarssl/ssl/sslctx.hpp	/^      virtual void load_ca(const std::string& ca_txt, bool strict)$/;"	f	class:openvpn::PolarSSLContext::Config
load_cert	applecrypto/ssl/sslctx.hpp	/^      virtual void load_cert(const std::string& cert_txt)$/;"	f	class:openvpn::AppleSSLContext::Config
load_cert	applecrypto/ssl/sslctx.hpp	/^      virtual void load_cert(const std::string& cert_txt, const std::string& extra_certs_txt)$/;"	f	class:openvpn::AppleSSLContext::Config
load_cert	openssl/ssl/sslctx.hpp	/^      virtual void load_cert(const std::string& cert_txt)$/;"	f	class:openvpn::OpenSSLContext::Config
load_cert	openssl/ssl/sslctx.hpp	/^      virtual void load_cert(const std::string& cert_txt, const std::string& extra_certs_txt)$/;"	f	class:openvpn::OpenSSLContext::Config
load_cert	polarssl/ssl/sslctx.hpp	/^      virtual void load_cert(const std::string& cert_txt)$/;"	f	class:openvpn::PolarSSLContext::Config
load_cert	polarssl/ssl/sslctx.hpp	/^      virtual void load_cert(const std::string& cert_txt, const std::string& extra_certs_txt)$/;"	f	class:openvpn::PolarSSLContext::Config
load_common	ssl/proto.hpp	/^      void load_common(const OptionList& opt, const ProtoContextOptions& pco,$/;"	f	class:openvpn::ProtoContext::Config
load_crl	applecrypto/ssl/sslctx.hpp	/^      virtual void load_crl(const std::string& crl_txt)$/;"	f	class:openvpn::AppleSSLContext::Config
load_crl	openssl/ssl/sslctx.hpp	/^      virtual void load_crl(const std::string& crl_txt)$/;"	f	class:openvpn::OpenSSLContext::Config
load_crl	polarssl/ssl/sslctx.hpp	/^      virtual void load_crl(const std::string& crl_txt)$/;"	f	class:openvpn::PolarSSLContext::Config
load_dh	applecrypto/ssl/sslctx.hpp	/^      virtual void load_dh(const std::string& dh_txt)$/;"	f	class:openvpn::AppleSSLContext::Config
load_dh	openssl/ssl/sslctx.hpp	/^      virtual void load_dh(const std::string& dh_txt)$/;"	f	class:openvpn::OpenSSLContext::Config
load_dh	polarssl/ssl/sslctx.hpp	/^      virtual void load_dh(const std::string& dh_txt)$/;"	f	class:openvpn::PolarSSLContext::Config
load_duration_default	time/durhelper.hpp	/^  inline Time::Duration load_duration_default(const std::string& name,$/;"	f	namespace:openvpn
load_duration_parm	time/durhelper.hpp	/^  inline const Option* load_duration_parm(Time::Duration& dur,$/;"	f	namespace:openvpn
load_factor	addr/pool.hpp	/^      float load_factor() const { return map.load_factor(); }$/;"	f	class:openvpn::IP::PoolType
load_from_environ	common/process.hpp	/^    void load_from_environ()$/;"	f	class:openvpn::Environ
load_identity	applecrypto/ssl/sslctx.hpp	/^      void load_identity(const std::string& subject_match)$/;"	f	class:openvpn::AppleSSLContext::Config
load_identity_	applecrypto/ssl/sslctx.hpp	/^    static CF::Array load_identity_(const std::string& subj_match)$/;"	f	class:openvpn::AppleSSLContext
load_private_key	applecrypto/ssl/sslctx.hpp	/^      virtual void load_private_key(const std::string& key_txt)$/;"	f	class:openvpn::AppleSSLContext::Config
load_private_key	openssl/ssl/sslctx.hpp	/^      virtual void load_private_key(const std::string& key_txt)$/;"	f	class:openvpn::OpenSSLContext::Config
load_private_key	polarssl/ssl/sslctx.hpp	/^      virtual void load_private_key(const std::string& key_txt)$/;"	f	class:openvpn::PolarSSLContext::Config
load_transport_config	client/cliopt.hpp	/^    std::string load_transport_config()$/;"	f	class:openvpn::ClientOptions
local	server/peeraddr.hpp	/^    AddrPort local;$/;"	m	struct:openvpn::PeerAddr
local_cert_enabled	openssl/ssl/sslctx.hpp	/^      bool local_cert_enabled;$/;"	m	class:openvpn::OpenSSLContext::Config
local_cert_enabled	polarssl/ssl/sslctx.hpp	/^      bool local_cert_enabled;$/;"	m	class:openvpn::PolarSSLContext::Config
local_gateway	netconf/linux/route.hpp	/^    IP::Addr local_gateway;$/;"	m	class:openvpn::RouteListLinux
local_peer_id	ssl/proto.hpp	/^      int local_peer_id = -1;  \/\/ -1 to disable$/;"	m	class:openvpn::ProtoContext::Config
log	ssl/tls_remote.hpp	/^    inline void log(const std::string& tls_remote, const std::string& subject, const std::string& common_name)$/;"	f	namespace:openvpn::TLSRemote
log_context	common/runcontext.hpp	/^    Log::Context log_context;$/;"	m	class:openvpn::RunContext
log_context	log/logbasesimple.hpp	/^    Log::Context log_context;$/;"	m	class:openvpn::LogBaseSimple
log_history	common/runcontext.hpp	/^    std::unique_ptr<std::vector<RunContextLogEntry>> log_history;$/;"	m	class:openvpn::RunContext
log_notify	common/runcontext.hpp	/^    virtual void log_notify(const RunContextLogEntry& le)$/;"	f	struct:openvpn::ServerThreadType
log_observers	common/runcontext.hpp	/^    std::vector<unsigned int> log_observers; \/\/ unit numbers of log observers$/;"	m	class:openvpn::RunContext
log_packet	client/cliproto.hpp	/^      void log_packet(const Buffer& buf, const bool out)$/;"	f	class:openvpn::ClientProto::Session
log_rotate	common/logrotate.hpp	/^  inline void log_rotate(const std::string& fn, const int max_versions)$/;"	f	namespace:openvpn
log_setup	common/daemon.hpp	/^  inline void log_setup(const std::string& log_fn,$/;"	f	namespace:openvpn
log_wrap	common/runcontext.hpp	/^    Log::Context::Wrapper log_wrap; \/\/ must be constructed after log_context$/;"	m	class:openvpn::RunContext
log_wrapper	common/runcontext.hpp	/^    const Log::Context::Wrapper& log_wrapper() { return log_wrap; }$/;"	f	class:openvpn::RunContext
logwrap	apple/maclife.hpp	/^    Log::Context::Wrapper logwrap; \/\/ used to carry forward the log context from parent thread$/;"	m	class:openvpn::MacLifeCycle
logwrap	common/actionthread.hpp	/^    Log::Context::Wrapper logwrap; \/\/ used to carry forward the log context from parent thread$/;"	m	class:openvpn::ActionThread
logwrap	tun/mac/macdns_watchdog.hpp	/^    Log::Context::Wrapper logwrap; \/\/ used to carry forward the log context from parent thread$/;"	m	class:openvpn::MacDNSWatchdog
lookup	crypto/cryptoalgs.hpp	/^    inline Type lookup(const std::string& name)$/;"	f	namespace:openvpn::CryptoAlgs
lz4_extra_buffer	compress/lz4.hpp	/^    size_t lz4_extra_buffer(const size_t len)$/;"	f	class:openvpn::CompressLZ4Base
lzo	compress/compstub.hpp	/^    CompressLZO lzo;$/;"	m	class:openvpn::CompressStub
lzo1x_decompress_safe	compress/lzoasym_impl.hpp	/^    inline int lzo1x_decompress_safe(const unsigned char *input,$/;"	f	namespace:openvpn::lzo_asym_impl
lzo_asym_impl	compress/lzoasym_impl.hpp	/^  namespace lzo_asym_impl {$/;"	n	namespace:openvpn
lzo_extra_buffer	compress/lzo.hpp	/^    size_t lzo_extra_buffer(const size_t len)$/;"	f	class:openvpn::CompressLZO
lzo_workspace	compress/lzo.hpp	/^    BufferAllocated lzo_workspace;$/;"	m	class:openvpn::CompressLZO
m_rtm	tun/mac/gwv4.hpp	/^      struct rt_msghdr m_rtm;$/;"	m	struct:openvpn::MacGatewayInfoV4::rtmsg	typeref:struct:openvpn::MacGatewayInfoV4::rtmsg::rt_msghdr
m_space	tun/mac/gwv4.hpp	/^      char m_space[512];$/;"	m	struct:openvpn::MacGatewayInfoV4::rtmsg
mac_sleep_start	apple/macsleep.hpp	/^    bool mac_sleep_start()$/;"	f	class:openvpn::MacSleep
mac_sleep_stop	apple/macsleep.hpp	/^    void mac_sleep_stop()$/;"	f	class:openvpn::MacSleep
macdns	tun/mac/macdns_watchdog.hpp	/^    MacDNS::Ptr macdns;$/;"	m	class:openvpn::MacDNSWatchdog
magic	ip/dhcp.hpp	/^    std::uint32_t magic;      \/* must be 0x63825363 (network order) *\/$/;"	m	struct:openvpn::DHCP
major	apple/ver.hpp	/^    int major() const { return ver[0]; }$/;"	f	class:openvpn::AppleVersion
make_pipe	common/redir.hpp	/^    static void make_pipe(int fd[2])$/;"	f	class:openvpn::RedirectPipe
man_factory	server/servproto.hpp	/^      ManClientInstanceFactory::Ptr man_factory;$/;"	m	class:openvpn::ServerProto::Factory
man_factory	server/servproto.hpp	/^      ManClientInstanceFactory::Ptr man_factory;$/;"	m	class:openvpn::ServerProto::Session
map	addr/pool.hpp	/^      std::unordered_map<ADDR, bool> map;$/;"	m	class:openvpn::IP::PoolType
map	common/options.hpp	/^    const IndexMap& map() const { return map_; }$/;"	f	class:openvpn::OptionList
map_	common/options.hpp	/^    IndexMap map_;$/;"	m	class:openvpn::OptionList
mask_to_string	common/inotify.hpp	/^    inline std::string mask_to_string(const uint32_t mask)$/;"	f	namespace:openvpn::INotify
match	client/clihalt.hpp	/^    static bool match(const std::string& msg)$/;"	f	class:openvpn::ClientHalt
match	server/listenlist.hpp	/^      static bool match(const std::string& directive, const Option& o)$/;"	f	class:openvpn::Listen::List
match	ssl/psid.hpp	/^    bool match(const ProtoSessionID& other) const$/;"	f	class:openvpn::ProtoSessionID
match_uid	common/peercred.hpp	/^      bool match_uid(const int other_uid) const$/;"	f	struct:openvpn::SockOpt::Creds
max	random/randapi.hpp	/^    static constexpr result_type max() { return ~result_type(0); }$/;"	f	class:openvpn::RandomAPI
max	time/time.hpp	/^      void max(const Duration& d)$/;"	f	class:openvpn::TimeType::Duration
max	time/time.hpp	/^    void max(const TimeType& t)$/;"	f	class:openvpn::TimeType
max_ack_list	ssl/proto.hpp	/^      size_t max_ack_list = 0;$/;"	m	class:openvpn::ProtoContext::Config
max_ack_list_	reliable/relack.hpp	/^    size_t max_ack_list_; \/\/ Maximum number of ACKs placed in a single message by prepend_acklist()$/;"	m	class:openvpn::ReliableAck
max_backtrack	crypto/packet_id.hpp	/^    unsigned int max_backtrack;$/;"	m	class:openvpn::PacketIDReceiveType
max_bytes	buffer/buflimit.hpp	/^    T max_bytes;$/;"	m	class:openvpn::BufferLimit
max_bytes	common/options.hpp	/^      const std::uint64_t max_bytes;$/;"	m	class:openvpn::OptionList::Limits
max_directive_len	common/options.hpp	/^      const size_t max_directive_len;$/;"	m	class:openvpn::OptionList::Limits
max_line_len	common/options.hpp	/^      const size_t max_line_len;$/;"	m	class:openvpn::OptionList::Limits
max_line_len	common/splitlines.hpp	/^    size_t max_line_len;$/;"	m	class:openvpn::SplitLinesType
max_lines	buffer/buflimit.hpp	/^    T max_lines;$/;"	m	class:openvpn::BufferLimit
max_size	buffer/buffer.hpp	/^    size_t max_size() const {$/;"	f	class:openvpn::BufferType
max_size_tailroom	buffer/buffer.hpp	/^    size_t max_size_tailroom(const size_t tailroom) const {$/;"	f	class:openvpn::BufferType
mem_bio	openssl/ssl/sslctx.hpp	/^      static BIO* mem_bio(const Frame::Ptr& frame)$/;"	f	class:openvpn::OpenSSLContext::SSL
memneq	common/memneq.hpp	/^    inline bool memneq(const void *a, const void *b, size_t size)$/;"	f	namespace:openvpn::crypto
memneq_deref_ok	common/memneq.hpp	/^    inline bool memneq_deref_ok(const void *a, const void *b)$/;"	f	namespace:openvpn::crypto
memneq_t	common/memneq.hpp	/^    typedef size_t memneq_t;$/;"	t	namespace:openvpn::crypto
memneq_unaligned_ok	common/memneq.hpp	/^    enum { memneq_unaligned_ok = 1 };$/;"	e	enum:openvpn::crypto::__anon20
memq_ctrl	openssl/bio/bio_memq_dgram.hpp	/^      inline long memq_ctrl (BIO *b, int cmd, long arg1, void *arg2)$/;"	f	namespace:openvpn::bmq_dgram::bio_memq_internal
memq_ctrl	openssl/bio/bio_memq_stream.hpp	/^      inline long memq_ctrl (BIO *b, int cmd, long arg1, void *arg2)$/;"	f	namespace:openvpn::bmq_stream::bio_memq_internal
memq_free	openssl/bio/bio_memq_dgram.hpp	/^      inline int memq_free (BIO *b)$/;"	f	namespace:openvpn::bmq_dgram::bio_memq_internal
memq_free	openssl/bio/bio_memq_stream.hpp	/^      inline int memq_free (BIO *b)$/;"	f	namespace:openvpn::bmq_stream::bio_memq_internal
memq_from_bio	openssl/bio/bio_memq_dgram.hpp	/^    inline MemQ *memq_from_bio(BIO *b)$/;"	f	namespace:openvpn::bmq_dgram
memq_from_bio	openssl/bio/bio_memq_stream.hpp	/^    inline MemQ *memq_from_bio(BIO *b)$/;"	f	namespace:openvpn::bmq_stream
memq_method	openssl/bio/bio_memq_dgram.hpp	/^      BIO_METHOD memq_method =$/;"	m	namespace:openvpn::bmq_dgram::bio_memq_internal
memq_method	openssl/bio/bio_memq_stream.hpp	/^      BIO_METHOD memq_method =$/;"	m	namespace:openvpn::bmq_stream::bio_memq_internal
memq_new	openssl/bio/bio_memq_dgram.hpp	/^      inline int memq_new (BIO *b)$/;"	f	namespace:openvpn::bmq_dgram::bio_memq_internal
memq_new	openssl/bio/bio_memq_stream.hpp	/^      inline int memq_new (BIO *b)$/;"	f	namespace:openvpn::bmq_stream::bio_memq_internal
memq_puts	openssl/bio/bio_memq_dgram.hpp	/^      inline int memq_puts (BIO *b, const char *str)$/;"	f	namespace:openvpn::bmq_dgram::bio_memq_internal
memq_puts	openssl/bio/bio_memq_stream.hpp	/^      inline int memq_puts (BIO *b, const char *str)$/;"	f	namespace:openvpn::bmq_stream::bio_memq_internal
memq_read	openssl/bio/bio_memq_dgram.hpp	/^      inline int memq_read (BIO *b, char *out, int size)$/;"	f	namespace:openvpn::bmq_dgram::bio_memq_internal
memq_read	openssl/bio/bio_memq_stream.hpp	/^      inline int memq_read (BIO *b, char *out, int size)$/;"	f	namespace:openvpn::bmq_stream::bio_memq_internal
memq_write	openssl/bio/bio_memq_dgram.hpp	/^      inline int memq_write (BIO *b, const char *in, int len)$/;"	f	namespace:openvpn::bmq_dgram::bio_memq_internal
memq_write	openssl/bio/bio_memq_stream.hpp	/^      inline int memq_write (BIO *b, const char *in, int len)$/;"	f	namespace:openvpn::bmq_stream::bio_memq_internal
merge	options/merge.hpp	/^    static std::string merge(const std::string& profile_content,$/;"	f	class:openvpn::ProfileMergeFromString
merge	options/merge.hpp	/^    static std::string merge(const std::string& profile_path,$/;"	f	class:openvpn::ProfileMerge
message	client/cliopthelper.hpp	/^    const std::string& message() const { return message_; }$/;"	f	class:openvpn::ParseClientConfig
message_	client/cliopthelper.hpp	/^    std::string message_;$/;"	m	class:openvpn::ParseClientConfig
meth	applecrypto/crypto/digest.hpp	/^      const DigestAlgorithm *meth;$/;"	m	class:openvpn::AppleCrypto::DigestContext
method	common/stop.hpp	/^      const std::function<void()> method;$/;"	m	class:openvpn::Stop::Scope
method	http/request.hpp	/^	  method,$/;"	e	enum:openvpn::HTTP::RequestParser::state
method	http/request.hpp	/^      std::string method;$/;"	m	struct:openvpn::HTTP::Request
method	proxy/proxyauth.hpp	/^      std::string method;$/;"	m	class:openvpn::HTTPProxy::ProxyAuthenticate
method_start	http/request.hpp	/^	  method_start,$/;"	e	enum:openvpn::HTTP::RequestParser::state
methods	common/function.hpp	/^    const Methods* methods;$/;"	m	class:openvpn::Function
metric	tun/builder/capture.hpp	/^      int metric = -1;     \/\/ optional$/;"	m	class:openvpn::TunBuilderCapture::RouteBase
milliseconds	time/time.hpp	/^      static Duration milliseconds(const T v)$/;"	f	class:openvpn::TimeType::Duration
min	random/randapi.hpp	/^    static constexpr result_type min() { return result_type(0); }$/;"	f	class:openvpn::RandomAPI
min	time/time.hpp	/^      void min(const Duration& d)$/;"	f	class:openvpn::TimeType::Duration
min	time/time.hpp	/^    void min(const TimeType& t)$/;"	f	class:openvpn::TimeType
min_args	common/options.hpp	/^    void min_args(const size_t n) const$/;"	f	class:openvpn::Option
minor	apple/ver.hpp	/^    int minor() const { return ver[1]; }$/;"	f	class:openvpn::AppleVersion
mkcode	error/excode.hpp	/^    static unsigned int mkcode(const Error::Type code, const bool fatal)$/;"	f	class:openvpn::ExceptionCode
mod	tun/mac/macdns.hpp	/^      CF::MutableDict mod;$/;"	m	class:openvpn::MacDNS::DSDict
mod_addr_version	transport/protocol.hpp	/^    void mod_addr_version(const IP::Addr& addr)$/;"	f	class:openvpn::Protocol
mod_ref	applecrypto/cf/cf.hpp	/^      T* mod_ref()$/;"	f	class:openvpn::CF::Wrap
mod_reply	tun/client/dhcp_capture.hpp	/^    bool mod_reply(Buffer& buf)$/;"	f	class:openvpn::DHCPCapture
mod_reset	tun/mac/macdns.hpp	/^      void mod_reset()$/;"	f	class:openvpn::MacDNS::DSDict
mode	applecrypto/ssl/sslctx.hpp	/^      Mode mode;$/;"	m	class:openvpn::AppleSSLContext::Config
mode	applecrypto/ssl/sslctx.hpp	/^    virtual const Mode& mode() const$/;"	f	class:openvpn::AppleSSLContext
mode	crypto/cryptoalgs.hpp	/^      Mode mode() const { return Mode(flags_ & MODE_MASK); }$/;"	f	class:openvpn::CryptoAlgs::Alg
mode	crypto/packet_id.hpp	/^    int mode;                       \/\/ UDP_MODE or TCP_MODE$/;"	m	class:openvpn::PacketIDReceiveType
mode	openssl/ssl/sslctx.hpp	/^      Mode mode;$/;"	m	class:openvpn::OpenSSLContext::Config
mode	openssl/ssl/sslctx.hpp	/^    virtual const Mode& mode() const$/;"	f	class:openvpn::OpenSSLContext
mode	polarssl/ssl/sslctx.hpp	/^      Mode mode;$/;"	m	class:openvpn::PolarSSLContext::Config
mode	polarssl/ssl/sslctx.hpp	/^    virtual const Mode& mode() const$/;"	f	class:openvpn::PolarSSLContext
mode	ssl/proto.hpp	/^    const Mode& mode() const { return mode_; }$/;"	f	class:openvpn::ProtoContext
mode_	crypto/cipher.hpp	/^    int mode_;$/;"	m	class:openvpn::CipherContext
mode_	ssl/proto.hpp	/^    Mode mode_;                        \/\/ client or server$/;"	m	class:openvpn::ProtoContext
mode_str	ssl/datalimit.hpp	/^    static const char *mode_str(const Mode m)$/;"	f	class:openvpn::DataLimit
module_name	win/modname.hpp	/^      inline std::wstring module_name()$/;"	f	namespace:openvpn::Win
module_name_utf8	win/modname.hpp	/^    inline std::string module_name_utf8()$/;"	f	namespace:openvpn::Win
more	addr/range.hpp	/^	bool more() const { return remaining_ > 0; }$/;"	f	class:openvpn::IP::RangeType::Iterator
move	buffer/buffer.hpp	/^    void move(BufferAllocatedType& other)$/;"	f	class:openvpn::BufferAllocatedType
move	common/cleanup.hpp	/^      : clean(std::move(method))$/;"	f	class:openvpn::CleanupType
move	common/exception.hpp	/^    Exception(std::string&& err) noexcept : err_(std::move(err)) {}$/;"	f	class:openvpn::Exception
move	common/function.hpp	/^        : functor_(std::move(functor))$/;"	f	class:openvpn::Function::Intern
move	common/function.hpp	/^        : functor_(std::move(obj.functor_))$/;"	f	class:openvpn::Function::Intern
move	common/function.hpp	/^      static void move(void *dest, void *src)$/;"	f	class:openvpn::Function::Intern
move	common/function.hpp	/^      void (*move)(void *, void *);$/;"	m	struct:openvpn::Function::Methods
move	common/rc.hpp	/^      : callable(std::move(c))$/;"	f	class:openvpn::RCWeak::NotifyItem
move	openssl/pki/x509store.hpp	/^      X509_STORE* move()$/;"	f	class:openvpn::OpenSSLPKI::X509Store
move_	buffer/buffer.hpp	/^    void move_(BufferAllocatedType& other)$/;"	f	class:openvpn::BufferAllocatedType
move_to_ptr	buffer/buffer.hpp	/^    RCPtr<BufferAllocatedType<T>> move_to_ptr()$/;"	f	class:openvpn::BufferAllocatedType
mssfix	ssl/mssparms.hpp	/^    unsigned int mssfix;  \/\/ standard OpenVPN mssfix parm$/;"	m	struct:openvpn::MSSParms
mssfix_ctrl	ssl/mssparms.hpp	/^    unsigned int mssfix_ctrl;$/;"	m	struct:openvpn::MSSCtrlParms
mtu	openssl/bio/bio_memq_dgram.hpp	/^      long mtu;$/;"	m	class:openvpn::bmq_dgram::MemQ
mtu	ssl/mssparms.hpp	/^    bool mtu;             \/\/ consider transport packet overhead in MSS adjustment$/;"	m	struct:openvpn::MSSParms
mtu	tun/builder/capture.hpp	/^    int mtu = 0;$/;"	m	class:openvpn::TunBuilderCapture
mtu	tun/client/tunprop.hpp	/^      int mtu = 0;$/;"	m	struct:openvpn::TunProp::Config
multi	options/continuation.hpp	/^    OptionList multi;$/;"	m	struct:openvpn::PushOptionsBase
mutable_array	applecrypto/cf/cf.hpp	/^    inline MutableArray mutable_array(const CFIndex capacity=0)$/;"	f	namespace:openvpn::CF
mutable_array_new	applecrypto/cf/cfhelper.hpp	/^    inline CFTypeRef mutable_array_new()$/;"	f	namespace:openvpn::CF
mutable_buffers_1	buffer/buffer.hpp	/^    asio::mutable_buffers_1 mutable_buffers_1(const size_t tailroom = 0)$/;"	f	class:openvpn::BufferType
mutable_buffers_1	frame/frame.hpp	/^      asio::mutable_buffers_1 mutable_buffers_1(Buffer& buf) const$/;"	f	class:openvpn::Frame::Context
mutable_buffers_1_append	buffer/buffer.hpp	/^    asio::mutable_buffers_1 mutable_buffers_1_append(const size_t tailroom = 0)$/;"	f	class:openvpn::BufferType
mutable_buffers_1_append_clamp	buffer/buffer.hpp	/^    asio::mutable_buffers_1 mutable_buffers_1_append_clamp(const size_t tailroom = 0)$/;"	f	class:openvpn::BufferType
mutable_buffers_1_clamp	buffer/buffer.hpp	/^    asio::mutable_buffers_1 mutable_buffers_1_clamp(const size_t tailroom = 0)$/;"	f	class:openvpn::BufferType
mutable_buffers_1_clamp	frame/frame.hpp	/^      asio::mutable_buffers_1 mutable_buffers_1_clamp(Buffer& buf) const$/;"	f	class:openvpn::Frame::Context
mutable_dict	applecrypto/cf/cf.hpp	/^    inline MutableDict mutable_dict(const CFIndex capacity=0)$/;"	f	namespace:openvpn::CF
mutable_dict_copy	applecrypto/cf/cf.hpp	/^    inline MutableDict mutable_dict_copy(const DICT& dict, const CFIndex capacity=0)$/;"	f	namespace:openvpn::CF
mutable_dict_new	applecrypto/cf/cfhelper.hpp	/^    inline CFTypeRef mutable_dict_new()$/;"	f	namespace:openvpn::CF
mutate	transport/tcplink.hpp	/^      TransportMutateStream::Ptr mutate;$/;"	m	class:openvpn::TCPTransport::Link
mutex	common/asiocontext.hpp	/^    std::mutex mutex;$/;"	m	class:openvpn::AsioContextStore
mutex	common/pthreadcond.hpp	/^    std::mutex mutex;$/;"	m	class:openvpn::PThreadBarrier
mutex	common/runcontext.hpp	/^    std::recursive_mutex mutex;$/;"	m	class:openvpn::RunContext
mutex	common/stop.hpp	/^    std::recursive_mutex mutex;$/;"	m	class:openvpn::Stop
mutex	log/logbasesimple.hpp	/^    std::mutex mutex;$/;"	m	class:openvpn::LogBaseSimple
mutex	server/vpnservpool.hpp	/^      std::mutex mutex;$/;"	m	class:openvpn::VPNServerPool::Pool
mydata_index	openssl/ssl/sslctx.hpp	/^      static int mydata_index;$/;"	m	class:openvpn::OpenSSLContext::SSL
mydata_index	openssl/ssl/sslctx.hpp	/^  int OpenSSLContext::SSL::mydata_index = -1;$/;"	m	class:openvpn::OpenSSLContext::SSL
n_bytes	buffer/buflimit.hpp	/^    T n_bytes;$/;"	m	class:openvpn::BufferLimit
n_bytes	http/htmlskip.hpp	/^      unsigned long n_bytes() const { return bytes; }$/;"	f	class:openvpn::HTTP::HTMLSkip
n_bytes	random/randbytestore.hpp	/^    unsigned int n_bytes = 0;$/;"	m	class:openvpn::RandomByteStore
n_contexts	frame/frame.hpp	/^    size_t n_contexts() const { return N_ALIGN_CONTEXTS; }$/;"	f	class:openvpn::Frame
n_cores	common/core.hpp	/^  inline int n_cores()$/;"	f	namespace:openvpn
n_err	openssl/util/error.hpp	/^    size_t n_err;$/;"	m	class:openvpn::OpenSSLException
n_errors	openssl/ssl/sslctx.hpp	/^      unsigned int n_errors;$/;"	m	class:openvpn::OpenSSLContext::ExternalPKIImpl
n_in_use	addr/pool.hpp	/^      size_t n_in_use() const$/;"	f	class:openvpn::IP::PoolType
n_key_ids	ssl/proto.hpp	/^    unsigned int n_key_ids;$/;"	m	class:openvpn::ProtoContext
n_lines	buffer/buflimit.hpp	/^    T n_lines;$/;"	m	class:openvpn::BufferLimit
n_parallel	transport/client/udpcli.hpp	/^      int n_parallel;$/;"	m	class:openvpn::UDPTransport::ClientConfig
n_parallel	tun/builder/client.hpp	/^      int n_parallel;            \/\/ number of parallel async reads on tun socket$/;"	m	class:openvpn::TunBuilderClient::ClientConfig
n_parallel	tun/linux/client/tuncli.hpp	/^      int n_parallel = 8;$/;"	m	class:openvpn::TunLinux::ClientConfig
n_parallel	tun/mac/client/tuncli.hpp	/^      int n_parallel = 8;        \/\/ number of parallel async reads on tun socket$/;"	m	class:openvpn::TunMac::ClientConfig
n_parallel	tun/win/client/tuncli.hpp	/^      int n_parallel = 8;         \/\/ number of parallel async reads on tun socket$/;"	m	class:openvpn::TunWin::ClientConfig
n_threads	server/listenlist.hpp	/^      unsigned int n_threads = 0;$/;"	m	struct:openvpn::Listen::Item
n_transactions	transport/client/httpcli.hpp	/^      unsigned int n_transactions;$/;"	m	class:openvpn::HTTPProxyTransport::Client
n_unacked	reliable/relsend.hpp	/^    unsigned int n_unacked()$/;"	f	class:openvpn::ReliableSendTemplate
n_unused	common/options.hpp	/^    size_t n_unused() const$/;"	f	class:openvpn::OptionList
name	applecrypto/crypto/digest.hpp	/^      const char *name() const { return CryptoAlgs::name(type_); }$/;"	f	class:openvpn::AppleCrypto::DigestInfo
name	applecrypto/util/rand.hpp	/^    virtual std::string name() const$/;"	f	class:openvpn::AppleRandom
name	client/clievent.hpp	/^      const char *name() const$/;"	f	class:openvpn::ClientEvent::Base
name	common/getopt.hpp	/^    const char *name;$/;"	m	struct:openvpn::option
name	compress/compnull.hpp	/^    virtual const char *name() const { return "null"; }$/;"	f	class:openvpn::CompressNull
name	compress/compstub.hpp	/^    virtual const char *name() const { return "stub"; }$/;"	f	class:openvpn::CompressStub
name	compress/compstub.hpp	/^    virtual const char *name() const { return "stubv2"; }$/;"	f	class:openvpn::CompressStubV2
name	compress/lz4.hpp	/^    virtual const char *name() const { return "lz4"; }$/;"	f	class:openvpn::CompressLZ4
name	compress/lz4.hpp	/^    virtual const char *name() const { return "lz4v2"; }$/;"	f	class:openvpn::CompressLZ4v2
name	compress/lzo.hpp	/^    virtual const char *name() const { return "lzo"; }$/;"	f	class:openvpn::CompressLZO
name	compress/lzoasym.hpp	/^    virtual const char *name() const { return "lzo-asym"; }$/;"	f	class:openvpn::CompressLZOAsym
name	compress/snappy.hpp	/^    virtual const char *name() const { return "snappy"; }$/;"	f	class:openvpn::CompressSnappy
name	crypto/cryptoalgs.hpp	/^      const char *name() const { return name_; }$/;"	f	class:openvpn::CryptoAlgs::Alg
name	crypto/cryptoalgs.hpp	/^    inline const char *name(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
name	crypto/cryptoalgs.hpp	/^    inline const char *name(const Type type, const char *default_name)$/;"	f	namespace:openvpn::CryptoAlgs
name	crypto/digestapi.hpp	/^    virtual std::string name() const$/;"	f	class:openvpn::CryptoDigestContext
name	crypto/packet_id.hpp	/^    std::string name;               \/\/ name of this object (for debugging)$/;"	m	class:openvpn::PacketIDReceiveType
name	error/error.hpp	/^    inline const char *name(const size_t type)$/;"	f	namespace:openvpn::Error
name	http/header.hpp	/^      std::string name;$/;"	m	struct:openvpn::HTTP::Header
name	http/urlparm.hpp	/^      std::string name;$/;"	m	struct:openvpn::URL::Parm
name	openssl/util/rand.hpp	/^    virtual std::string name() const$/;"	f	class:openvpn::OpenSSLRandom
name	pki/x509track.hpp	/^    inline const char *name(const Type type)$/;"	f	namespace:openvpn::X509Track
name	polarssl/util/rand.hpp	/^    virtual std::string name() const$/;"	f	class:openvpn::PolarSSLRandom
name	random/devurand.hpp	/^    virtual std::string name() const$/;"	f	class:openvpn::DevURand
name	random/mtrandapi.hpp	/^    virtual std::string name() const$/;"	f	class:openvpn::MTRand
name	tun/tunio.hpp	/^    std::string name() const$/;"	f	class:openvpn::TunIO
name	tun/win/tunutil.hpp	/^	std::string name;$/;"	m	struct:openvpn::TunWin::Util::TapNameGuidPair
name_	crypto/cryptoalgs.hpp	/^      const char *name_;$/;"	m	class:openvpn::CryptoAlgs::Alg
name_	tun/tunio.hpp	/^    std::string name_;$/;"	m	class:openvpn::TunIO
name_from_guid	tun/win/tunutil.hpp	/^	std::string name_from_guid(const std::string& guid) const$/;"	f	struct:openvpn::TunWin::Util::TapNameGuidPairList
names	pki/x509track.hpp	/^    static const char *const names[] = { \/\/ CONST GLOBAL$/;"	m	namespace:openvpn::X509Track
names	tun/win/nrpt.hpp	/^	const std::vector<std::string> names;$/;"	m	class:openvpn::TunWin::NRPT::ActionCreate
nbdd	tun/win/tunutil.hpp	/^	std::vector<IPv4::Addr> nbdd;  \/\/ NBDD (45)$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
nc	apple/maclife.hpp	/^    NotifyCallback* nc;$/;"	m	class:openvpn::MacLifeCycle
need_creds	client/cliopt.hpp	/^    bool need_creds() const$/;"	f	class:openvpn::ClientOptions
negate	addr/ipv4.hpp	/^      void negate()$/;"	f	class:openvpn::IPv4::Addr
negate	addr/ipv6.hpp	/^      void negate()$/;"	f	class:openvpn::IPv6::Addr
negotiations	ssl/proto.hpp	/^    unsigned int negotiations() const { return n_key_ids; }$/;"	f	class:openvpn::ProtoContext
net	server/vpnservnetblock.hpp	/^      IP::Addr net;$/;"	m	struct:openvpn::VPNServerNetblock::Netblock
net30	tun/builder/capture.hpp	/^      bool net30 = false;$/;"	m	class:openvpn::TunBuilderCapture::RouteBase
net_recv	ssl/proto.hpp	/^      bool net_recv(Packet&& pkt)$/;"	f	class:openvpn::ProtoContext::KeyContext
net_recv	ssl/protostack.hpp	/^    bool net_recv(PACKET&& pkt)$/;"	f	class:openvpn::ProtoStackBase
net_send	ssl/proto.hpp	/^      void net_send(const Packet& net_pkt, const Base::NetSendType nstype)  \/\/ called by ProtoStackBase$/;"	f	class:openvpn::ProtoContext::KeyContext
net_send	ssl/proto.hpp	/^    void net_send(const unsigned int key_id, const Packet& net_pkt)$/;"	f	class:openvpn::ProtoContext
net_time_t	crypto/packet_id.hpp	/^    typedef std::uint32_t net_time_t;$/;"	t	struct:openvpn::PacketID
net_up	apple/maclife.hpp	/^      bool net_up;$/;"	m	struct:openvpn::MacLifeCycle::State
net_up	apple/maclife.hpp	/^    bool net_up()$/;"	f	class:openvpn::MacLifeCycle
netbios_node_type	tun/win/tunutil.hpp	/^	int netbios_node_type = 0;     \/\/ NBT 1,2,4,8 (46)$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
netbios_scope	tun/win/tunutil.hpp	/^	std::string netbios_scope;     \/\/ NBS (47)$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
netblock4	server/vpnservnetblock.hpp	/^    const Netblock& netblock4() const { return snb4; }$/;"	f	class:openvpn::VPNServerNetblock
netblock6	server/vpnservnetblock.hpp	/^    const Netblock& netblock6() const { return snb6; }$/;"	f	class:openvpn::VPNServerNetblock
netmask	addr/addrpair.hpp	/^      Addr netmask;$/;"	m	struct:openvpn::IP::AddrMaskPair
netmask	addr/route.hpp	/^      ADDR netmask() const$/;"	f	struct:openvpn::IP::RouteType
netmask	server/vpnservnetblock.hpp	/^      IP::Addr netmask() const$/;"	f	struct:openvpn::VPNServerNetblock::Netblock
netmask	tun/win/tunutil.hpp	/^	IPv4::Addr netmask = IPv4::Addr::from_zero();$/;"	m	struct:openvpn::TunWin::Util::IPNetmask4
netmask_from_extent	addr/ip.hpp	/^      Addr netmask_from_extent() const$/;"	f	class:openvpn::IP::Addr
netmask_from_extent	addr/ipv4.hpp	/^      Addr netmask_from_extent() const$/;"	f	class:openvpn::IPv4::Addr
netmask_from_extent	addr/ipv6.hpp	/^      Addr netmask_from_extent() const$/;"	f	class:openvpn::IPv6::Addr
netmask_from_prefix_len	addr/ip.hpp	/^      static Addr netmask_from_prefix_len(Version v, const unsigned int prefix_len)$/;"	f	class:openvpn::IP::Addr
netmask_from_prefix_len	addr/ipv4.hpp	/^      static Addr netmask_from_prefix_len(const unsigned int prefix_len)$/;"	f	class:openvpn::IPv4::Addr
netmask_from_prefix_len	addr/ipv6.hpp	/^      static Addr netmask_from_prefix_len(const unsigned int prefix_len)$/;"	f	class:openvpn::IPv6::Addr
network_addr	addr/ip.hpp	/^      Addr network_addr(const unsigned int prefix_len) const {$/;"	f	class:openvpn::IP::Addr
network_addr	addr/ipv4.hpp	/^      Addr network_addr(const unsigned int prefix_len) const$/;"	f	class:openvpn::IPv4::Addr
network_addr	addr/ipv6.hpp	/^      Addr network_addr(const unsigned int prefix_len) const$/;"	f	class:openvpn::IPv6::Addr
network_available	apple/maclife.hpp	/^    virtual bool network_available()$/;"	f	class:openvpn::MacLifeCycle
network_to_host_order	addr/ipv6.hpp	/^      static void network_to_host_order(union ipv6addr *dest, const union ipv6addr *src)$/;"	f	class:openvpn::IPv6::Addr
new_client	client/cliconnect.hpp	/^    void new_client()$/;"	f	class:openvpn::ClientConnect
new_client_instance	server/servproto.hpp	/^  inline TransportClientInstanceRecv::Ptr ServerProto::Factory::new_client_instance()$/;"	f	class:openvpn::ServerProto::Factory
new_compressor	compress/compress.hpp	/^    Compress::Ptr new_compressor(const Frame::Ptr& frame, const SessionStats::Ptr& stats)$/;"	f	class:openvpn::CompressContext
new_context	common/asiocontext.hpp	/^    asio::io_context& new_context(int concurrency_hint)$/;"	f	class:openvpn::AsioContextStore
new_context	crypto/digestapi.hpp	/^  virtual DigestContext::Ptr new_context(const CryptoAlgs::Type digest_type)$/;"	f	class:openvpn::CryptoDigestFactory
new_digest	crypto/digestapi.hpp	/^    virtual DigestInstance::Ptr new_digest()$/;"	f	class:openvpn::CryptoDigestContext
new_digest	crypto/digestapi.hpp	/^  virtual DigestInstance::Ptr new_digest(const CryptoAlgs::Type digest_type)$/;"	f	class:openvpn::CryptoDigestFactory
new_factory	applecrypto/ssl/sslctx.hpp	/^      virtual SSLFactoryAPI::Ptr new_factory()$/;"	f	class:openvpn::AppleSSLContext::Config
new_factory	openssl/ssl/sslctx.hpp	/^      virtual SSLFactoryAPI::Ptr new_factory()$/;"	f	class:openvpn::OpenSSLContext::Config
new_factory	polarssl/ssl/sslctx.hpp	/^      virtual SSLFactoryAPI::Ptr new_factory()$/;"	f	class:openvpn::PolarSSLContext::Config
new_from_foreign_set	ssl/peerinfo.hpp	/^      static Ptr new_from_foreign_set(const SET& other)$/;"	f	struct:openvpn::PeerInfo::Set
new_guid	tun/win/wfp.hpp	/^      static GUID new_guid()$/;"	f	class:openvpn::TunWin::WFP
new_hmac	crypto/digestapi.hpp	/^    virtual HMACInstance::Ptr new_hmac(const unsigned char *key,$/;"	f	class:openvpn::CryptoDigestContext
new_hmac	crypto/digestapi.hpp	/^  virtual HMACInstance::Ptr new_hmac(const CryptoAlgs::Type digest_type,$/;"	f	class:openvpn::CryptoDigestFactory
new_obj	client/cliemuexr.hpp	/^    virtual EmulateExcludeRoute::Ptr new_obj() const$/;"	f	class:openvpn::EmulateExcludeRouteFactoryImpl
new_obj	crypto/crypto_aead.hpp	/^      virtual CryptoDCInstance::Ptr new_obj(const unsigned int key_id)$/;"	f	class:openvpn::AEAD::CryptoContext
new_obj	crypto/crypto_chm.hpp	/^    virtual CryptoDCInstance::Ptr new_obj(const unsigned int key_id)$/;"	f	class:openvpn::CryptoContextCHM
new_obj	crypto/cryptodcsel.hpp	/^    virtual CryptoDCContext::Ptr new_obj(const CryptoAlgs::Type cipher,$/;"	f	class:openvpn::CryptoDCSelect
new_obj	crypto/ovpnhmac.hpp	/^    virtual OvpnHMACContext::Ptr new_obj(const CryptoAlgs::Type digest_type)$/;"	f	class:openvpn::CryptoOvpnHMACFactory
new_obj	crypto/ovpnhmac.hpp	/^    virtual OvpnHMACInstance::Ptr new_obj()$/;"	f	class:openvpn::CryptoOvpnHMACContext
new_obj	ssl/tlsprf.hpp	/^    virtual TLSPRFInstance::Ptr new_obj(const bool self_is_server)$/;"	f	class:openvpn::CryptoTLSPRFFactory
new_obj	transport/client/httpcli.hpp	/^      static Ptr new_obj()$/;"	f	class:openvpn::HTTPProxyTransport::ClientConfig
new_obj	transport/client/tcpcli.hpp	/^      static Ptr new_obj()$/;"	f	class:openvpn::TCPTransport::ClientConfig
new_obj	transport/client/udpcli.hpp	/^      static Ptr new_obj()$/;"	f	class:openvpn::UDPTransport::ClientConfig
new_obj	tun/builder/client.hpp	/^      static Ptr new_obj()$/;"	f	class:openvpn::TunBuilderClient::ClientConfig
new_obj	tun/client/tunnull.hpp	/^      static Ptr new_obj()$/;"	f	class:openvpn::TunNull::ClientConfig
new_obj	tun/linux/client/tuncli.hpp	/^      static Ptr new_obj()$/;"	f	class:openvpn::TunLinux::ClientConfig
new_obj	tun/mac/client/tuncli.hpp	/^      static Ptr new_obj()$/;"	f	class:openvpn::TunMac::ClientConfig
new_obj	tun/win/client/tuncli.hpp	/^      static Ptr new_obj()$/;"	f	class:openvpn::TunWin::ClientConfig
new_secondary_key	ssl/proto.hpp	/^    void new_secondary_key(const bool initiator)$/;"	f	class:openvpn::ProtoContext
new_setup_obj	tun/mac/client/tuncli.hpp	/^      TunBuilderSetup::Base::Ptr new_setup_obj()$/;"	f	class:openvpn::TunMac::ClientConfig
new_setup_obj	tun/win/client/tuncli.hpp	/^      TunWin::SetupBase::Ptr new_setup_obj(asio::io_context& io_context)$/;"	f	class:openvpn::TunWin::ClientConfig
new_transport_client_obj	transport/client/httpcli.hpp	/^    inline TransportClient::Ptr ClientConfig::new_transport_client_obj(asio::io_context& io_context, TransportClientParent& parent)$/;"	f	class:openvpn::HTTPProxyTransport::ClientConfig
new_transport_client_obj	transport/client/tcpcli.hpp	/^    inline TransportClient::Ptr ClientConfig::new_transport_client_obj(asio::io_context& io_context,$/;"	f	class:openvpn::TCPTransport::ClientConfig
new_transport_client_obj	transport/client/udpcli.hpp	/^    inline TransportClient::Ptr ClientConfig::new_transport_client_obj(asio::io_context& io_context,$/;"	f	class:openvpn::UDPTransport::ClientConfig
new_tun_client_obj	tun/builder/client.hpp	/^    inline TunClient::Ptr ClientConfig::new_tun_client_obj(asio::io_context& io_context,$/;"	f	class:openvpn::TunBuilderClient::ClientConfig
new_tun_client_obj	tun/client/tunnull.hpp	/^    inline TunClient::Ptr ClientConfig::new_tun_client_obj(asio::io_context& io_context,$/;"	f	class:openvpn::TunNull::ClientConfig
new_tun_client_obj	tun/linux/client/tuncli.hpp	/^    inline TunClient::Ptr ClientConfig::new_tun_client_obj(asio::io_context& io_context,$/;"	f	class:openvpn::TunLinux::ClientConfig
new_tun_client_obj	tun/mac/client/tuncli.hpp	/^    inline TunClient::Ptr ClientConfig::new_tun_client_obj(asio::io_context& io_context,$/;"	f	class:openvpn::TunMac::ClientConfig
new_tun_client_obj	tun/win/client/tuncli.hpp	/^    inline TunClient::Ptr ClientConfig::new_tun_client_obj(asio::io_context& io_context,$/;"	f	class:openvpn::TunWin::ClientConfig
next	addr/range.hpp	/^	void next()$/;"	f	class:openvpn::IP::RangeType::Iterator
next	addr/range.hpp	/^      bool next(RangeType<ADDR>& r)$/;"	f	class:openvpn::IP::RangePartitionType
next	client/cliopt.hpp	/^    void next()$/;"	f	class:openvpn::ClientOptions
next	client/remotelist.hpp	/^      void next()$/;"	f	class:openvpn::RemoteList::PreResolve
next	client/remotelist.hpp	/^    void next()$/;"	f	class:openvpn::RemoteList
next	common/hostlist.hpp	/^      bool next(const List& list, HOST& host)$/;"	f	class:openvpn::HostList::Iterator
next	common/rc.hpp	/^      NotifyBase* next;$/;"	m	class:openvpn::RCWeak::NotifyBase
next	common/splitlines.hpp	/^    Status next(std::string& ln, const bool trim=true)$/;"	f	class:openvpn::SplitLinesType
next	crypto/packet_id.hpp	/^    PacketID next(const PacketID::time_t now)$/;"	f	class:openvpn::PacketIDSend
next	reliable/relsend.hpp	/^    id_t next;$/;"	m	class:openvpn::ReliableSendTemplate
next_event	ssl/proto.hpp	/^      EventType next_event;$/;"	m	class:openvpn::ProtoContext::KeyContext
next_event	transport/gremlin.hpp	/^      AsioTimer next_event;$/;"	m	struct:openvpn::Gremlin::DelayedQueue
next_event_time	ssl/proto.hpp	/^      Time next_event_time;$/;"	m	class:openvpn::ProtoContext::KeyContext
next_housekeeping	ssl/proto.hpp	/^    Time next_housekeeping() const$/;"	f	class:openvpn::ProtoContext
next_key_id	ssl/proto.hpp	/^    unsigned int next_key_id()$/;"	f	class:openvpn::ProtoContext
next_retransmit	ssl/proto.hpp	/^      Time next_retransmit() const$/;"	f	class:openvpn::ProtoContext::KeyContext
next_retransmit	ssl/protostack.hpp	/^    Time next_retransmit() const$/;"	f	class:openvpn::ProtoStackBase
next_retransmit_	ssl/protostack.hpp	/^    Time next_retransmit_;$/;"	m	class:openvpn::ProtoStackBase
next_sequenced	reliable/relrecv.hpp	/^    Message& next_sequenced()$/;"	f	class:openvpn::ReliableRecvTemplate
next_timeout	openssl/bio/bio_memq_dgram.hpp	/^      struct timeval next_timeout;$/;"	m	class:openvpn::bmq_dgram::MemQ	typeref:struct:openvpn::bmq_dgram::MemQ::timeval
no_argument	common/getopt.hpp	/^    no_argument=0,$/;"	e	enum:openvpn::__anon19
noexcept	common/rc.hpp	/^      Controller(RCWeak* parent_arg) noexcept$/;"	m	struct:openvpn::RCWeak::Controller
noexcept	common/rc.hpp	/^      ControllerRef(RCWeak* parent) noexcept$/;"	m	struct:openvpn::ControllerRef
noexcept	common/rc.hpp	/^      virtual void call() noexcept = 0;$/;"	m	class:openvpn::RCWeak::NotifyBase
noexcept	common/rc.hpp	/^    template <typename R> friend void intrusive_ptr_add_ref(R* p) noexcept;$/;"	m	class:openvpn::RC
noexcept	common/rc.hpp	/^    template <typename R> friend void intrusive_ptr_add_ref(R* p) noexcept;$/;"	m	class:openvpn::RCCopyable
noexcept	common/rc.hpp	/^    template <typename R> friend void intrusive_ptr_release(R* p) noexcept;$/;"	m	class:openvpn::RC
noexcept	common/rc.hpp	/^    template <typename R> friend void intrusive_ptr_release(R* p) noexcept;$/;"	m	class:openvpn::RCCopyable
nonce	crypto/crypto_aead.hpp	/^	Nonce nonce;$/;"	m	struct:openvpn::AEAD::Crypto::Decrypt
nonce	crypto/crypto_aead.hpp	/^	Nonce nonce;$/;"	m	struct:openvpn::AEAD::Crypto::Encrypt
normalize_cn	auth/authcert.hpp	/^      std::string normalize_cn() const \/\/ remove trailing "_AUTOLOGIN" from AS certs$/;"	f	struct:openvpn::AuthCert
not_closed_out_err	common/options.hpp	/^    static void not_closed_out_err(const char *type, const Option& opt)$/;"	f	class:openvpn::OptionList
not_implemented	applecrypto/ssl/sslctx.hpp	/^      void not_implemented(const char *funcname)$/;"	f	class:openvpn::AppleSSLContext::Config
not_implemented	openssl/ssl/sslctx.hpp	/^      static void not_implemented(RSA *rsa)$/;"	f	class:openvpn::OpenSSLContext::ExternalPKIImpl
notifierObject	apple/macsleep.hpp	/^    io_object_t notifierObject;$/;"	m	class:openvpn::MacSleep
notify	common/rc.hpp	/^      NotifyListHead notify;                \/\/ linked list of callables to be notified on object release$/;"	m	namespace:openvpn
notifyPortRef	apple/macsleep.hpp	/^    IONotificationPortRef notifyPortRef;$/;"	m	class:openvpn::MacSleep
notify_callback	client/cliproto.hpp	/^      NotifyCallback* notify_callback;$/;"	m	class:openvpn::ClientProto::Session
notify_callback	client/remotelist.hpp	/^      NotifyCallback* notify_callback;$/;"	m	class:openvpn::RemoteList::PreResolve
notify_sleep	apple/maclife.hpp	/^    virtual void notify_sleep()$/;"	f	class:openvpn::MacLifeCycle
notify_wakeup	apple/maclife.hpp	/^    virtual void notify_wakeup()$/;"	f	class:openvpn::MacLifeCycle
now	ssl/proto.hpp	/^      TimePtr now;$/;"	m	class:openvpn::ProtoContext::Config
now	ssl/proto.hpp	/^    const Time& now() const { return *now_; }$/;"	f	class:openvpn::ProtoContext
now	ssl/protostack.hpp	/^    TimePtr now;$/;"	m	class:openvpn::ProtoStackBase
now	time/asiotimer.hpp	/^    static time_point now()$/;"	f	struct:openvpn::AsioClock
now	time/time.hpp	/^    static TimeType now() { return TimeType(now_()); }$/;"	f	class:openvpn::TimeType
now_	client/cliopt.hpp	/^    Time now_; \/\/ current time$/;"	m	class:openvpn::ClientOptions
now_	ssl/proto.hpp	/^    TimePtr now_;                      \/\/ pointer to current time (a clone of config->now)$/;"	m	class:openvpn::ProtoContext
now_	time/time.hpp	/^    static T now_()$/;"	f	class:openvpn::TimeType
ns_cert_type	openssl/ssl/sslctx.hpp	/^      NSCert::Type ns_cert_type;$/;"	m	class:openvpn::OpenSSLContext::Config
ns_cert_type	polarssl/ssl/sslctx.hpp	/^      NSCert::Type ns_cert_type;$/;"	m	class:openvpn::PolarSSLContext::Config
ns_cert_type	ssl/nscert.hpp	/^    inline Type ns_cert_type(const OptionList& opt) {$/;"	f	namespace:openvpn::NSCert
ns_cert_type_defined	openssl/ssl/sslctx.hpp	/^    bool ns_cert_type_defined() const$/;"	f	class:openvpn::OpenSSLContext
ns_cert_type_defined	polarssl/ssl/sslctx.hpp	/^    bool ns_cert_type_defined() const$/;"	f	class:openvpn::PolarSSLContext
ntlm_auth_phase_1	transport/client/httpcli.hpp	/^      void ntlm_auth_phase_1(HTTPProxy::ProxyAuthenticate& pa)$/;"	f	class:openvpn::HTTPProxyTransport::Client
ntlm_auth_phase_2	transport/client/httpcli.hpp	/^      void ntlm_auth_phase_2()$/;"	f	class:openvpn::HTTPProxyTransport::Client
ntlm_auth_phase_2_pre	transport/client/httpcli.hpp	/^      void ntlm_auth_phase_2_pre()$/;"	f	class:openvpn::HTTPProxyTransport::Client
ntlm_auth_phase_3	transport/client/httpcli.hpp	/^      void ntlm_auth_phase_3(const std::string& phase_2_response)$/;"	f	class:openvpn::HTTPProxyTransport::Client
ntlm_phase_2_response_pending	transport/client/httpcli.hpp	/^      bool ntlm_phase_2_response_pending;$/;"	m	class:openvpn::HTTPProxyTransport::Client
ntp	tun/win/tunutil.hpp	/^	std::vector<IPv4::Addr> ntp;   \/\/ NTP (42)$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
null_terminate	buffer/buffer.hpp	/^    void null_terminate()$/;"	f	class:openvpn::BufferType
number_from_index	applecrypto/cf/cf.hpp	/^    inline Number number_from_index(const CFIndex n)$/;"	f	namespace:openvpn::CF
number_from_int	applecrypto/cf/cf.hpp	/^    inline Number number_from_int(const int n)$/;"	f	namespace:openvpn::CF
number_from_int32	applecrypto/cf/cf.hpp	/^    inline Number number_from_int32(const SInt32 n)$/;"	f	namespace:openvpn::CF
number_from_long_long	applecrypto/cf/cf.hpp	/^    inline Number number_from_long_long(const long long n)$/;"	f	namespace:openvpn::CF
obj	log/logthread.hpp	/^      static OPENVPN_LOG_CLASS* obj()$/;"	f	struct:openvpn::Log::Context
obj	openssl/pki/crl.hpp	/^      X509_CRL* obj() const { return crl_; }$/;"	f	class:openvpn::OpenSSLPKI::CRL
obj	openssl/pki/dh.hpp	/^      ::DH* obj() const { return dh_; }$/;"	f	class:openvpn::OpenSSLPKI::DH
obj	openssl/pki/pkey.hpp	/^      EVP_PKEY* obj() const { return pkey_; }$/;"	f	class:openvpn::OpenSSLPKI::PKey
obj	openssl/pki/x509.hpp	/^      ::X509* obj() const { return x509_; }$/;"	f	class:openvpn::OpenSSLPKI::X509Base
obj	openssl/pki/x509store.hpp	/^      X509_STORE* obj() const { return x509_store_; }$/;"	f	class:openvpn::OpenSSLPKI::X509Store
obj	tun/persist/tunwrap.hpp	/^    typename SCOPED_OBJ::base_type obj() const$/;"	f	class:openvpn::TunWrapTemplate
obj_	applecrypto/cf/cf.hpp	/^      T obj_;$/;"	m	class:openvpn::CF::Wrap
obj_	common/autoreset.hpp	/^    T* obj_;$/;"	m	class:openvpn::AutoReset
obj_	common/scoped_asio_stream.hpp	/^    STREAM* obj_;$/;"	m	class:openvpn::ScopedAsioStream
obj_	tun/persist/tunwrap.hpp	/^    SCOPED_OBJ obj_;$/;"	m	class:openvpn::TunWrapTemplate
obj_defined	tun/persist/tunwrap.hpp	/^    bool obj_defined() const$/;"	f	class:openvpn::TunWrapTemplate
obj_dup	openssl/pki/x509.hpp	/^      ::X509* obj_dup() const { return dup(x509_); }$/;"	f	class:openvpn::OpenSSLPKI::X509Base
offset	buffer/buffer.hpp	/^    size_t offset() const { return offset_; }$/;"	f	class:openvpn::BufferType
offset_	buffer/buffer.hpp	/^    size_t offset_;    \/\/ offset from data_ of beginning of T array (to allow for headroom)$/;"	m	class:openvpn::BufferType
offsetsFromUTF8	common/unicode-impl.hpp	/^    const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL, $/;"	m	namespace:openvpn::Unicode
old_mask_	common/signal.hpp	/^    sigset_t old_mask_;$/;"	m	class:openvpn::SignalBlocker
old_title	win/console.hpp	/^	std::string old_title;$/;"	m	class:openvpn::Win::Console::Title
old_title_defined	win/console.hpp	/^	bool old_title_defined;$/;"	m	class:openvpn::Win::Console::Title
olong	common/olong.hpp	/^  typedef long long olong;$/;"	t	namespace:openvpn
one	addr/ipv4.hpp	/^      void one()$/;"	f	class:openvpn::IPv4::Addr
one	addr/ipv6.hpp	/^      void one()$/;"	f	class:openvpn::IPv6::Addr
op	ip/dhcp.hpp	/^    std::uint8_t  op;         \/* message op *\/$/;"	m	struct:openvpn::DHCP
op32_compose	ssl/proto.hpp	/^    static unsigned int op32_compose(const unsigned int opcode,$/;"	f	class:openvpn::ProtoContext
op_compose	ssl/proto.hpp	/^    static unsigned int op_compose(const unsigned int opcode, const unsigned int key_id)$/;"	f	class:openvpn::ProtoContext
op_head_size	ssl/proto.hpp	/^    static size_t op_head_size(const unsigned int op)$/;"	f	class:openvpn::ProtoContext
opcode	ssl/proto.hpp	/^      unsigned int opcode;$/;"	m	class:openvpn::ProtoContext::Packet
opcode	ssl/proto.hpp	/^      unsigned int opcode;$/;"	m	class:openvpn::ProtoContext::PacketType
opcode_extract	ssl/proto.hpp	/^    static unsigned int opcode_extract(const unsigned int op)$/;"	f	class:openvpn::ProtoContext
opcode_name	ssl/proto.hpp	/^    static const char *opcode_name(const unsigned int opcode)$/;"	f	class:openvpn::ProtoContext
open	common/asioboundsock.hpp	/^      asio::error_code open(implementation_type& impl,$/;"	f	struct:openvpn::AsioBoundSocket::SocketService
open_input	common/redir.hpp	/^    void open_input(const std::string& fn)$/;"	f	class:openvpn::RedirectStd
open_output	common/redir.hpp	/^    void open_output(const std::string& fn,$/;"	f	class:openvpn::RedirectStd
open_unit	tun/linux/tun.hpp	/^      static void open_unit(const std::string& name, struct ifreq& ifr, ScopedFD& fd)$/;"	f	class:openvpn::TunLinux::Tun
openssl_clear_error_stack	openssl/util/error.hpp	/^  inline void openssl_clear_error_stack()$/;"	f	namespace:openvpn
openssl_error	openssl/util/error.hpp	/^  inline std::string openssl_error()$/;"	f	namespace:openvpn
openssl_error	openssl/util/error.hpp	/^  inline std::string openssl_error(const int ssl_error)$/;"	f	namespace:openvpn
openssl_init	openssl/util/init.hpp	/^  typedef asio::ssl::detail::openssl_init<> openssl_init;$/;"	t	namespace:openvpn
openssl_init_	init/cryptoinit.hpp	/^    openssl_init openssl_init_;$/;"	m	class:openvpn::crypto_init
openssl_setup_engine	openssl/util/engine.hpp	/^  inline void openssl_setup_engine (const std::string& engine)$/;"	f	namespace:openvpn
openvpn	addr/addrlist.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/addrpair.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/ip.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/iperr.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/ipv4.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/ipv6.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/macaddr.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/pool.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/range.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/regex.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/route.hpp	/^namespace openvpn {$/;"	n
openvpn	addr/routeinv.hpp	/^namespace openvpn {$/;"	n
openvpn	apple/maclife.hpp	/^namespace openvpn {$/;"	n
openvpn	apple/macsleep.hpp	/^namespace openvpn {$/;"	n
openvpn	apple/macver.hpp	/^namespace openvpn {$/;"	n
openvpn	apple/runloop.hpp	/^namespace openvpn {$/;"	n
openvpn	apple/scdynstore.hpp	/^namespace openvpn {$/;"	n
openvpn	apple/ver.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/cf/cf.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/cf/cfhelper.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/cf/cfsec.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/cf/cftimer.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/cf/error.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/crypto/api.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/crypto/cipher.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/crypto/digest.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/crypto/hmac.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/ssl/sslctx.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/util/iosactiveiface.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/util/rand.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/util/reach.hpp	/^namespace openvpn {$/;"	n
openvpn	applecrypto/util/reachable.hpp	/^namespace openvpn {$/;"	n
openvpn	auth/authcert.hpp	/^namespace openvpn {$/;"	n
openvpn	auth/authcreds.hpp	/^namespace openvpn {$/;"	n
openvpn	auth/cr.hpp	/^namespace openvpn {$/;"	n
openvpn	auth/validatecreds.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/asiobuf.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/bufclamp.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/bufcomplete.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/bufcomposed.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/buffer.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/bufhex.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/buflimit.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/buflist.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/bufstr.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/bufstream.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/memq.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/safestr.hpp	/^namespace openvpn {$/;"	n
openvpn	buffer/zlib.hpp	/^namespace openvpn {$/;"	n
openvpn	client/cliconnect.hpp	/^namespace openvpn {$/;"	n
openvpn	client/cliconstants.hpp	/^namespace openvpn {$/;"	n
openvpn	client/clicreds.hpp	/^namespace openvpn {$/;"	n
openvpn	client/cliemuexr.hpp	/^namespace openvpn {$/;"	n
openvpn	client/clievent.hpp	/^namespace openvpn {$/;"	n
openvpn	client/clihalt.hpp	/^namespace openvpn {$/;"	n
openvpn	client/clilife.hpp	/^namespace openvpn {$/;"	n
openvpn	client/cliopt.hpp	/^namespace openvpn {$/;"	n
openvpn	client/cliopthelper.hpp	/^namespace openvpn {$/;"	n
openvpn	client/cliproto.hpp	/^namespace openvpn {$/;"	n
openvpn	client/ipverflags.hpp	/^namespace openvpn {$/;"	n
openvpn	client/optfilt.hpp	/^namespace openvpn {$/;"	n
openvpn	client/remotelist.hpp	/^namespace openvpn {$/;"	n
openvpn	client/rgopt.hpp	/^namespace openvpn {$/;"	n
openvpn	common/action.hpp	/^namespace openvpn {$/;"	n
openvpn	common/actionthread.hpp	/^namespace openvpn {$/;"	n
openvpn	common/argv.hpp	/^namespace openvpn {$/;"	n
openvpn	common/arraysize.hpp	/^namespace openvpn {$/;"	n
openvpn	common/asioboundsock.hpp	/^namespace openvpn {$/;"	n
openvpn	common/asiocontext.hpp	/^namespace openvpn {$/;"	n
openvpn	common/asioerr.hpp	/^namespace openvpn {$/;"	n
openvpn	common/asiopolysock.hpp	/^namespace openvpn {$/;"	n
openvpn	common/asiosignal.hpp	/^namespace openvpn {$/;"	n
openvpn	common/asiostop.hpp	/^namespace openvpn {$/;"	n
openvpn	common/asyncsleep.hpp	/^namespace openvpn {$/;"	n
openvpn	common/autoreset.hpp	/^namespace openvpn {$/;"	n
openvpn	common/base64.hpp	/^namespace openvpn {$/;"	n
openvpn	common/binprefix.hpp	/^namespace openvpn {$/;"	n
openvpn	common/circ_list.hpp	/^namespace openvpn {$/;"	n
openvpn	common/cleanup.hpp	/^namespace openvpn {$/;"	n
openvpn	common/core.hpp	/^namespace openvpn {$/;"	n
openvpn	common/count.hpp	/^namespace openvpn {$/;"	n
openvpn	common/daemon.hpp	/^namespace openvpn {$/;"	n
openvpn	common/demangle.hpp	/^namespace openvpn {$/;"	n
openvpn	common/destruct.hpp	/^namespace openvpn {$/;"	n
openvpn	common/endian.hpp	/^namespace openvpn {$/;"	n
openvpn	common/enumdir.hpp	/^namespace openvpn {$/;"	n
openvpn	common/exception.hpp	/^namespace openvpn {$/;"	n
openvpn	common/ffs.hpp	/^namespace openvpn {$/;"	n
openvpn	common/file.hpp	/^namespace openvpn {$/;"	n
openvpn	common/fileatomic.hpp	/^namespace openvpn {$/;"	n
openvpn	common/format.hpp	/^namespace openvpn {$/;"	n
openvpn	common/function.hpp	/^namespace openvpn {$/;"	n
openvpn	common/getopt.hpp	/^namespace openvpn {$/;"	n
openvpn	common/getpw.hpp	/^namespace openvpn {$/;"	n
openvpn	common/glob.hpp	/^namespace openvpn {$/;"	n
openvpn	common/hash.hpp	/^namespace openvpn {$/;"	n
openvpn	common/hexstr.hpp	/^namespace openvpn {$/;"	n
openvpn	common/hostlist.hpp	/^namespace openvpn {$/;"	n
openvpn	common/hostport.hpp	/^namespace openvpn {$/;"	n
openvpn	common/inotify.hpp	/^namespace openvpn {$/;"	n
openvpn	common/lex.hpp	/^namespace openvpn {$/;"	n
openvpn	common/link.hpp	/^namespace openvpn {$/;"	n
openvpn	common/logrotate.hpp	/^namespace openvpn {$/;"	n
openvpn	common/memneq.hpp	/^namespace openvpn {$/;"	n
openvpn	common/mode.hpp	/^namespace openvpn {$/;"	n
openvpn	common/msgwin.hpp	/^namespace openvpn {$/;"	n
openvpn	common/number.hpp	/^namespace openvpn {$/;"	n
openvpn	common/olong.hpp	/^namespace openvpn {$/;"	n
openvpn	common/options.hpp	/^namespace openvpn {$/;"	n
openvpn	common/path.hpp	/^namespace openvpn {$/;"	n
openvpn	common/peercred.hpp	/^namespace openvpn {$/;"	n
openvpn	common/persistfile.hpp	/^namespace openvpn {$/;"	n
openvpn	common/platform_name.hpp	/^namespace openvpn {$/;"	n
openvpn	common/platform_string.hpp	/^namespace openvpn {$/;"	n
openvpn	common/process.hpp	/^namespace openvpn {$/;"	n
openvpn	common/pthreadcond.hpp	/^namespace openvpn {$/;"	n
openvpn	common/rc.hpp	/^namespace openvpn {$/;"	n
openvpn	common/redir.hpp	/^namespace openvpn {$/;"	n
openvpn	common/runcontext.hpp	/^namespace openvpn {$/;"	n
openvpn	common/scoped_asio_stream.hpp	/^namespace openvpn {$/;"	n
openvpn	common/scoped_fd.hpp	/^namespace openvpn {$/;"	n
openvpn	common/signal.hpp	/^namespace openvpn {$/;"	n
openvpn	common/sleep.hpp	/^namespace openvpn {$/;"	n
openvpn	common/sockopt.hpp	/^namespace openvpn {$/;"	n
openvpn	common/split.hpp	/^namespace openvpn {$/;"	n
openvpn	common/splitlines.hpp	/^namespace openvpn {$/;"	n
openvpn	common/stat.hpp	/^namespace openvpn {$/;"	n
openvpn	common/stop.hpp	/^namespace openvpn {$/;"	n
openvpn	common/string.hpp	/^namespace openvpn {$/;"	n
openvpn	common/tempfile.hpp	/^namespace openvpn {$/;"	n
openvpn	common/umask.hpp	/^namespace openvpn {$/;"	n
openvpn	common/unicode-impl.hpp	/^namespace openvpn {$/;"	n
openvpn	common/unicode.hpp	/^namespace openvpn {$/;"	n
openvpn	common/uniqueptr.hpp	/^namespace openvpn {$/;"	n
openvpn	common/usecount.hpp	/^namespace openvpn {$/;"	n
openvpn	common/usergroup.hpp	/^namespace openvpn {$/;"	n
openvpn	common/userpass.hpp	/^namespace openvpn {$/;"	n
openvpn	common/waitbarrier.hpp	/^namespace openvpn {$/;"	n
openvpn	common/write.hpp	/^namespace openvpn {$/;"	n
openvpn	common/wstring.hpp	/^namespace openvpn {$/;"	n
openvpn	compress/compnull.hpp	/^namespace openvpn {$/;"	n
openvpn	compress/compress.hpp	/^namespace openvpn {$/;"	n
openvpn	compress/compstub.hpp	/^namespace openvpn {$/;"	n
openvpn	compress/lz4.hpp	/^namespace openvpn {$/;"	n
openvpn	compress/lzo.hpp	/^namespace openvpn {$/;"	n
openvpn	compress/lzoasym.hpp	/^namespace openvpn {$/;"	n
openvpn	compress/lzoasym_impl.hpp	/^namespace openvpn {$/;"	n
openvpn	compress/lzoselect.hpp	/^namespace openvpn {$/;"	n
openvpn	compress/snappy.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/bs64_data_limit.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/cipher.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/crypto_aead.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/crypto_chm.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/cryptoalgs.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/cryptodc.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/cryptodcsel.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/decrypt_chm.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/digestapi.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/encrypt_chm.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/hashstr.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/ovpnhmac.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/packet_id.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/selftest.hpp	/^namespace openvpn {$/;"	n
openvpn	crypto/static_key.hpp	/^namespace openvpn {$/;"	n
openvpn	error/error.hpp	/^namespace openvpn {$/;"	n
openvpn	error/excode.hpp	/^namespace openvpn {$/;"	n
openvpn	frame/frame.hpp	/^namespace openvpn {$/;"	n
openvpn	frame/frame_init.hpp	/^namespace openvpn {$/;"	n
openvpn	frame/memq_dgram.hpp	/^namespace openvpn {$/;"	n
openvpn	frame/memq_stream.hpp	/^namespace openvpn {$/;"	n
openvpn	http/header.hpp	/^namespace openvpn {$/;"	n
openvpn	http/htmlskip.hpp	/^namespace openvpn {$/;"	n
openvpn	http/method.hpp	/^namespace openvpn {$/;"	n
openvpn	http/parseutil.hpp	/^namespace openvpn {$/;"	n
openvpn	http/reply.hpp	/^namespace openvpn {$/;"	n
openvpn	http/request.hpp	/^namespace openvpn {$/;"	n
openvpn	http/status.hpp	/^namespace openvpn {$/;"	n
openvpn	http/urlencode.hpp	/^namespace openvpn {$/;"	n
openvpn	http/urlparm.hpp	/^namespace openvpn {$/;"	n
openvpn	http/urlparse.hpp	/^namespace openvpn {$/;"	n
openvpn	http/webexcept.hpp	/^namespace openvpn {$/;"	n
openvpn	init/cryptoinit.hpp	/^namespace openvpn {$/;"	n
openvpn	init/engineinit.hpp	/^namespace openvpn {$/;"	n
openvpn	init/initprocess.hpp	/^namespace openvpn {$/;"	n
openvpn	ip/dhcp.hpp	/^namespace openvpn {$/;"	n
openvpn	ip/eth.hpp	/^namespace openvpn {$/;"	n
openvpn	ip/icmp.hpp	/^namespace openvpn {$/;"	n
openvpn	ip/ip.hpp	/^namespace openvpn {$/;"	n
openvpn	ip/udp.hpp	/^namespace openvpn {$/;"	n
openvpn	linux/core.hpp	/^namespace openvpn {$/;"	n
openvpn	linux/daemon_alive.hpp	/^namespace openvpn {$/;"	n
openvpn	log/logbase.hpp	/^namespace openvpn {$/;"	n
openvpn	log/logbasesimple.hpp	/^namespace openvpn {$/;"	n
openvpn	log/logperiod.hpp	/^namespace openvpn {$/;"	n
openvpn	log/logsimple.hpp	/^namespace openvpn {$/;"	n
openvpn	log/logthread.hpp	/^namespace openvpn {$/;"	n
openvpn	log/sessionstats.hpp	/^namespace openvpn {$/;"	n
openvpn	netconf/enumiface.hpp	/^namespace openvpn {$/;"	n
openvpn	netconf/hwaddr.hpp	/^namespace openvpn {$/;"	n
openvpn	netconf/linux/route.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/bio/bio_memq_dgram.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/bio/bio_memq_stream.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/crypto/api.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/crypto/cipher.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/crypto/ciphergcm.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/crypto/digest.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/crypto/hmac.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/pki/crl.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/pki/dh.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/pki/pkey.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/pki/x509.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/pki/x509store.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/sign/pkcs7verify.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/sign/verify.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/ssl/sslctx.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/util/engine.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/util/error.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/util/init.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/util/rand.hpp	/^namespace openvpn {$/;"	n
openvpn	openssl/util/tokenencrypt.hpp	/^namespace openvpn {$/;"	n
openvpn	options/continuation.hpp	/^namespace openvpn {$/;"	n
openvpn	options/merge.hpp	/^namespace openvpn {$/;"	n
openvpn	options/sanitize.hpp	/^namespace openvpn {$/;"	n
openvpn	options/servpush.hpp	/^namespace openvpn {$/;"	n
openvpn	pki/cclist.hpp	/^namespace openvpn {$/;"	n
openvpn	pki/epkibase.hpp	/^namespace openvpn {$/;"	n
openvpn	pki/pkcs1.hpp	/^namespace openvpn {$/;"	n
openvpn	pki/x509track.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/crypto/api.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/crypto/cipher.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/crypto/ciphergcm.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/crypto/digest.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/crypto/hmac.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/pki/dh.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/pki/pkctx.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/pki/x509cert.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/pki/x509crl.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/ssl/sslctx.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/util/error.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/util/rand.hpp	/^namespace openvpn {$/;"	n
openvpn	polarssl/util/selftest.hpp	/^namespace openvpn {$/;"	n
openvpn	proxy/httpdigest.hpp	/^namespace openvpn {$/;"	n
openvpn	proxy/ntlm.hpp	/^namespace openvpn {$/;"	n
openvpn	proxy/proxyauth.hpp	/^namespace openvpn {$/;"	n
openvpn	random/devurand.hpp	/^namespace openvpn {$/;"	n
openvpn	random/mtrandapi.hpp	/^namespace openvpn {$/;"	n
openvpn	random/randapi.hpp	/^namespace openvpn {$/;"	n
openvpn	random/randbytestore.hpp	/^namespace openvpn {$/;"	n
openvpn	reliable/relack.hpp	/^namespace openvpn {$/;"	n
openvpn	reliable/relcommon.hpp	/^namespace openvpn {$/;"	n
openvpn	reliable/relrecv.hpp	/^namespace openvpn {$/;"	n
openvpn	reliable/relsend.hpp	/^namespace openvpn {$/;"	n
openvpn	server/listenlist.hpp	/^namespace openvpn {$/;"	n
openvpn	server/manage.hpp	/^namespace openvpn {$/;"	n
openvpn	server/peeraddr.hpp	/^namespace openvpn {$/;"	n
openvpn	server/peerstats.hpp	/^namespace openvpn {$/;"	n
openvpn	server/servhalt.hpp	/^namespace openvpn {$/;"	n
openvpn	server/servproto.hpp	/^namespace openvpn {$/;"	n
openvpn	server/vpnservnetblock.hpp	/^namespace openvpn {$/;"	n
openvpn	server/vpnservpool.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/datalimit.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/is_openvpn_protocol.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/kuparse.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/mssparms.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/nscert.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/peerinfo.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/proto.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/proto_context_options.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/protostack.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/psid.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/sslapi.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/sslchoose.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/sslconsts.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/tls_remote.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/tlsprf.hpp	/^namespace openvpn {$/;"	n
openvpn	ssl/tlsver.hpp	/^namespace openvpn {$/;"	n
openvpn	time/asiotimer.hpp	/^namespace openvpn {$/;"	n
openvpn	time/coarsetime.hpp	/^namespace openvpn {$/;"	n
openvpn	time/durhelper.hpp	/^namespace openvpn {$/;"	n
openvpn	time/time.hpp	/^namespace openvpn {$/;"	n
openvpn	time/timestr.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/altproxy.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/client/httpcli.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/client/tcpcli.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/client/transbase.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/client/udpcli.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/dco.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/gremlin.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/mutate.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/pktstream.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/protocol.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/reconnect_notify.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/server/transbase.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/socket_protect.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/tcplink.hpp	/^namespace openvpn {$/;"	n
openvpn	transport/udplink.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/builder/base.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/builder/capture.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/builder/client.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/builder/rgwflags.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/builder/setup.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/client/dhcp_capture.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/client/emuexr.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/client/tunbase.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/client/tunnull.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/client/tunprop.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/ipv6_setting.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/layer.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/linux/client/tuncli.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/linux/tun.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/mac/client/tuncli.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/mac/client/tunsetup.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/mac/gwv4.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/mac/macdns.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/mac/macdns_watchdog.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/mac/macgw.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/mac/tunutil.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/mac/utun.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/persist/tunpersist.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/persist/tunwrap.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/persist/tunwrapasio.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/server/tunbase.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/tunio.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/tunmtu.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/tunspec.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/win/client/setupbase.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/win/client/tuncli.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/win/client/tunsetup.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/win/nrpt.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/win/tunutil.hpp	/^namespace openvpn {$/;"	n
openvpn	tun/win/wfp.hpp	/^namespace openvpn {$/;"	n
openvpn	win/call.hpp	/^namespace openvpn {$/;"	n
openvpn	win/cmd.hpp	/^namespace openvpn {$/;"	n
openvpn	win/console.hpp	/^namespace openvpn {$/;"	n
openvpn	win/handle.hpp	/^namespace openvpn {$/;"	n
openvpn	win/modname.hpp	/^namespace openvpn {$/;"	n
openvpn	win/reg.hpp	/^namespace openvpn {$/;"	n
openvpn	win/scoped_handle.hpp	/^namespace openvpn {$/;"	n
openvpn	win/sleep.hpp	/^namespace openvpn {$/;"	n
openvpn	win/unicode.hpp	/^namespace openvpn {$/;"	n
openvpn	win/winerr.hpp	/^namespace openvpn {$/;"	n
openvpn_PRF	ssl/tlsprf.hpp	/^    static void openvpn_PRF (const unsigned char *secret,$/;"	f	class:openvpn::TLSPRF
openvpn_app_path	tun/win/client/tunsetup.hpp	/^	std::wstring openvpn_app_path;$/;"	m	struct:openvpn::TunWin::Setup::L2State
openvpn_app_path	tun/win/wfp.hpp	/^      const std::wstring openvpn_app_path;$/;"	m	class:openvpn::TunWin::ActionWFP
openvpn_copyright	legal/copyright.hpp	/^  const char openvpn_copyright[] = "Copyright (C) 2012-2016 OpenVPN Technologies, Inc. All rights reserved."; \/\/ CONST GLOBAL$/;"	m	namespace:__anon52
operator !	time/time.hpp	/^      bool operator!() const { return duration_ == T(0); }$/;"	f	class:openvpn::TimeType::Duration
operator !	time/time.hpp	/^    bool operator!() const { return time_ == 0; }$/;"	f	class:openvpn::TimeType
operator !=	addr/ip.hpp	/^      bool operator!=(const Addr& other) const$/;"	f	class:openvpn::IP::Addr
operator !=	addr/ipv4.hpp	/^      bool operator!=(const Addr& other) const$/;"	f	class:openvpn::IPv4::Addr
operator !=	addr/ipv6.hpp	/^      bool operator!=(const Addr& other) const$/;"	f	class:openvpn::IPv6::Addr
operator !=	apple/maclife.hpp	/^      bool operator!=(const State& other) const$/;"	f	struct:openvpn::MacLifeCycle::State
operator !=	auth/authcert.hpp	/^      bool operator!=(const AuthCert& other) const$/;"	f	struct:openvpn::AuthCert
operator !=	buffer/buffer.hpp	/^    bool operator!=(const BufferType& other) const$/;"	f	class:openvpn::BufferType
operator !=	buffer/safestr.hpp	/^    bool operator!=(const char *str) const$/;"	f	class:openvpn::SafeString
operator !=	common/mode.hpp	/^    bool operator!=(const Mode& other)$/;"	f	class:openvpn::Mode
operator !=	common/options.hpp	/^    bool operator!=(const Option& other) const { return data != other.data; }$/;"	f	class:openvpn::Option
operator !=	transport/protocol.hpp	/^    bool operator!=(const Protocol& other) const$/;"	f	class:openvpn::Protocol
operator !=	tun/ipv6_setting.hpp	/^    bool operator!=(const IPv6Setting& other) const$/;"	f	class:openvpn::IPv6Setting
operator !=	tun/layer.hpp	/^    bool operator!=(const Layer& other) const$/;"	f	class:openvpn::Layer
operator !=	tun/win/tunutil.hpp	/^	bool operator!=(const IPNetmask4& rhs) const$/;"	f	struct:openvpn::TunWin::Util::IPNetmask4
operator %	addr/ipv4.hpp	/^      Addr operator%(const Addr& other) const {$/;"	f	class:openvpn::IPv4::Addr
operator %	addr/ipv6.hpp	/^      Addr operator%(const Addr& d) const {$/;"	f	class:openvpn::IPv6::Addr
operator &	addr/ipv4.hpp	/^      Addr operator&(const Addr& other) const {$/;"	f	class:openvpn::IPv4::Addr
operator &	addr/ipv6.hpp	/^      Addr operator&(const Addr& other) const {$/;"	f	class:openvpn::IPv6::Addr
operator ()	applecrypto/cf/cf.hpp	/^      T operator()() const { return obj_; }$/;"	f	class:openvpn::CF::Wrap
operator ()	client/rgopt.hpp	/^    unsigned int operator()() const { return flags_; }$/;"	f	class:openvpn::RedirectGatewayFlags
operator ()	common/action.hpp	/^      bool operator()()$/;"	f	class:openvpn::ActionList::Iter
operator ()	common/function.hpp	/^    R operator()(A... args)$/;"	f	class:openvpn::Function
operator ()	common/hash.hpp	/^      std::size_t operator()(const T& obj) const$/;"	f	class:openvpn::Hash::InitialSeed
operator ()	common/scoped_asio_stream.hpp	/^    STREAM* operator()() const$/;"	f	class:openvpn::ScopedAsioStream
operator ()	common/scoped_fd.hpp	/^    int operator()() const$/;"	f	class:openvpn::ScopedFD
operator ()	common/splitlines.hpp	/^    bool operator()(const bool trim=true)$/;"	f	class:openvpn::SplitLinesType
operator ()	random/randapi.hpp	/^    result_type operator()() { return rand_get<result_type>(); }$/;"	f	class:openvpn::RandomAPI
operator ()	transport/protocol.hpp	/^    Type operator()() const { return type_; }$/;"	f	class:openvpn::Protocol
operator ()	tun/ipv6_setting.hpp	/^    Type operator()() const { return type_; }$/;"	f	class:openvpn::IPv6Setting
operator ()	tun/layer.hpp	/^    Type operator()() const { return type_; }$/;"	f	class:openvpn::Layer
operator ()	tun/win/wfp.hpp	/^	HANDLE operator()() const$/;"	f	class:openvpn::TunWin::WFP::WFPEngine
operator ()	win/reg.hpp	/^      HKEY operator()() { return key; }$/;"	f	class:openvpn::Win::RegKey
operator ()	win/scoped_handle.hpp	/^      HANDLE operator()() const$/;"	f	class:openvpn::Win::ScopedHANDLE
operator *	addr/ipv4.hpp	/^      Addr operator*(const Addr& other) const {$/;"	f	class:openvpn::IPv4::Addr
operator *	addr/ipv6.hpp	/^      Addr operator*(const Addr& d) const {$/;"	f	class:openvpn::IPv6::Addr
operator *	time/time.hpp	/^      Duration operator*(const unsigned int mult) const$/;"	f	class:openvpn::TimeType::Duration
operator +	addr/ip.hpp	/^      Addr operator+(const long delta) const {$/;"	f	class:openvpn::IP::Addr
operator +	addr/ipv4.hpp	/^      Addr operator+(const Addr& other) const {$/;"	f	class:openvpn::IPv4::Addr
operator +	addr/ipv4.hpp	/^      Addr operator+(const long delta) const {$/;"	f	class:openvpn::IPv4::Addr
operator +	addr/ipv6.hpp	/^      Addr operator+(const Addr& other) const {$/;"	f	class:openvpn::IPv6::Addr
operator +	addr/ipv6.hpp	/^      Addr operator+(const long delta) const {$/;"	f	class:openvpn::IPv6::Addr
operator +	time/time.hpp	/^      Duration operator+(const Duration& d) const$/;"	f	class:openvpn::TimeType::Duration
operator +	time/time.hpp	/^      Duration operator+(const int delta) const$/;"	f	class:openvpn::TimeType::Duration
operator +	time/time.hpp	/^    TimeType operator+(const Duration& d) const$/;"	f	class:openvpn::TimeType
operator ++	addr/ip.hpp	/^      Addr& operator++()$/;"	f	class:openvpn::IP::Addr
operator ++	addr/ipv4.hpp	/^      Addr& operator++()$/;"	f	class:openvpn::IPv4::Addr
operator ++	addr/ipv6.hpp	/^      Addr& operator++()$/;"	f	class:openvpn::IPv6::Addr
operator +=	addr/ip.hpp	/^      Addr& operator+=(const long delta)$/;"	f	class:openvpn::IP::Addr
operator +=	addr/ipv4.hpp	/^      Addr& operator+=(const long delta)$/;"	f	class:openvpn::IPv4::Addr
operator +=	addr/ipv6.hpp	/^      Addr& operator+=(const Addr& other) {$/;"	f	class:openvpn::IPv6::Addr
operator +=	addr/ipv6.hpp	/^      Addr& operator+=(const long delta)$/;"	f	class:openvpn::IPv6::Addr
operator +=	buffer/safestr.hpp	/^    SafeString& operator+=(char c)$/;"	f	class:openvpn::SafeString
operator +=	buffer/safestr.hpp	/^    SafeString& operator+=(const SafeString& str)$/;"	f	class:openvpn::SafeString
operator +=	buffer/safestr.hpp	/^    SafeString& operator+=(const char* s)$/;"	f	class:openvpn::SafeString
operator +=	time/time.hpp	/^      Duration& operator+=(const Duration& d)$/;"	f	class:openvpn::TimeType::Duration
operator +=	time/time.hpp	/^    TimeType& operator+=(const Duration& d)$/;"	f	class:openvpn::TimeType
operator -	addr/ip.hpp	/^      Addr operator-(const long delta) const {$/;"	f	class:openvpn::IP::Addr
operator -	addr/ipv4.hpp	/^      Addr operator-(const Addr& other) const {$/;"	f	class:openvpn::IPv4::Addr
operator -	addr/ipv4.hpp	/^      Addr operator-(const long delta) const {$/;"	f	class:openvpn::IPv4::Addr
operator -	addr/ipv6.hpp	/^      Addr operator-(const Addr& other) const {$/;"	f	class:openvpn::IPv6::Addr
operator -	addr/ipv6.hpp	/^      Addr operator-(const long delta) const {$/;"	f	class:openvpn::IPv6::Addr
operator -	log/sessionstats.hpp	/^	Data operator-(const Data& rhs) const$/;"	f	struct:openvpn::SessionStats::DCOTransportSource::Data
operator -	time/time.hpp	/^      Duration operator-(const Duration& d) const$/;"	f	class:openvpn::TimeType::Duration
operator -	time/time.hpp	/^    Duration operator-(const TimeType& t) const$/;"	f	class:openvpn::TimeType
operator -=	addr/ip.hpp	/^      Addr& operator-=(const long delta)$/;"	f	class:openvpn::IP::Addr
operator -=	addr/ipv4.hpp	/^      Addr& operator-=(const long delta)$/;"	f	class:openvpn::IPv4::Addr
operator -=	addr/ipv6.hpp	/^      Addr& operator-=(const Addr& other) {$/;"	f	class:openvpn::IPv6::Addr
operator -=	addr/ipv6.hpp	/^      Addr& operator-=(const long delta)$/;"	f	class:openvpn::IPv6::Addr
operator -=	time/time.hpp	/^      Duration& operator-=(const Duration& d)$/;"	f	class:openvpn::TimeType::Duration
operator /	addr/ipv4.hpp	/^      Addr operator\/(const Addr& other) const {$/;"	f	class:openvpn::IPv4::Addr
operator /	addr/ipv6.hpp	/^      Addr operator\/(const Addr& d) const {$/;"	f	class:openvpn::IPv6::Addr
operator <	addr/ipv4.hpp	/^      bool operator<(const Addr& other) const$/;"	f	class:openvpn::IPv4::Addr
operator <<	addr/ip.hpp	/^      Addr operator<<(const unsigned int shift) const {$/;"	f	class:openvpn::IP::Addr
operator <<	addr/ipv4.hpp	/^      Addr operator<<(const unsigned int shift) const {$/;"	f	class:openvpn::IPv4::Addr
operator <<	addr/ipv6.hpp	/^      Addr operator<<(const unsigned int shift) const {$/;"	f	class:openvpn::IPv6::Addr
operator <<	buffer/safestr.hpp	/^  std::basic_ostream<Elem, Traits>& operator<<($/;"	f	namespace:openvpn
operator <<=	addr/ipv6.hpp	/^      Addr& operator<<=(const unsigned int shift) {$/;"	f	class:openvpn::IPv6::Addr
operator <=	addr/ipv4.hpp	/^      bool operator<=(const Addr& other) const$/;"	f	class:openvpn::IPv4::Addr
operator =	addr/ip.hpp	/^      Addr& operator=(const Addr& other)$/;"	f	class:openvpn::IP::Addr
operator =	applecrypto/cf/cf.hpp	/^      Wrap& operator=(const Wrap& other)$/;"	f	class:openvpn::CF::Wrap
operator =	buffer/buffer.hpp	/^    void operator=(const BufferAllocatedType& other)$/;"	f	class:openvpn::BufferAllocatedType
operator =	openssl/pki/crl.hpp	/^      void operator=(const CRL& other)$/;"	f	class:openvpn::OpenSSLPKI::CRL
operator =	openssl/pki/dh.hpp	/^      void operator=(const DH& other)$/;"	f	class:openvpn::OpenSSLPKI::DH
operator =	openssl/pki/pkey.hpp	/^      void operator=(const PKey& other)$/;"	f	class:openvpn::OpenSSLPKI::PKey
operator =	openssl/pki/x509.hpp	/^      void operator=(const X509& other)$/;"	f	class:openvpn::OpenSSLPKI::X509
operator ==	addr/ip.hpp	/^      bool operator==(const Addr& other) const$/;"	f	class:openvpn::IP::Addr
operator ==	addr/ipv4.hpp	/^      bool operator==(const Addr& other) const$/;"	f	class:openvpn::IPv4::Addr
operator ==	addr/ipv6.hpp	/^      bool operator==(const Addr& other) const$/;"	f	class:openvpn::IPv6::Addr
operator ==	addr/route.hpp	/^      bool operator==(const RouteType& other) const$/;"	f	struct:openvpn::IP::RouteType
operator ==	apple/maclife.hpp	/^      bool operator==(const State& other) const$/;"	f	struct:openvpn::MacLifeCycle::State
operator ==	auth/authcert.hpp	/^      bool operator==(const AuthCert& other) const$/;"	f	struct:openvpn::AuthCert
operator ==	buffer/buffer.hpp	/^    bool operator==(const BufferType& other) const$/;"	f	class:openvpn::BufferType
operator ==	buffer/safestr.hpp	/^    bool operator==(const char *str) const$/;"	f	class:openvpn::SafeString
operator ==	common/mode.hpp	/^    bool operator==(const Mode& other)$/;"	f	class:openvpn::Mode
operator ==	common/options.hpp	/^    bool operator==(const Option& other) const { return data == other.data; }$/;"	f	class:openvpn::Option
operator ==	transport/protocol.hpp	/^    bool operator==(const Protocol& other) const$/;"	f	class:openvpn::Protocol
operator ==	tun/ipv6_setting.hpp	/^    bool operator==(const IPv6Setting& other) const$/;"	f	class:openvpn::IPv6Setting
operator ==	tun/layer.hpp	/^    bool operator==(const Layer& other) const$/;"	f	class:openvpn::Layer
operator ==	tun/win/tunutil.hpp	/^	bool operator==(const IPNetmask4& rhs) const$/;"	f	struct:openvpn::TunWin::Util::IPNetmask4
operator >	addr/ipv4.hpp	/^      bool operator>(const Addr& other) const$/;"	f	class:openvpn::IPv4::Addr
operator >=	addr/ipv4.hpp	/^      bool operator>=(const Addr& other) const$/;"	f	class:openvpn::IPv4::Addr
operator >>	addr/ip.hpp	/^      Addr operator>>(const unsigned int shift) const {$/;"	f	class:openvpn::IP::Addr
operator >>	addr/ipv4.hpp	/^      Addr operator>>(const unsigned int shift) const {$/;"	f	class:openvpn::IPv4::Addr
operator >>	addr/ipv6.hpp	/^      Addr operator>>(const unsigned int shift) const {$/;"	f	class:openvpn::IPv6::Addr
operator >>=	addr/ipv6.hpp	/^      Addr& operator>>=(const unsigned int shift) {$/;"	f	class:openvpn::IPv6::Addr
operator []	addr/addrpair.hpp	/^	const std::string& operator[](const size_t i) const$/;"	f	class:openvpn::IP::AddrMaskPair::StringPair
operator []	addr/addrpair.hpp	/^	std::string& operator[](const size_t i)$/;"	f	class:openvpn::IP::AddrMaskPair::StringPair
operator []	buffer/buffer.hpp	/^    T& operator[](const size_t index)$/;"	f	class:openvpn::BufferType
operator []	buffer/buffer.hpp	/^    const T& operator[](const size_t index) const$/;"	f	class:openvpn::BufferType
operator []	buffer/safestr.hpp	/^    char& operator[](size_t pos)$/;"	f	class:openvpn::SafeString
operator []	buffer/safestr.hpp	/^    const char& operator[](size_t pos) const$/;"	f	class:openvpn::SafeString
operator []	common/base64.hpp	/^      unsigned char operator[](const size_t i) const { return data_[i]; }$/;"	f	class:openvpn::Base64::UCharWrap
operator []	common/circ_list.hpp	/^    T& operator[](const size_t index)$/;"	f	class:openvpn::CircList
operator []	common/circ_list.hpp	/^    const T& operator[](const size_t index) const$/;"	f	class:openvpn::CircList
operator []	common/glob.hpp	/^    const char* operator[](const size_t i) const$/;"	f	class:openvpn::Glob
operator []	frame/frame.hpp	/^    Context& operator[](const size_t i)$/;"	f	class:openvpn::Frame
operator []	frame/frame.hpp	/^    const Context& operator[](const size_t i) const$/;"	f	class:openvpn::Frame
operator []	openssl/util/error.hpp	/^    unsigned long operator[](const size_t i) const$/;"	f	class:openvpn::OpenSSLException
operator bool	ssl/proto.hpp	/^      operator bool() const { return bool(buf); }$/;"	f	class:openvpn::ProtoContext::Packet
operator |	addr/ipv4.hpp	/^      Addr operator|(const Addr& other) const {$/;"	f	class:openvpn::IPv4::Addr
operator |	addr/ipv6.hpp	/^      Addr operator|(const Addr& other) const {$/;"	f	class:openvpn::IPv6::Addr
operator ~	addr/ip.hpp	/^      Addr operator~() const {$/;"	f	class:openvpn::IP::Addr
operator ~	addr/ipv4.hpp	/^      Addr operator~() const {$/;"	f	class:openvpn::IPv4::Addr
operator ~	addr/ipv6.hpp	/^      Addr operator~() const {$/;"	f	class:openvpn::IPv6::Addr
optarg	common/getopt.hpp	/^  char *optarg = nullptr;    \/* argument associated with option *\/$/;"	m	namespace:openvpn
opterr	common/getopt.hpp	/^  int opterr = 1;         \/* if error message should be printed *\/$/;"	m	namespace:openvpn
optind	common/getopt.hpp	/^  int optind = 1;         \/* index into parent argv vector *\/$/;"	m	namespace:openvpn
option	common/getopt.hpp	/^  struct option$/;"	s	namespace:openvpn
optional_argument	common/getopt.hpp	/^    optional_argument=2$/;"	e	enum:openvpn::__anon19
options	ip/dhcp.hpp	/^    std::uint8_t options[];$/;"	m	struct:openvpn::DHCPPacket
options	tun/persist/tunpersist.hpp	/^    const std::string& options()$/;"	f	class:openvpn::TunPersistTemplate
options_	tun/persist/tunpersist.hpp	/^    std::string options_;$/;"	m	class:openvpn::TunPersistTemplate
options_string	compress/compress.hpp	/^    const char *options_string() const$/;"	f	class:openvpn::CompressContext
options_string	ssl/proto.hpp	/^      std::string options_string()$/;"	f	class:openvpn::ProtoContext::Config
optopt	common/getopt.hpp	/^  int optopt = 0;         \/* character checked for validity *\/$/;"	m	namespace:openvpn
optreset	common/getopt.hpp	/^  int optreset = 0;       \/* reset getopt *\/$/;"	m	namespace:openvpn
or_flags	buffer/buffer.hpp	/^    void or_flags(const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
orig_key	tun/mac/macdns.hpp	/^      CF::String orig_key(const std::string& key) const$/;"	f	class:openvpn::MacDNS::DSDict
os_	common/format.hpp	/^      std::ostringstream os_;$/;"	m	class:openvpn::print_formatted_detail::Output
oulong	common/olong.hpp	/^  typedef unsigned long long oulong;$/;"	t	namespace:openvpn
out	common/format.hpp	/^    print_formatted_detail::Output<OUTPUT> out;$/;"	m	class:openvpn::PrintFormatted
out	common/redir.hpp	/^      std::string out;$/;"	m	struct:openvpn::RedirectPipe::InOut
out	common/redir.hpp	/^    ScopedFD out;$/;"	m	struct:openvpn::RedirectStdFD
output_arg	options/servpush.hpp	/^    static void output_arg(const std::string& e, std::ostream& os)$/;"	f	class:openvpn::ServerPushList
output_csv	options/servpush.hpp	/^    void output_csv(std::ostream& os) const$/;"	f	class:openvpn::ServerPushList
output_size	crypto/cipher.hpp	/^    size_t output_size(const size_t in_size) const$/;"	f	class:openvpn::CipherContext
output_size	crypto/ovpnhmac.hpp	/^    size_t output_size() const$/;"	f	class:openvpn::OvpnHMAC
output_size	crypto/ovpnhmac.hpp	/^    virtual size_t output_size() const$/;"	f	class:openvpn::CryptoOvpnHMACInstance
overflow	applecrypto/ssl/sslctx.hpp	/^      bool overflow;$/;"	m	class:openvpn::AppleSSLContext::SSL
overflow	buffer/bufstream.hpp	/^    virtual int overflow(int c = EOF)$/;"	f	class:openvpn::BufferStream
overflow	common/splitlines.hpp	/^    bool overflow = false;$/;"	m	class:openvpn::SplitLinesType
overflow	openssl/ssl/sslctx.hpp	/^      bool overflow;$/;"	m	class:openvpn::OpenSSLContext::SSL
overflow	polarssl/ssl/sslctx.hpp	/^      bool overflow;$/;"	m	class:openvpn::PolarSSLContext::SSL
override	tun/win/client/tuncli.hpp	/^						TransportClient* transcli) override;$/;"	m	class:openvpn::TunWin::ClientConfig
override_dc_factory	server/servproto.hpp	/^      virtual void override_dc_factory(const CryptoDCFactory::Ptr& dc_factory)$/;"	f	class:openvpn::ServerProto::Session
override_tun	server/servproto.hpp	/^      virtual TunClientInstanceRecv* override_tun(TunClientInstanceSend* tun)$/;"	f	class:openvpn::ServerProto::Session
ovpn	tun/mac/macdns.hpp	/^      DSDict ovpn; \/\/ we may modify$/;"	m	class:openvpn::MacDNS::Info
ovpn_hmac	crypto/ovpnhmac.hpp	/^    OvpnHMAC<CRYPTO_API> ovpn_hmac;$/;"	m	class:openvpn::CryptoOvpnHMACInstance
ovpn_hmac_cmp	crypto/ovpnhmac.hpp	/^    bool ovpn_hmac_cmp(const unsigned char *data, const size_t data_size,$/;"	f	class:openvpn::OvpnHMAC
ovpn_hmac_cmp	crypto/ovpnhmac.hpp	/^    virtual bool ovpn_hmac_cmp(const unsigned char *data, const size_t data_size,$/;"	f	class:openvpn::CryptoOvpnHMACInstance
ovpn_hmac_gen	crypto/ovpnhmac.hpp	/^    virtual void ovpn_hmac_gen(unsigned char *data, const size_t data_size,$/;"	f	class:openvpn::CryptoOvpnHMACInstance
ovpn_hmac_gen	crypto/ovpnhmac.hpp	/^    void ovpn_hmac_gen(unsigned char *data, const size_t data_size,$/;"	f	class:openvpn::OvpnHMAC
ovpn_hmac_pre	crypto/ovpnhmac.hpp	/^    bool ovpn_hmac_pre(const unsigned char *data, const size_t data_size,$/;"	f	class:openvpn::OvpnHMAC
p1	transport/client/httpcli.hpp	/^	std::string p1;$/;"	m	struct:openvpn::HTTPProxyTransport::Options::CustomHeader
p2	transport/client/httpcli.hpp	/^	std::string p2;$/;"	m	struct:openvpn::HTTPProxyTransport::Options::CustomHeader
pack_string_vector	common/wstring.hpp	/^    inline std::wstring pack_string_vector(const std::vector<std::string>& strvec)$/;"	f	namespace:openvpn::wstring
packet	reliable/relcommon.hpp	/^    PACKET packet;$/;"	m	class:openvpn::ReliableMessageBase
packet_log	client/cliproto.hpp	/^      std::ofstream packet_log;$/;"	m	class:openvpn::ClientProto::Session
packet_type	ssl/proto.hpp	/^    PacketType packet_type(const Buffer& buf)$/;"	f	class:openvpn::ProtoContext
parent	common/rc.hpp	/^      RCWeak *const parent;  \/\/ dangles (harmlessly) after rc decrements to 0$/;"	m	class:openvpn::RCWeak
parent	polarssl/ssl/sslctx.hpp	/^      PolarSSLContext *parent;$/;"	m	class:openvpn::PolarSSLContext::SSL
parent	ssl/protostack.hpp	/^    PARENT& parent()$/;"	f	class:openvpn::ProtoStackBase
parent	transport/client/httpcli.hpp	/^      TransportClientParent& parent;$/;"	m	class:openvpn::HTTPProxyTransport::Client
parent	transport/client/tcpcli.hpp	/^      TransportClientParent& parent;$/;"	m	class:openvpn::TCPTransport::Client
parent	transport/client/udpcli.hpp	/^      TransportClientParent& parent;$/;"	m	class:openvpn::UDPTransport::Client
parent	tun/builder/client.hpp	/^      TunClientParent& parent;$/;"	m	class:openvpn::TunBuilderClient::Client
parent	tun/client/tunnull.hpp	/^      TunClientParent& parent;$/;"	m	class:openvpn::TunNull::Client
parent	tun/linux/client/tuncli.hpp	/^      TunClientParent& parent;$/;"	m	class:openvpn::TunLinux::Client
parent	tun/mac/client/tuncli.hpp	/^      TunClientParent& parent;$/;"	m	class:openvpn::TunMac::Client
parent	tun/mac/macdns_watchdog.hpp	/^      const MacDNSWatchdog::Ptr parent;$/;"	m	class:openvpn::MacDNSWatchdog::DNSAction
parent	tun/win/client/tuncli.hpp	/^      TunClientParent& parent;$/;"	m	class:openvpn::TunWin::Client
parms	proxy/proxyauth.hpp	/^      HTTP::HeaderList parms;$/;"	m	class:openvpn::HTTPProxy::ProxyAuthenticate
parse	buffer/bufhex.hpp	/^    inline T parse(const std::string& hex, const std::string& title)$/;"	f	namespace:openvpn::BufHex
parse	client/cliopthelper.hpp	/^    static ParseClientConfig parse(const std::string& content, OptionList::KeyValueList* content_list)$/;"	f	class:openvpn::ParseClientConfig
parse	client/cliopthelper.hpp	/^    static ParseClientConfig parse(const std::string& content,$/;"	f	class:openvpn::ParseClientConfig
parse	common/userpass.hpp	/^    inline bool parse(const OptionList& options,$/;"	f	namespace:openvpn::UserPass
parse	common/userpass.hpp	/^    inline void parse(const OptionList& options,$/;"	f	namespace:openvpn::UserPass
parse	common/userpass.hpp	/^    inline void parse(const std::string& path,$/;"	f	namespace:openvpn::UserPass
parse	crypto/static_key.hpp	/^    void parse(const std::string& key_text)$/;"	f	class:openvpn::OpenVPNStaticKey
parse	http/method.hpp	/^      Type parse(const std::string& methstr)$/;"	f	namespace:openvpn::HTTP::Method
parse	options/servpush.hpp	/^    void parse(const std::string& opt_name, const OptionList& opt)$/;"	f	class:openvpn::ServerPushList
parse	polarssl/pki/dh.hpp	/^      void parse(const std::string& dh_txt, const std::string& title)$/;"	f	class:openvpn::PolarSSLPKI::DH
parse	polarssl/pki/pkctx.hpp	/^      void parse(const std::string& key_txt, const std::string& title, const std::string& priv_key_pwd)$/;"	f	class:openvpn::PolarSSLPKI::PKContext
parse	polarssl/pki/x509cert.hpp	/^      void parse(const std::string& cert_txt, const std::string& title, const bool strict)$/;"	f	class:openvpn::PolarSSLPKI::X509Cert
parse	polarssl/pki/x509crl.hpp	/^      void parse(const std::string& crl_txt)$/;"	f	class:openvpn::PolarSSLPKI::X509CRL
parse	proxy/proxyauth.hpp	/^      void parse(const std::string& line)$/;"	f	class:openvpn::HTTPProxy::ProxyAuthenticate
parse	ssl/mssparms.hpp	/^    void parse(const OptionList& opt)$/;"	f	struct:openvpn::MSSParms
parse	transport/client/httpcli.hpp	/^      static Ptr parse(const OptionList& opt)$/;"	f	class:openvpn::HTTPProxyTransport::Options
parse	transport/protocol.hpp	/^    static Protocol parse(const std::string& str,$/;"	f	class:openvpn::Protocol
parse	tun/ipv6_setting.hpp	/^    static IPv6Setting parse(const std::string& str)$/;"	f	class:openvpn::IPv6Setting
parse_auth_user_pass	client/cliopthelper.hpp	/^    static bool parse_auth_user_pass(const OptionList& options, std::vector<std::string>* user_pass)$/;"	f	class:openvpn::ParseClientConfig
parse_bool	client/cliopthelper.hpp	/^    bool parse_bool(const Option& o, const std::string& title, const size_t index)$/;"	f	class:openvpn::ParseClientConfig
parse_compression_mode	ssl/proto_context_options.hpp	/^    void parse_compression_mode(const std::string& mode)$/;"	f	struct:openvpn::ProtoContextOptions
parse_csv	ssl/peerinfo.hpp	/^      static void parse_csv(const std::string& src, SET& dest)$/;"	f	struct:openvpn::PeerInfo::Set
parse_from_argv	common/options.hpp	/^    void parse_from_argv(const std::vector<std::string>& argv)$/;"	f	class:openvpn::OptionList
parse_from_argv_static	common/options.hpp	/^    static OptionList parse_from_argv_static(const std::vector<std::string>& argv)$/;"	f	class:openvpn::OptionList
parse_from_config	common/options.hpp	/^    void parse_from_config(const std::string& str, Limits* lim)$/;"	f	class:openvpn::OptionList
parse_from_config_static	common/options.hpp	/^    static OptionList parse_from_config_static(const std::string& str, Limits* lim)$/;"	f	class:openvpn::OptionList
parse_from_config_static_ptr	common/options.hpp	/^    static OptionList::Ptr parse_from_config_static_ptr(const std::string& str, Limits* lim)$/;"	f	class:openvpn::OptionList
parse_from_csv	common/options.hpp	/^    void parse_from_csv(const std::string& str, Limits* lim)$/;"	f	class:openvpn::OptionList
parse_from_csv_static	common/options.hpp	/^    static OptionList parse_from_csv_static(const std::string& str, Limits* lim)$/;"	f	class:openvpn::OptionList
parse_from_file	crypto/static_key.hpp	/^    void parse_from_file(const std::string filename)$/;"	f	class:openvpn::OpenVPNStaticKey
parse_from_key_value_list	common/options.hpp	/^    void parse_from_key_value_list(const KeyValueList& list, Limits* lim)$/;"	f	class:openvpn::OptionList
parse_from_peer_info	common/options.hpp	/^    void parse_from_peer_info(const std::string& str, Limits* lim)$/;"	f	class:openvpn::OptionList
parse_hex	common/hexstr.hpp	/^  inline void parse_hex(V& dest, const std::string& str)$/;"	f	namespace:openvpn
parse_hex_char	common/hexstr.hpp	/^  inline int parse_hex_char(const char c)$/;"	f	namespace:openvpn
parse_hex_number	common/hexstr.hpp	/^  inline T parse_hex_number(const std::string& str)$/;"	f	namespace:openvpn
parse_hex_number	common/hexstr.hpp	/^  inline bool parse_hex_number(const char *str, T& retval)$/;"	f	namespace:openvpn
parse_hex_number	common/hexstr.hpp	/^  inline bool parse_hex_number(const std::string& str, T& retval)$/;"	f	namespace:openvpn
parse_meta_from_config	common/options.hpp	/^    void parse_meta_from_config(const std::string& str, const std::string& tag, Limits* lim)$/;"	f	class:openvpn::OptionList
parse_method	compress/compress.hpp	/^    static Type parse_method(const std::string& method)$/;"	f	class:openvpn::CompressContext
parse_msg	client/clihalt.hpp	/^    static void parse_msg(StringList& sl, const std::string& msg)$/;"	f	class:openvpn::ClientHalt
parse_number	common/number.hpp	/^  inline bool parse_number(const char *str,$/;"	f	namespace:openvpn
parse_number	common/number.hpp	/^  inline bool parse_number(const std::string& str, T& retval)$/;"	f	namespace:openvpn
parse_number_throw	common/number.hpp	/^  inline T parse_number_throw(const char *str, const char *error)$/;"	f	namespace:openvpn
parse_number_throw	common/number.hpp	/^  inline T parse_number_throw(const std::string& str, const char *error)$/;"	f	namespace:openvpn
parse_number_throw	common/number.hpp	/^  inline T parse_number_throw(const std::string& str, const std::string& error)$/;"	f	namespace:openvpn
parse_number_validate	common/number.hpp	/^  inline bool parse_number_validate(const std::string& numstr,$/;"	f	namespace:openvpn
parse_option_from_line	common/options.hpp	/^    static Option parse_option_from_line(const std::string& line, Limits* lim)$/;"	f	class:openvpn::OptionList
parse_options	transport/client/httpcli.hpp	/^      bool parse_options(const OptionList& opt)$/;"	f	class:openvpn::HTTPProxyTransport::Options
parse_pem	openssl/pki/crl.hpp	/^      void parse_pem(const std::string& crl_txt)$/;"	f	class:openvpn::OpenSSLPKI::CRL
parse_pem	openssl/pki/dh.hpp	/^      void parse_pem(const std::string& dh_txt)$/;"	f	class:openvpn::OpenSSLPKI::DH
parse_pem	openssl/pki/pkey.hpp	/^      void parse_pem(const std::string& pkey_txt, const std::string& title)$/;"	f	class:openvpn::OpenSSLPKI::PKey
parse_pem	openssl/pki/x509.hpp	/^      void parse_pem(const std::string& cert_txt, const std::string& title)$/;"	f	class:openvpn::OpenSSLPKI::X509
parse_pem	pki/cclist.hpp	/^    void parse_pem(const std::string& content, const std::string& title)$/;"	f	class:openvpn::CertCRLListTemplate
parse_pem_file	pki/cclist.hpp	/^    void parse_pem_file(const std::string& filename)$/;"	f	class:openvpn::CertCRLListTemplate
parse_port	common/hostport.hpp	/^    inline unsigned short parse_port(const std::string& port, const std::string& title)$/;"	f	namespace:openvpn::HostPort
parse_static_cookie	auth/cr.hpp	/^    static void parse_static_cookie(const std::string& cookie,$/;"	f	class:openvpn::ChallengeResponse
parse_tls_version_min	ssl/tlsver.hpp	/^    inline Type parse_tls_version_min(const OptionList& opt, const Type max_version)$/;"	f	namespace:openvpn::TLSVersion
parse_tls_version_min	ssl/tlsver.hpp	/^    inline Type parse_tls_version_min(const std::string& ver,$/;"	f	namespace:openvpn::TLSVersion
parse_tun_mtu	tun/tunmtu.hpp	/^  inline unsigned int parse_tun_mtu(const OptionList& opt, unsigned int default_value)$/;"	f	namespace:openvpn
parse_type	pki/x509track.hpp	/^    inline Type parse_type(const std::string& name)$/;"	f	namespace:openvpn::X509Track
parse_type	transport/protocol.hpp	/^    static Type parse_type(const std::string& str,$/;"	f	class:openvpn::Protocol
partial	options/continuation.hpp	/^    bool partial() const { return partial_; }$/;"	f	class:openvpn::OptionListContinuation
partial_	options/continuation.hpp	/^    bool partial_;$/;"	m	class:openvpn::OptionListContinuation
password	auth/authcreds.hpp	/^      SafeString password;$/;"	m	class:openvpn::AuthCreds
password	client/clicreds.hpp	/^    std::string password;$/;"	m	class:openvpn::ClientCreds
password	transport/client/httpcli.hpp	/^      std::string password;$/;"	m	class:openvpn::HTTPProxyTransport::Options
password_defined	client/clicreds.hpp	/^    bool password_defined() const$/;"	f	class:openvpn::ClientCreds
password_save	client/clicreds.hpp	/^    std::string password_save;$/;"	m	class:openvpn::ClientCreds
password_save_defined	client/clicreds.hpp	/^    bool password_save_defined;$/;"	m	class:openvpn::ClientCreds
path	common/path.hpp	/^  namespace path {$/;"	n	namespace:openvpn
pause	client/cliconnect.hpp	/^    void pause(const std::string& reason)$/;"	f	class:openvpn::ClientConnect
pause_on_connection_timeout	client/cliopt.hpp	/^    bool pause_on_connection_timeout()$/;"	f	class:openvpn::ClientOptions
paused	apple/maclife.hpp	/^    bool paused;$/;"	m	class:openvpn::MacLifeCycle
paused	client/cliconnect.hpp	/^    bool paused;$/;"	m	class:openvpn::ClientConnect
payload	frame/frame.hpp	/^      size_t payload() const { return payload_; }$/;"	f	class:openvpn::Frame::Context
payload_	frame/frame.hpp	/^      size_t payload_;$/;"	m	class:openvpn::Frame::Context
pct	common/format.hpp	/^    bool pct;$/;"	m	class:openvpn::PrintFormatted
peek	buffer/memq.hpp	/^    BufferPtr& peek()$/;"	f	class:openvpn::MemQBase
peer	ssl/tlsprf.hpp	/^    TLSPRF<CRYPTO_API> peer;$/;"	m	class:openvpn::CryptoTLSPRFInstance
peerInfoUV	client/cliopthelper.hpp	/^    const PeerInfo::Set* peerInfoUV() const { return peerInfoUV_.get(); }$/;"	f	class:openvpn::ParseClientConfig
peerInfoUV_	client/cliopthelper.hpp	/^    PeerInfo::Set::Ptr peerInfoUV_;$/;"	m	class:openvpn::ParseClientConfig
peer_addr	server/servproto.hpp	/^      PeerAddr::Ptr peer_addr;$/;"	m	class:openvpn::ServerProto::Session
peer_id	ssl/proto.hpp	/^      int peer_id() const { return peer_id_; }$/;"	f	class:openvpn::ProtoContext::PacketType
peer_id_	ssl/proto.hpp	/^      int peer_id_;$/;"	m	class:openvpn::ProtoContext::PacketType
peer_info	auth/authcreds.hpp	/^      OptionList peer_info;$/;"	m	class:openvpn::AuthCreds
peer_info_string	compress/compress.hpp	/^    const char *peer_info_string() const$/;"	f	class:openvpn::CompressContext
peer_info_string	ssl/proto.hpp	/^      std::string peer_info_string() const$/;"	f	class:openvpn::ProtoContext::Config
peer_info_string_v1	compress/compress.hpp	/^    const char *peer_info_string_v1() const$/;"	f	class:openvpn::CompressContext
peer_read	ssl/tlsprf.hpp	/^    virtual void peer_read(Buffer& buf)$/;"	f	class:openvpn::CryptoTLSPRFInstance
peer_read_complete	ssl/tlsprf.hpp	/^    virtual bool peer_read_complete(BufferComplete& bc)$/;"	f	class:openvpn::CryptoTLSPRFInstance
peercreds	common/asiopolysock.hpp	/^      virtual bool peercreds(SockOpt::Creds& cr)$/;"	f	class:openvpn::AsioPolySock::Base
peercreds	common/peercred.hpp	/^    inline bool peercreds(const int fd, Creds& cr)$/;"	f	namespace:openvpn::SockOpt
pem_password_callback	openssl/pki/pkey.hpp	/^      static int pem_password_callback (char *buf, int size, int rwflag, void *userdata)$/;"	f	class:openvpn::OpenSSLPKI::PKey
pending	frame/memq_dgram.hpp	/^    size_t pending() const$/;"	f	class:openvpn::MemQDgram
pending	frame/memq_stream.hpp	/^    size_t pending() const$/;"	f	class:openvpn::MemQStream
pending	http/reply.hpp	/^	pending,$/;"	e	enum:openvpn::HTTP::ReplyParser::status
pending	http/request.hpp	/^	pending,$/;"	e	enum:openvpn::HTTP::RequestParser::status
per_thread	server/vpnservnetblock.hpp	/^    const PerThread& per_thread(const size_t index) const$/;"	f	class:openvpn::VPNServerNetblock
period	time/asiotimer.hpp	/^    typedef std::ratio<1, 1024> period; \/\/ time resolution of openvpn::Time$/;"	t	struct:openvpn::AsioClock
period_	log/logperiod.hpp	/^    Period period_;$/;"	m	class:openvpn::LogPeriod
period_base	log/logperiod.hpp	/^    static olong period_base(const Period p, const time_t time)$/;"	f	class:openvpn::LogPeriod
period_from_string	log/logperiod.hpp	/^    static Period period_from_string(const std::string& str)$/;"	f	class:openvpn::LogPeriod
period_sec	log/logperiod.hpp	/^    static olong period_sec(const Period p)$/;"	f	class:openvpn::LogPeriod
persist_tun_state	tun/persist/tunpersist.hpp	/^    bool persist_tun_state(const typename SCOPED_OBJ::base_type obj,$/;"	f	class:openvpn::TunPersistTemplate
phase_1	proxy/ntlm.hpp	/^      static std::string phase_1()$/;"	f	class:openvpn::HTTPProxy::NTLM
phase_3	proxy/ntlm.hpp	/^      static std::string phase_3(DigestFactory& digest_factory,$/;"	f	class:openvpn::HTTPProxy::NTLM
pid	common/peercred.hpp	/^      int pid;$/;"	m	struct:openvpn::SockOpt::Creds
pid_	crypto/packet_id.hpp	/^    PacketID pid_;$/;"	m	class:openvpn::PacketIDSend
pid_mode	ssl/proto.hpp	/^      int pid_mode = 0;                \/\/ PacketIDReceive::UDP_MODE or PacketIDReceive::TCP_MODE$/;"	m	class:openvpn::ProtoContext::Config
pid_recv	crypto/crypto_aead.hpp	/^	PacketIDReceive pid_recv;$/;"	m	struct:openvpn::AEAD::Crypto::Decrypt
pid_recv	crypto/decrypt_chm.hpp	/^    PacketIDReceive pid_recv;$/;"	m	class:openvpn::DecryptCHM
pid_send	crypto/crypto_aead.hpp	/^	PacketIDSend pid_send;$/;"	m	struct:openvpn::AEAD::Crypto::Encrypt
pid_send	crypto/encrypt_chm.hpp	/^    PacketIDSend pid_send;$/;"	m	class:openvpn::EncryptCHM
pkey	openssl/ssl/sslctx.hpp	/^      OpenSSLPKI::PKey pkey;            \/\/ private key$/;"	m	class:openvpn::OpenSSLContext::Config
pkey_	openssl/pki/pkey.hpp	/^      EVP_PKEY *pkey_;$/;"	m	class:openvpn::OpenSSLPKI::PKey
pktstream	transport/tcplink.hpp	/^      PacketStream pktstream;$/;"	m	class:openvpn::TCPTransport::Link
platform_name	common/platform_name.hpp	/^  inline const char *platform_name()$/;"	f	namespace:openvpn
platform_string	common/platform_string.hpp	/^  inline std::string platform_string()$/;"	f	namespace:openvpn
platform_string	common/platform_string.hpp	/^  inline std::string platform_string(const std::string& title, const std::string& app_version)$/;"	f	namespace:openvpn
plist	applecrypto/cf/cf.hpp	/^    inline Data plist(CFTypeRef obj)$/;"	f	namespace:openvpn::CF
polarssl_ctx_private	polarssl/ssl/sslctx.hpp	/^  namespace polarssl_ctx_private {$/;"	n	namespace:openvpn
polarssl_errtext	polarssl/util/error.hpp	/^    static std::string polarssl_errtext(int errnum)$/;"	f	class:openvpn::PolarSSLException
pool	server/vpnservpool.hpp	/^      Pool* pool;$/;"	m	class:openvpn::VPNServerPool::IP46AutoRelease
pool4	server/vpnservpool.hpp	/^      IP::Pool pool4;$/;"	m	class:openvpn::VPNServerPool::Pool
pool6	server/vpnservpool.hpp	/^      IP::Pool pool6;$/;"	m	class:openvpn::VPNServerPool::Pool
pop	buffer/memq.hpp	/^    void pop()$/;"	f	class:openvpn::MemQBase
pop_back	buffer/buffer.hpp	/^    T pop_back()$/;"	f	class:openvpn::BufferType
pop_front	buffer/buffer.hpp	/^    T pop_front()$/;"	f	class:openvpn::BufferType
pop_front	reliable/relack.hpp	/^    void pop_front()           { data.pop_front(); }$/;"	f	class:openvpn::ReliableAck
port	client/cliopthelper.hpp	/^      std::string port;$/;"	m	struct:openvpn::ParseClientConfig::RemoteItem
port	client/remotelist.hpp	/^      std::string port;$/;"	m	struct:openvpn::RemoteList::Directives
port	common/hostlist.hpp	/^      std::string port;$/;"	m	struct:openvpn::HostList::Host
port	http/urlparse.hpp	/^      std::string port;$/;"	m	class:openvpn::URL::Parse
port	server/listenlist.hpp	/^      std::string port;$/;"	m	struct:openvpn::Listen::Item
port	server/peeraddr.hpp	/^    std::uint16_t port;$/;"	m	struct:openvpn::AddrPort
port	tun/builder/capture.hpp	/^      int port = 0;$/;"	m	class:openvpn::TunBuilderCapture::ProxyHostPort
port_for_scheme	http/urlparse.hpp	/^      std::string port_for_scheme() const$/;"	f	class:openvpn::URL::Parse
port_implied	http/urlparse.hpp	/^      bool port_implied() const$/;"	f	class:openvpn::URL::Parse
port_offset	server/listenlist.hpp	/^      Item port_offset(const unsigned int offset) const$/;"	f	struct:openvpn::Listen::Item
post_	time/coarsetime.hpp	/^    Time::Duration post_;$/;"	m	class:openvpn::CoarseTime
post_ack_action	ssl/proto.hpp	/^      void post_ack_action()$/;"	f	class:openvpn::ProtoContext::KeyContext
post_close	common/scoped_fd.hpp	/^    virtual void post_close(const int close_status)$/;"	f	class:openvpn::ScopedFD
post_info	server/servproto.hpp	/^      virtual void post_info(BufferPtr&& info)$/;"	f	class:openvpn::ServerProto::Session
post_method	common/asiostop.hpp	/^    static std::function<void()> post_method(asio::io_context& io_context, std::function<void()>&& method)$/;"	f	class:openvpn::AsioStopScope
pre_	time/coarsetime.hpp	/^    Time::Duration pre_;$/;"	m	class:openvpn::CoarseTime
pre_destroy	ssl/proto.hpp	/^    void pre_destroy()$/;"	f	class:openvpn::ProtoContext
pre_master	ssl/tlsprf.hpp	/^    unsigned char pre_master[48]; \/\/ client generated$/;"	m	class:openvpn::TLSPRF
pre_resolve	client/cliconnect.hpp	/^    RemoteList::PreResolve::Ptr pre_resolve;$/;"	m	class:openvpn::ClientConnect
pre_resolve_done	client/cliconnect.hpp	/^    virtual void pre_resolve_done()$/;"	f	class:openvpn::ClientConnect
pre_window	common/msgwin.hpp	/^    bool pre_window(const id_t id) const$/;"	f	class:openvpn::MessageWindow
prec	time/time.hpp	/^    enum { prec=1024 };$/;"	e	enum:openvpn::TimeType::__anon85
prefix	common/runcontext.hpp	/^    std::string prefix;$/;"	m	class:openvpn::RunContext
prefix_len	addr/ip.hpp	/^      unsigned int prefix_len() const$/;"	f	class:openvpn::IP::Addr
prefix_len	addr/ipv4.hpp	/^      unsigned int prefix_len() const$/;"	f	class:openvpn::IPv4::Addr
prefix_len	addr/ipv6.hpp	/^      unsigned int prefix_len() const$/;"	f	class:openvpn::IPv6::Addr
prefix_len	addr/route.hpp	/^      unsigned int prefix_len;$/;"	m	struct:openvpn::IP::RouteType
prefix_len	server/vpnservnetblock.hpp	/^      unsigned int prefix_len;$/;"	m	struct:openvpn::VPNServerNetblock::Netblock
prefix_len_32	addr/ipv4.hpp	/^      static int prefix_len_32(const std::uint32_t addr)$/;"	f	class:openvpn::IPv4::Addr
prefix_len_nothrow	addr/ipv4.hpp	/^      int prefix_len_nothrow() const$/;"	f	class:openvpn::IPv4::Addr
prefix_len_to_netmask	addr/ipv4.hpp	/^      static base_type prefix_len_to_netmask(const unsigned int prefix_len)$/;"	f	class:openvpn::IPv4::Addr
prefix_len_to_netmask	addr/ipv6.hpp	/^      void prefix_len_to_netmask(const unsigned int prefix_len)$/;"	f	class:openvpn::IPv6::Addr
prefix_len_to_netmask_unchecked	addr/ipv4.hpp	/^      static base_type prefix_len_to_netmask_unchecked(const unsigned int prefix_len)$/;"	f	class:openvpn::IPv4::Addr
prefix_len_to_netmask_unchecked	addr/ipv6.hpp	/^      void prefix_len_to_netmask_unchecked(const unsigned int prefix_len)$/;"	f	class:openvpn::IPv6::Addr
prefix_length	tun/builder/capture.hpp	/^      int prefix_length = 0;$/;"	m	class:openvpn::TunBuilderCapture::RouteBase
prepare	frame/frame.hpp	/^      size_t prepare(Buffer& buf) const$/;"	f	class:openvpn::Frame::Context
prepare	frame/frame.hpp	/^    BufferPtr prepare(const unsigned int context) const$/;"	f	class:openvpn::Frame
prepare	frame/frame.hpp	/^    size_t prepare(const unsigned int context, Buffer& buf) const$/;"	f	class:openvpn::Frame
prepare_expire	ssl/proto.hpp	/^      void prepare_expire(const EventType current_ev = KeyContext::KEV_NONE)$/;"	f	class:openvpn::ProtoContext::KeyContext
prepend	buffer/buffer.hpp	/^    void prepend(const T* data, const size_t size)$/;"	f	class:openvpn::BufferType
prepend	reliable/relack.hpp	/^    void prepend(Buffer& buf)$/;"	f	class:openvpn::ReliableAck
prepend	ssl/psid.hpp	/^    void prepend(Buffer& buf) const$/;"	f	class:openvpn::ProtoSessionID
prepend_ad	crypto/crypto_aead.hpp	/^	void prepend_ad(Buffer& buf) const$/;"	f	class:openvpn::AEAD::Crypto::Nonce
prepend_alloc	buffer/buffer.hpp	/^    T* prepend_alloc(const size_t size)$/;"	f	class:openvpn::BufferType
prepend_dest_psid_and_acks	ssl/proto.hpp	/^      void prepend_dest_psid_and_acks(Buffer& buf)$/;"	f	class:openvpn::ProtoContext::KeyContext
prepend_hmac	crypto/encrypt_chm.hpp	/^    void prepend_hmac(BufferAllocated& buf)$/;"	f	class:openvpn::EncryptCHM
prepend_id	reliable/relack.hpp	/^    static void prepend_id(Buffer& buf, const id_t id)$/;"	f	class:openvpn::ReliableAck
prepend_pf_inet	tun/tunio.hpp	/^    void prepend_pf_inet(Buffer& buf, const std::uint32_t value)$/;"	f	class:openvpn::TunIO
prepend_size	transport/pktstream.hpp	/^    static void prepend_size(Buffer& buf)$/;"	f	class:openvpn::PacketStream
preprocess	common/options.hpp	/^      void preprocess()$/;"	f	struct:openvpn::OptionList::KeyValueList
prev	tun/mac/macdns.hpp	/^    Info::Ptr prev;$/;"	m	class:openvpn::MacDNS
prev_state	apple/maclife.hpp	/^    State prev_state;$/;"	m	class:openvpn::MacLifeCycle
preval	server/servproto.hpp	/^      Base::TLSAuthPreValidate::Ptr preval;$/;"	m	class:openvpn::ServerProto::Factory
primary	client/remotelist.hpp	/^      size_t primary() const { return primary_; }$/;"	f	class:openvpn::RemoteList::Index
primary	ssl/proto.hpp	/^    KeyContext::Ptr primary;$/;"	m	class:openvpn::ProtoContext
primary_	client/remotelist.hpp	/^      size_t primary_;$/;"	m	class:openvpn::RemoteList::Index
primary_dns	tun/mac/macdns.hpp	/^      static std::string primary_dns(const CF::Dict& ipv4, const CF::Dict& info)$/;"	f	class:openvpn::MacDNS::Info
primary_index	client/remotelist.hpp	/^    const size_t primary_index() const$/;"	f	class:openvpn::RemoteList
primary_interface	apple/maclife.hpp	/^    std::string primary_interface()$/;"	f	class:openvpn::MacLifeCycle
print	common/format.hpp	/^    inline void print(std::ostream& os, char delim, const T& first)$/;"	f	namespace:openvpn::print_detail
print	common/format.hpp	/^    inline void print(std::ostream& os, char delim, const T& first, Args... args)$/;"	f	namespace:openvpn::print_detail
print	common/format.hpp	/^  inline std::string print(Args... args)$/;"	f	namespace:openvpn
print_detail	common/format.hpp	/^  namespace print_detail {$/;"	n	namespace:openvpn
print_formatted_detail	common/format.hpp	/^  namespace print_formatted_detail {$/;"	n	namespace:openvpn
printable_directive	common/options.hpp	/^    std::string printable_directive() const$/;"	f	class:openvpn::Option
printd	common/format.hpp	/^  inline std::string printd(char delim, Args... args)$/;"	f	namespace:openvpn
printfmt	common/format.hpp	/^  inline std::string printfmt(const std::string& fmt, Args... args)$/;"	f	namespace:openvpn
prints	common/format.hpp	/^  inline std::string prints(Args... args)$/;"	f	namespace:openvpn
priv_key	polarssl/ssl/sslctx.hpp	/^      PolarSSLPKI::PKContext::Ptr priv_key;  \/\/ private key$/;"	m	class:openvpn::PolarSSLContext::Config
priv_key_pwd	openssl/pki/pkey.hpp	/^      std::string priv_key_pwd;$/;"	m	class:openvpn::OpenSSLPKI::PKey
priv_key_pwd	polarssl/ssl/sslctx.hpp	/^      std::string priv_key_pwd;              \/\/ private key password$/;"	m	class:openvpn::PolarSSLContext::Config
privateKeyPasswordRequired	client/cliopthelper.hpp	/^    bool privateKeyPasswordRequired() const { return privateKeyPasswordRequired_; }$/;"	f	class:openvpn::ParseClientConfig
privateKeyPasswordRequired_	client/cliopthelper.hpp	/^    bool privateKeyPasswordRequired_;$/;"	m	class:openvpn::ParseClientConfig
private_key_password	client/cliopt.hpp	/^      std::string private_key_password;$/;"	m	struct:openvpn::ClientOptions::Config
prng	client/cliopt.hpp	/^    RandomAPI::Ptr prng;$/;"	m	class:openvpn::ClientOptions
prng	crypto/crypto_chm.hpp	/^    RandomAPI::Ptr prng;$/;"	m	class:openvpn::CryptoCHM
prng	crypto/crypto_chm.hpp	/^    RandomAPI::Ptr prng;$/;"	m	class:openvpn::CryptoContextCHM
prng	crypto/cryptodcsel.hpp	/^    RandomAPI::Ptr prng;$/;"	m	class:openvpn::CryptoDCSelect
prng	crypto/encrypt_chm.hpp	/^    RandomAPI::Ptr prng;$/;"	m	class:openvpn::EncryptCHM
prng	ssl/proto.hpp	/^      RandomAPI::Ptr prng;$/;"	m	class:openvpn::ProtoContext::Config
process	common/format.hpp	/^    void process()$/;"	f	class:openvpn::PrintFormatted
process	common/format.hpp	/^    void process(const T& first, Args... args)$/;"	f	class:openvpn::PrintFormatted
process	common/format.hpp	/^    void process(const T& last)$/;"	f	class:openvpn::PrintFormatted
process_arg	common/format.hpp	/^    bool process_arg(const T& arg)$/;"	f	class:openvpn::PrintFormatted
process_echo	client/cliproto.hpp	/^      void process_echo(const OptionList& opt)$/;"	f	class:openvpn::ClientProto::Session
process_events	ssl/proto.hpp	/^    bool process_events()$/;"	f	class:openvpn::ProtoContext
process_exception	client/cliproto.hpp	/^      void process_exception(const std::exception& e, const char *method_name)$/;"	f	class:openvpn::ClientProto::Session
process_finish	common/format.hpp	/^    void process_finish()$/;"	f	class:openvpn::PrintFormatted
process_halt_restart	client/cliproto.hpp	/^      void process_halt_restart(const ClientHalt& ch)$/;"	f	class:openvpn::ClientProto::Session
process_inactive	client/cliproto.hpp	/^      void process_inactive(const OptionList& opt)$/;"	f	class:openvpn::ClientProto::Session
process_next_event	ssl/proto.hpp	/^      void process_next_event()$/;"	f	class:openvpn::ProtoContext::KeyContext
process_primary_event	ssl/proto.hpp	/^    void process_primary_event()$/;"	f	class:openvpn::ProtoContext
process_push	ssl/proto.hpp	/^      void process_push(const OptionList& opt, const ProtoContextOptions& pco)$/;"	f	class:openvpn::ProtoContext::Config
process_push	ssl/proto.hpp	/^    void process_push(const OptionList& opt, const ProtoContextOptions& pco)$/;"	f	class:openvpn::ProtoContext
process_secondary_event	ssl/proto.hpp	/^    void process_secondary_event()$/;"	f	class:openvpn::ProtoContext
process_setenv_opt	client/cliopthelper.hpp	/^    static void process_setenv_opt(OptionList& options)$/;"	f	class:openvpn::ParseClientConfig
profileName	client/cliopthelper.hpp	/^    const std::string& profileName() const { return profileName_; }$/;"	f	class:openvpn::ParseClientConfig
profileName_	client/cliopthelper.hpp	/^    std::string profileName_;$/;"	m	class:openvpn::ParseClientConfig
profile_content	options/merge.hpp	/^    const std::string& profile_content() const { return profile_content_; }$/;"	f	class:openvpn::ProfileMerge
profile_content_	options/merge.hpp	/^    std::string profile_content_;$/;"	m	class:openvpn::ProfileMerge
promote_secondary_to_primary	ssl/proto.hpp	/^    void promote_secondary_to_primary()$/;"	f	class:openvpn::ProtoContext
props	tun/client/dhcp_capture.hpp	/^    TunBuilderCapture::Ptr props;$/;"	m	class:openvpn::DHCPCapture
props_ready	tun/win/client/tunsetup.hpp	/^	Time props_ready;$/;"	m	struct:openvpn::TunWin::Setup::L2State
proto	client/cliopthelper.hpp	/^      std::string proto;$/;"	m	struct:openvpn::ParseClientConfig::RemoteItem
proto	client/remotelist.hpp	/^      std::string proto;$/;"	m	struct:openvpn::RemoteList::Directives
proto	server/listenlist.hpp	/^      Protocol proto;$/;"	m	struct:openvpn::Listen::Item
proto	ssl/proto.hpp	/^      ProtoContext& proto; \/\/ parent$/;"	m	class:openvpn::ProtoContext::KeyContext
proto_context_config	client/cliproto.hpp	/^	ProtoConfig::Ptr proto_context_config;$/;"	m	struct:openvpn::ClientProto::Session::Config
proto_context_config	server/servproto.hpp	/^      ProtoConfig::Ptr proto_context_config;$/;"	m	class:openvpn::ServerProto::Factory
proto_context_options	client/cliopt.hpp	/^      ProtoContextOptions::Ptr proto_context_options;$/;"	m	struct:openvpn::ClientOptions::Config
proto_context_options	client/cliopt.hpp	/^    ProtoContextOptions::Ptr proto_context_options;$/;"	m	class:openvpn::ClientOptions
proto_context_options	client/cliproto.hpp	/^	ProtoContextOptions::Ptr proto_context_options;$/;"	m	struct:openvpn::ClientProto::Session::Config
proto_context_options	client/cliproto.hpp	/^      ProtoContextOptions::Ptr proto_context_options;$/;"	m	class:openvpn::ClientProto::Session
proto_context_private	ssl/proto.hpp	/^  namespace proto_context_private {$/;"	n	namespace:openvpn
proto_override	client/cliopt.hpp	/^      Protocol proto_override;$/;"	m	struct:openvpn::ClientOptions::Config
proto_override	client/cliopt.hpp	/^    Protocol proto_override;$/;"	m	class:openvpn::ClientOptions
protocol	ip/ip.hpp	/^    std::uint8_t    protocol;$/;"	m	struct:openvpn::IPHeader
protocol	ssl/proto.hpp	/^      Protocol protocol; \/\/ set with set_protocol()$/;"	m	class:openvpn::ProtoContext::Config
protocol	transport/dco.hpp	/^      Protocol protocol;$/;"	m	struct:openvpn::DCO::TransportConfig
protocol	transport/tcplink.hpp	/^      typedef Protocol protocol;$/;"	t	class:openvpn::TCPTransport::Link
proxy_auto_config_url	tun/builder/capture.hpp	/^    ProxyAutoConfigURL proxy_auto_config_url;$/;"	m	class:openvpn::TunBuilderCapture
proxy_bypass	tun/builder/capture.hpp	/^    std::vector<ProxyBypass> proxy_bypass; \/\/ hosts that should bypass proxy$/;"	m	class:openvpn::TunBuilderCapture
proxy_connected	transport/client/httpcli.hpp	/^      void proxy_connected(BufferAllocated& buf, const bool notify_parent)$/;"	f	class:openvpn::HTTPProxyTransport::Client
proxy_eof_handler	transport/client/httpcli.hpp	/^      void proxy_eof_handler()$/;"	f	class:openvpn::HTTPProxyTransport::Client
proxy_error	client/cliproto.hpp	/^      virtual void proxy_error(const Error::Type fatal_err, const std::string& err_text)$/;"	f	class:openvpn::ClientProto::Session
proxy_error	transport/client/httpcli.hpp	/^      void proxy_error(const Error::Type fatal_err, const std::string& what)$/;"	f	class:openvpn::HTTPProxyTransport::Client
proxy_established	transport/client/httpcli.hpp	/^      bool proxy_established;$/;"	m	class:openvpn::HTTPProxyTransport::Client
proxy_half_connected	transport/client/httpcli.hpp	/^      void proxy_half_connected()$/;"	f	class:openvpn::HTTPProxyTransport::Client
proxy_host	transport/client/httpcli.hpp	/^      std::string proxy_host;$/;"	m	class:openvpn::HTTPProxyTransport::Client
proxy_port	transport/client/httpcli.hpp	/^      std::string proxy_port;$/;"	m	class:openvpn::HTTPProxyTransport::Client
proxy_read_handler	transport/client/httpcli.hpp	/^      void proxy_read_handler(BufferAllocated& buf)$/;"	f	class:openvpn::HTTPProxyTransport::Client
proxy_remote_list	transport/client/httpcli.hpp	/^      RemoteList& proxy_remote_list() const { return *config->http_proxy_options->proxy_server; }$/;"	f	class:openvpn::HTTPProxyTransport::Client
proxy_response_limit	transport/client/httpcli.hpp	/^      ProxyResponseLimit proxy_response_limit;$/;"	m	class:openvpn::HTTPProxyTransport::Client
proxy_server	transport/client/httpcli.hpp	/^      RemoteList::Ptr proxy_server;$/;"	m	class:openvpn::HTTPProxyTransport::Options
proxy_server_precache	transport/client/httpcli.hpp	/^      void proxy_server_precache(RemoteList::Ptr& r)$/;"	f	class:openvpn::HTTPProxyTransport::Options
proxy_server_set_enable_cache	transport/client/httpcli.hpp	/^      void proxy_server_set_enable_cache(const bool enable_cache)$/;"	f	class:openvpn::HTTPProxyTransport::Options
prune	common/stop.hpp	/^    void prune()$/;"	f	class:openvpn::Stop
prune_uncached	client/remotelist.hpp	/^    void prune_uncached()$/;"	f	class:openvpn::RemoteList
psid	client/clihalt.hpp	/^    bool psid() const { return psid_; }$/;"	f	class:openvpn::ClientHalt
psid_	client/clihalt.hpp	/^    bool psid_ = false;$/;"	m	class:openvpn::ClientHalt
psid_peer	ssl/proto.hpp	/^    ProtoSessionID psid_peer;$/;"	m	class:openvpn::ProtoContext
psid_self	ssl/proto.hpp	/^    ProtoSessionID psid_self;$/;"	m	class:openvpn::ProtoContext
ptr	common/rc.hpp	/^      ListHead() noexcept : ptr(nullptr) {}$/;"	f	class:openvpn::thread_safe_refcount::ListHead
ptr	common/rc.hpp	/^      ListHead() noexcept : ptr(nullptr) {}$/;"	f	class:openvpn::thread_unsafe_refcount::ListHead
ptr	common/rc.hpp	/^      T* ptr;$/;"	m	class:openvpn::thread_unsafe_refcount::ListHead
ptr	common/rc.hpp	/^      std::atomic<T*> ptr;$/;"	m	class:openvpn::thread_safe_refcount::ListHead
ptr_aligned_4	compress/lzoasym_impl.hpp	/^    inline bool ptr_aligned_4(const T* a, const T* b)$/;"	f	namespace:openvpn::lzo_asym_impl
ptr_diff	compress/lzoasym_impl.hpp	/^    inline size_t ptr_diff(const T* a, const T* b)$/;"	f	namespace:openvpn::lzo_asym_impl
pull_front	addr/range.hpp	/^      RangeType pull_front(size_t extent)$/;"	f	class:openvpn::IP::RangeType
purge	common/msgwin.hpp	/^    void purge()$/;"	f	class:openvpn::MessageWindow
push	common/circ_list.hpp	/^    void push(const T& item)$/;"	f	class:openvpn::CircList
pushPeerInfo	client/cliopthelper.hpp	/^    bool pushPeerInfo() const { return pushPeerInfo_; }$/;"	f	class:openvpn::ParseClientConfig
pushPeerInfo_	client/cliopthelper.hpp	/^    bool pushPeerInfo_;$/;"	m	class:openvpn::ParseClientConfig
push_back	addr/addrpair.hpp	/^	void push_back(const std::string& s)$/;"	f	class:openvpn::IP::AddrMaskPair::StringPair
push_back	buffer/buffer.hpp	/^    void push_back(const T& value)$/;"	f	class:openvpn::BufferType
push_back	common/options.hpp	/^    void push_back(const std::string& item) { data.push_back(item); }$/;"	f	class:openvpn::Option
push_back	common/options.hpp	/^    void push_back(std::string&& item) { data.push_back(std::move(item)); }$/;"	f	class:openvpn::Option
push_back	reliable/relack.hpp	/^    void push_back(id_t value) { data.push_back(value); }$/;"	f	class:openvpn::ReliableAck
push_base	client/cliopt.hpp	/^    PushOptionsBase::Ptr push_base;$/;"	m	class:openvpn::ClientOptions
push_base	client/cliproto.hpp	/^	PushOptionsBase::Ptr push_base;$/;"	m	struct:openvpn::ClientProto::Session::Config
push_base	options/continuation.hpp	/^    PushOptionsBase::Ptr push_base;$/;"	m	class:openvpn::OptionListContinuation
push_front	buffer/buffer.hpp	/^    void push_front(const T& value)$/;"	f	class:openvpn::BufferType
push_halt_restart_msg	server/servproto.hpp	/^      virtual void push_halt_restart_msg(const HaltRestart::Type type,$/;"	f	class:openvpn::ServerProto::Session
push_reply	server/servproto.hpp	/^      virtual void push_reply(std::vector<BufferPtr>&& push_msgs,$/;"	f	class:openvpn::ServerProto::Session
push_request_timer	client/cliproto.hpp	/^      AsioTimer push_request_timer;$/;"	m	class:openvpn::ClientProto::Session
push_timer	tun/mac/macdns_watchdog.hpp	/^    CF::Timer push_timer;          \/\/ watcher thread timer$/;"	m	class:openvpn::MacDNSWatchdog
push_timer_callback	tun/mac/macdns_watchdog.hpp	/^    void push_timer_callback(CFRunLoopTimerRef timer)$/;"	f	class:openvpn::MacDNSWatchdog
push_timer_callback_static	tun/mac/macdns_watchdog.hpp	/^    static void push_timer_callback_static(CFRunLoopTimerRef timer, void *info)$/;"	f	class:openvpn::MacDNSWatchdog
push_timer_lock	tun/mac/macdns_watchdog.hpp	/^    std::mutex push_timer_lock;$/;"	m	class:openvpn::MacDNSWatchdog
push_to_store	tun/mac/macdns.hpp	/^      bool push_to_store()$/;"	f	class:openvpn::MacDNS::DSDict
pushed_options_filter	client/cliopt.hpp	/^    OptionList::FilterBase::Ptr pushed_options_filter;$/;"	m	class:openvpn::ClientOptions
pushed_options_filter	client/cliproto.hpp	/^	OptionList::FilterBase::Ptr pushed_options_filter;$/;"	m	struct:openvpn::ClientProto::Session::Config
pushed_options_filter	client/cliproto.hpp	/^      OptionList::FilterBase::Ptr pushed_options_filter;$/;"	m	class:openvpn::ClientProto::Session
pushed_options_limit	client/cliproto.hpp	/^	OptionList::Limits pushed_options_limit;$/;"	m	struct:openvpn::ClientProto::Session::Config
pushed_options_limit	client/cliproto.hpp	/^      OptionList::Limits pushed_options_limit;$/;"	m	class:openvpn::ClientProto::Session
put	buffer/bufcomposed.hpp	/^    void put(BufferPtr bp)$/;"	f	class:openvpn::BufferComposed
put	common/lex.hpp	/^    void put(char c) { ch = c; }$/;"	f	class:openvpn::NullLex
put	common/lex.hpp	/^    void put(char c)$/;"	f	class:openvpn::StandardLex
put	common/options.hpp	/^      void put(char c)$/;"	f	class:openvpn::OptionList::LexComment
put	transport/pktstream.hpp	/^    void put(BufferAllocated& buf, const Frame::Context& frame_context)$/;"	f	class:openvpn::PacketStream
put_consume	buffer/buflist.hpp	/^    void put_consume(BufferAllocated& buf, const size_t tailroom = 0)$/;"	f	struct:openvpn::BufferCollection
put_pktstream	transport/tcplink.hpp	/^      bool put_pktstream(BufferAllocated& buf, BufferAllocated& pkt)$/;"	f	class:openvpn::TCPTransport::Link
pw	common/usergroup.hpp	/^    struct passwd *pw;$/;"	m	class:openvpn::SetUserGroup	typeref:struct:openvpn::SetUserGroup::passwd
px	common/rc.hpp	/^      : px(nullptr)$/;"	f	class:openvpn::RCPtr
px	common/rc.hpp	/^      : px(p)$/;"	f	class:openvpn::RCPtr
px	common/rc.hpp	/^      : px(rhs.get())$/;"	f	class:openvpn::RCPtr
px	common/rc.hpp	/^      : px(rhs.px)$/;"	f	class:openvpn::RCPtr
px	common/rc.hpp	/^    T* px;$/;"	m	class:openvpn::RCPtr
q	buffer/memq.hpp	/^    q_type q;$/;"	m	class:openvpn::MemQBase
q_	common/msgwin.hpp	/^    std::deque<M> q_;$/;"	m	class:openvpn::MessageWindow
q_type	buffer/memq.hpp	/^    typedef std::deque<BufferPtr> q_type;$/;"	t	class:openvpn::MemQBase
query_mtu_return	openssl/bio/bio_memq_dgram.hpp	/^      long query_mtu_return;$/;"	m	class:openvpn::bmq_dgram::MemQ
queue	transport/gremlin.hpp	/^      void queue(F&& func_arg)$/;"	f	struct:openvpn::Gremlin::DelayedQueue
queue	transport/tcplink.hpp	/^      Queue queue;      \/\/ send queue$/;"	m	class:openvpn::TCPTransport::Link
queue_read	common/redir.hpp	/^      void queue_read()$/;"	f	class:openvpn::RedirectPipe::SD_IN
queue_read	transport/udplink.hpp	/^      void queue_read(PacketFrom *udpfrom)$/;"	f	class:openvpn::UDPTransport::Link
queue_read	tun/tunio.hpp	/^    void queue_read(PacketFrom *tunfrom)$/;"	f	class:openvpn::TunIO
queue_recv	transport/tcplink.hpp	/^      void queue_recv(PacketFrom *tcpfrom)$/;"	f	class:openvpn::TCPTransport::Link
queue_restart	client/cliconnect.hpp	/^    void queue_restart(const unsigned int delay = 2)$/;"	f	class:openvpn::ClientConnect
queue_send	transport/tcplink.hpp	/^      void queue_send()$/;"	f	class:openvpn::TCPTransport::Link
queue_send_buffer	transport/tcplink.hpp	/^      void queue_send_buffer(BufferPtr& buf)$/;"	f	class:openvpn::TCPTransport::Link
queue_write	common/redir.hpp	/^      void queue_write()$/;"	f	class:openvpn::RedirectPipe::SD_OUT
quote_delim	common/format.hpp	/^    static int quote_delim(const char fmt)$/;"	f	class:openvpn::PrintFormatted
rand	random/mtrandapi.hpp	/^    rand_type::result_type rand()$/;"	f	class:openvpn::MTRand
rand_bytes	applecrypto/util/rand.hpp	/^    virtual void rand_bytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::AppleRandom
rand_bytes	openssl/util/rand.hpp	/^    virtual void rand_bytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::OpenSSLRandom
rand_bytes	polarssl/util/rand.hpp	/^    virtual void rand_bytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::PolarSSLRandom
rand_bytes	random/devurand.hpp	/^    virtual void rand_bytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::DevURand
rand_bytes	random/mtrandapi.hpp	/^    virtual void rand_bytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::MTRand
rand_bytes_noexcept	applecrypto/util/rand.hpp	/^    virtual bool rand_bytes_noexcept(unsigned char *buf, size_t size)$/;"	f	class:openvpn::AppleRandom
rand_bytes_noexcept	openssl/util/rand.hpp	/^    virtual bool rand_bytes_noexcept(unsigned char *buf, size_t size)$/;"	f	class:openvpn::OpenSSLRandom
rand_bytes_noexcept	polarssl/util/rand.hpp	/^    virtual bool rand_bytes_noexcept(unsigned char *buf, size_t size)$/;"	f	class:openvpn::PolarSSLRandom
rand_bytes_noexcept	random/devurand.hpp	/^    virtual bool rand_bytes_noexcept(unsigned char *buf, size_t size)$/;"	f	class:openvpn::DevURand
rand_bytes_noexcept	random/mtrandapi.hpp	/^    virtual bool rand_bytes_noexcept(unsigned char *buf, size_t size)$/;"	f	class:openvpn::MTRand
rand_fill	random/randapi.hpp	/^    void rand_fill(T& obj)$/;"	f	class:openvpn::RandomAPI
rand_get	random/randapi.hpp	/^    T rand_get()$/;"	f	class:openvpn::RandomAPI
rand_get_positive	random/randapi.hpp	/^    T rand_get_positive()$/;"	f	class:openvpn::RandomAPI
rand_type	random/mtrandapi.hpp	/^    typedef std::mt19937_64 rand_type;$/;"	t	class:openvpn::MTRand
random1	ssl/tlsprf.hpp	/^    unsigned char random1[32];    \/\/ generated by both client and server$/;"	m	class:openvpn::TLSPRF
random2	ssl/tlsprf.hpp	/^    unsigned char random2[32];    \/\/ generated by both client and server$/;"	m	class:openvpn::TLSPRF
randomize	client/remotelist.hpp	/^    void randomize()$/;"	f	class:openvpn::RemoteList
randomize	common/hostlist.hpp	/^      void randomize(RandomAPI& rng)$/;"	f	class:openvpn::HostList::List
randomize	ssl/psid.hpp	/^    void randomize(PRNG_TYPE& prng)$/;"	f	class:openvpn::ProtoSessionID
randomize	ssl/tlsprf.hpp	/^    void randomize(RandomAPI& rng)$/;"	f	class:openvpn::TLSPRF
randrange	random/randapi.hpp	/^    T randrange(const T end)$/;"	f	class:openvpn::RandomAPI
randrange	random/randapi.hpp	/^    T randrange(const T start, const T end)$/;"	f	class:openvpn::RandomAPI
range	addr/range.hpp	/^      RangeType<ADDR> range;$/;"	m	class:openvpn::IP::RangePartitionType
range	buffer/buffer.hpp	/^    BufferType range(size_t offset, size_t len) const$/;"	f	class:openvpn::BufferType
range4	server/vpnservnetblock.hpp	/^      const IP::Range& range4() const { return range4_; }$/;"	f	class:openvpn::VPNServerNetblock::PerThread
range4_	server/vpnservnetblock.hpp	/^      IP::Range range4_;$/;"	m	class:openvpn::VPNServerNetblock::PerThread
range6	server/vpnservnetblock.hpp	/^      const IP::Range& range6() const { return range6_; }$/;"	f	class:openvpn::VPNServerNetblock::PerThread
range6_	server/vpnservnetblock.hpp	/^      IP::Range range6_;$/;"	m	class:openvpn::VPNServerNetblock::PerThread
range6_defined	server/vpnservnetblock.hpp	/^      bool range6_defined() const { return range6_.defined(); }$/;"	f	class:openvpn::VPNServerNetblock::PerThread
raw	time/time.hpp	/^      T raw() const { return duration_; }$/;"	f	class:openvpn::TimeType::Duration
raw	time/time.hpp	/^    T raw() const { return time_; }$/;"	f	class:openvpn::TimeType
raw_alloc	crypto/static_key.hpp	/^    unsigned char *raw_alloc()$/;"	f	class:openvpn::OpenVPNStaticKey
raw_mode_read	transport/tcplink.hpp	/^      bool raw_mode_read;$/;"	m	class:openvpn::TCPTransport::Link
raw_mode_write	transport/tcplink.hpp	/^      bool raw_mode_write;$/;"	m	class:openvpn::TCPTransport::Link
raw_recv	ssl/proto.hpp	/^      void raw_recv(Packet&& raw_pkt)  \/\/ called by ProtoStackBase$/;"	f	class:openvpn::ProtoContext::KeyContext
raw_send	ssl/protostack.hpp	/^    void raw_send(PACKET&& pkt)$/;"	f	class:openvpn::ProtoStackBase
raw_write_queue	ssl/protostack.hpp	/^    std::deque<PACKET> raw_write_queue;$/;"	m	class:openvpn::ProtoStackBase
rbs	random/mtrandapi.hpp	/^    RandomByteStore<rand_type> rbs;$/;"	m	class:openvpn::MTRand
rc	common/rc.hpp	/^      RCImpl rc;             \/\/ refcount$/;"	m	class:openvpn::RCWeak
rc	common/rc.hpp	/^    olong rc;$/;"	m	class:openvpn::thread_unsafe_refcount
rc	common/rc.hpp	/^    std::atomic<olong> rc;$/;"	m	class:openvpn::thread_safe_refcount
reach	applecrypto/util/reachable.hpp	/^    CF::NetworkReachability reach;$/;"	m	class:openvpn::ReachabilityBase
reachability	applecrypto/util/reachable.hpp	/^    Reachability reachability;$/;"	m	class:openvpn::ReachabilityTracker
reachability_tracker_cancel	applecrypto/util/reachable.hpp	/^    void reachability_tracker_cancel()$/;"	f	class:openvpn::ReachabilityTracker
reachability_tracker_event	apple/maclife.hpp	/^    virtual void reachability_tracker_event(const ReachabilityBase& rb, SCNetworkReachabilityFlags flags)$/;"	f	class:openvpn::MacLifeCycle
reachability_tracker_schedule	applecrypto/util/reachable.hpp	/^    void reachability_tracker_schedule()$/;"	f	class:openvpn::ReachabilityTracker
reachable	applecrypto/util/iosactiveiface.hpp	/^    virtual Status reachable() const$/;"	f	class:openvpn::iOSActiveInterface
reachable	applecrypto/util/reachable.hpp	/^    virtual Status reachable() const$/;"	f	class:openvpn::Reachability
reachableVia	applecrypto/util/iosactiveiface.hpp	/^    virtual bool reachableVia(const std::string& net_type) const$/;"	f	class:openvpn::iOSActiveInterface
reachableVia	applecrypto/util/reachable.hpp	/^    virtual bool reachableVia(const std::string& net_type) const$/;"	f	class:openvpn::Reachability
reachableViaCellular	applecrypto/util/reachable.hpp	/^    bool reachableViaCellular() const$/;"	f	class:openvpn::Reachability
reachableViaWiFi	applecrypto/util/reachable.hpp	/^    bool reachableViaWiFi() const {$/;"	f	class:openvpn::Reachability
reached_active	ssl/proto.hpp	/^      Time reached_active() const { return reached_active_time_; }$/;"	f	class:openvpn::ProtoContext::KeyContext
reached_active_time_	ssl/proto.hpp	/^      Time reached_active_time_;$/;"	m	class:openvpn::ProtoContext::KeyContext
reached_connected_state	client/cliproto.hpp	/^      bool reached_connected_state() const { return bool(connected_); }$/;"	f	class:openvpn::ClientProto::Session
read	buffer/buffer.hpp	/^    void read(T* data, const size_t size)$/;"	f	class:openvpn::BufferType
read	crypto/packet_id.hpp	/^    void read(Buffer& buf, const int form)$/;"	f	struct:openvpn::PacketID
read	frame/memq_dgram.hpp	/^    size_t read(unsigned char *data, size_t len)$/;"	f	class:openvpn::MemQDgram
read	frame/memq_stream.hpp	/^    size_t read(unsigned char *data, size_t len)$/;"	f	class:openvpn::MemQStream
read	reliable/relack.hpp	/^    void read(Buffer& buf)$/;"	f	class:openvpn::ReliableAck
read	ssl/psid.hpp	/^    void read(Buffer& buf)$/;"	f	class:openvpn::ProtoSessionID
read	ssl/tlsprf.hpp	/^    void read(Buffer& buf)$/;"	f	class:openvpn::TLSPRF
read_alloc	buffer/buffer.hpp	/^    T* read_alloc(const size_t size)$/;"	f	class:openvpn::BufferType
read_auth_string	ssl/proto.hpp	/^    static S read_auth_string(Buffer& buf)$/;"	f	class:openvpn::ProtoContext
read_binary	common/file.hpp	/^  inline BufferPtr read_binary(const std::string& filename,$/;"	f	namespace:openvpn
read_binary_linear	common/file.hpp	/^  inline BufferPtr read_binary_linear(const std::string& filename,$/;"	f	namespace:openvpn
read_buf	buffer/memq.hpp	/^    BufferPtr read_buf()$/;"	f	class:openvpn::MemQBase
read_ciphertext	applecrypto/ssl/sslctx.hpp	/^      virtual BufferPtr read_ciphertext()$/;"	f	class:openvpn::AppleSSLContext::SSL
read_ciphertext	openssl/ssl/sslctx.hpp	/^      virtual BufferPtr read_ciphertext()$/;"	f	class:openvpn::OpenSSLContext::SSL
read_ciphertext	polarssl/ssl/sslctx.hpp	/^      virtual BufferPtr read_ciphertext()$/;"	f	class:openvpn::PolarSSLContext::SSL
read_ciphertext_ready	applecrypto/ssl/sslctx.hpp	/^      virtual bool read_ciphertext_ready() const$/;"	f	class:openvpn::AppleSSLContext::SSL
read_ciphertext_ready	openssl/ssl/sslctx.hpp	/^      virtual bool read_ciphertext_ready() const$/;"	f	class:openvpn::OpenSSLContext::SSL
read_ciphertext_ready	polarssl/ssl/sslctx.hpp	/^      virtual bool read_ciphertext_ready() const$/;"	f	class:openvpn::PolarSSLContext::SSL
read_cleartext	applecrypto/ssl/sslctx.hpp	/^      virtual ssize_t read_cleartext(void *data, const size_t capacity)$/;"	f	class:openvpn::AppleSSLContext::SSL
read_cleartext	openssl/ssl/sslctx.hpp	/^      virtual ssize_t read_cleartext(void *data, const size_t capacity)$/;"	f	class:openvpn::OpenSSLContext::SSL
read_cleartext	polarssl/ssl/sslctx.hpp	/^      virtual ssize_t read_cleartext(void *data, const size_t capacity)$/;"	f	class:openvpn::PolarSSLContext::SSL
read_cleartext_ready	applecrypto/ssl/sslctx.hpp	/^      virtual bool read_cleartext_ready() const$/;"	f	class:openvpn::AppleSSLContext::SSL
read_cleartext_ready	openssl/ssl/sslctx.hpp	/^      virtual bool read_cleartext_ready() const$/;"	f	class:openvpn::OpenSSLContext::SSL
read_cleartext_ready	polarssl/ssl/sslctx.hpp	/^      virtual bool read_cleartext_ready() const$/;"	f	class:openvpn::PolarSSLContext::SSL
read_complete	ssl/tlsprf.hpp	/^    bool read_complete(BufferComplete& bc)$/;"	f	class:openvpn::TLSPRF
read_control_string	ssl/proto.hpp	/^    static S read_control_string(const Buffer& buf)$/;"	f	class:openvpn::ProtoContext
read_handler	transport/tcplink.hpp	/^      ReadHandler read_handler;$/;"	m	class:openvpn::TCPTransport::Link
read_handler	transport/udplink.hpp	/^      ReadHandler read_handler;$/;"	m	class:openvpn::UDPTransport::Link
read_handler	tun/tunio.hpp	/^    ReadHandler read_handler;$/;"	m	class:openvpn::TunIO
read_id	reliable/relack.hpp	/^    static id_t read_id(Buffer& buf)$/;"	f	class:openvpn::ReliableAck
read_next	crypto/packet_id.hpp	/^    PacketID read_next(Buffer& buf) const$/;"	f	class:openvpn::PacketIDReceiveType
read_size	transport/pktstream.hpp	/^    static size_t read_size(Buffer& buf)$/;"	f	class:openvpn::PacketStream
read_stdin	common/file.hpp	/^  inline std::string read_stdin()$/;"	f	namespace:openvpn
read_string_length	ssl/proto.hpp	/^    static size_t read_string_length(Buffer& buf)$/;"	f	class:openvpn::ProtoContext
read_text	common/file.hpp	/^  inline std::string read_text(const std::string& filename, const std::uint64_t max_size = 0)$/;"	f	namespace:openvpn
read_text_simple	common/file.hpp	/^  inline std::string read_text_simple(const std::string& filename)$/;"	f	namespace:openvpn
read_text_utf8	common/file.hpp	/^  inline std::string read_text_utf8(const std::string& filename, const std::uint64_t max_size = 0)$/;"	f	namespace:openvpn
ready	reliable/relrecv.hpp	/^    bool ready() const { return window_.head_defined(); }$/;"	f	class:openvpn::ReliableRecvTemplate
ready	reliable/relsend.hpp	/^    bool ready() const { return window_.in_window(next); }$/;"	f	class:openvpn::ReliableSendTemplate
ready	transport/pktstream.hpp	/^    bool ready() const$/;"	f	class:openvpn::PacketStream
ready_retransmit	reliable/relsend.hpp	/^      bool ready_retransmit(const Time& now) const$/;"	f	class:openvpn::ReliableSendTemplate::Message
realign	buffer/buffer.hpp	/^    void realign(size_t headroom)$/;"	f	class:openvpn::BufferType
realign	frame/frame.hpp	/^      void realign(Buffer& buf) const$/;"	f	class:openvpn::Frame::Context
realloc	buffer/buffer.hpp	/^    void realloc(const size_t newcap)$/;"	f	class:openvpn::BufferAllocatedType
realloc_	buffer/buffer.hpp	/^    void realloc_(const size_t newcap)$/;"	f	class:openvpn::BufferAllocatedType
reason	client/clievent.hpp	/^      std::string reason;$/;"	m	struct:openvpn::ClientEvent::ReasonBase
reason	client/clihalt.hpp	/^    const std::string& reason() const { return reason_; }$/;"	f	class:openvpn::ClientHalt
reason_	client/clihalt.hpp	/^    std::string reason_;$/;"	m	class:openvpn::ClientHalt
recalc_derived	frame/frame.hpp	/^      void recalc_derived()$/;"	f	class:openvpn::Frame::Context
receive	reliable/relrecv.hpp	/^    unsigned int receive(const PACKET& packet, const id_t id)$/;"	f	class:openvpn::ReliableRecvTemplate
received_options	client/cliproto.hpp	/^      OptionListContinuation received_options;$/;"	m	class:openvpn::ClientProto::Session
reconnect	client/cliconnect.hpp	/^    void reconnect(int seconds)$/;"	f	class:openvpn::ClientConnect
reconnect_notify	client/cliopt.hpp	/^      ReconnectNotify* reconnect_notify = nullptr;$/;"	m	struct:openvpn::ClientOptions::Config
reconnect_notify	client/cliopt.hpp	/^    ReconnectNotify* reconnect_notify;$/;"	m	class:openvpn::ClientOptions
recv	transport/gremlin.hpp	/^      DelayedQueue::Ptr recv;$/;"	m	class:openvpn::Gremlin::SendRecvQueue
recv_auth	ssl/proto.hpp	/^      void recv_auth(BufferPtr buf)$/;"	f	class:openvpn::ProtoContext::KeyContext
recv_auth_complete	ssl/proto.hpp	/^      bool recv_auth_complete(BufferComplete& bc) const$/;"	f	class:openvpn::ProtoContext::KeyContext
recv_delay_ms	transport/gremlin.hpp	/^      unsigned int recv_delay_ms = 0;$/;"	m	class:openvpn::Gremlin::Config
recv_drop_probability	transport/gremlin.hpp	/^      unsigned int recv_drop_probability = 0;$/;"	m	class:openvpn::Gremlin::Config
recv_queue	transport/gremlin.hpp	/^      void recv_queue(F&& func_arg)$/;"	f	class:openvpn::Gremlin::SendRecvQueue
recv_size	transport/gremlin.hpp	/^      size_t recv_size() const$/;"	f	class:openvpn::Gremlin::SendRecvQueue
red_limit	ssl/datalimit.hpp	/^      const size_type red_limit;$/;"	m	class:openvpn::DataLimit::Component
redirect_dns	tun/mac/macdns.hpp	/^      bool redirect_dns = false;$/;"	m	class:openvpn::MacDNS::Config
redirect_gateway_ipv4_enabled	client/rgopt.hpp	/^    bool redirect_gateway_ipv4_enabled() const$/;"	f	class:openvpn::RedirectGatewayFlags
redirect_gateway_ipv6_enabled	client/rgopt.hpp	/^    bool redirect_gateway_ipv6_enabled() const$/;"	f	class:openvpn::RedirectGatewayFlags
reduce_spaces	common/string.hpp	/^    inline std::string reduce_spaces(const std::string& str, const char rep)$/;"	f	namespace:openvpn::string
ref	common/options.hpp	/^    const std::string& ref(const size_t i) const { return data[i]; }$/;"	f	class:openvpn::Option
ref	common/options.hpp	/^    std::string& ref(const size_t i) { return data[i]; }$/;"	f	class:openvpn::Option
ref	win/reg.hpp	/^      HKEY* ref() { return &key; }$/;"	f	class:openvpn::Win::RegKey
ref	win/scoped_handle.hpp	/^      HANDLE* ref()$/;"	f	class:openvpn::Win::ScopedHANDLE
ref_by_id	common/msgwin.hpp	/^    M& ref_by_id(const id_t id)$/;"	f	class:openvpn::MessageWindow
ref_by_id	reliable/relsend.hpp	/^    Message& ref_by_id(const id_t id)$/;"	f	class:openvpn::ReliableSendTemplate
ref_fail_list_	options/merge.hpp	/^    std::vector<std::string> ref_fail_list_;$/;"	m	class:openvpn::ProfileMerge
ref_head	common/msgwin.hpp	/^    M& ref_head() { return q_.front(); }$/;"	f	class:openvpn::MessageWindow
ref_path_list	options/merge.hpp	/^    const std::vector<std::string>& ref_path_list() const { return ref_succeed_list_; }$/;"	f	class:openvpn::ProfileMerge
ref_succeed_list_	options/merge.hpp	/^    std::vector<std::string> ref_succeed_list_;$/;"	m	class:openvpn::ProfileMerge
refcount_	common/rc.hpp	/^      : refcount_(this)$/;"	f
refcount_	common/rc.hpp	/^    ControllerRef refcount_;$/;"	v
refcount_	common/rc.hpp	/^    RCImpl refcount_;$/;"	m	class:openvpn::RC
refcount_	common/rc.hpp	/^    RCImpl refcount_;$/;"	m	class:openvpn::RCCopyable
register_signals	common/asiosignal.hpp	/^    void register_signals(SignalHandler stop_handler, unsigned int sigmask = (S_SIGINT|S_SIGTERM))$/;"	f	class:openvpn::ASIOSignals
register_signals_all	common/asiosignal.hpp	/^    void register_signals_all(SignalHandler stop_handler)$/;"	f	class:openvpn::ASIOSignals
rekey	crypto/crypto_aead.hpp	/^      virtual void rekey(const typename Base::RekeyType type)$/;"	f	class:openvpn::AEAD::Crypto
rekey	crypto/crypto_chm.hpp	/^    virtual void rekey(const typename Base::RekeyType type)$/;"	f	class:openvpn::CryptoCHM
rekey	ssl/proto.hpp	/^      void rekey(const CryptoDCInstance::RekeyType type)$/;"	f	class:openvpn::ProtoContext::KeyContext
rekey_defined	ssl/proto.hpp	/^	bool rekey_defined;$/;"	m	struct:openvpn::ProtoContext::KeyContext::DataChannelKey
rekey_type	ssl/proto.hpp	/^	CryptoDCInstance::RekeyType rekey_type;$/;"	m	struct:openvpn::ProtoContext::KeyContext::DataChannelKey
rel_recv	ssl/protostack.hpp	/^    ReliableRecv rel_recv;$/;"	m	class:openvpn::ProtoStackBase
rel_send	ssl/protostack.hpp	/^    ReliableSend rel_send;$/;"	m	class:openvpn::ProtoStackBase
release	applecrypto/cf/cf.hpp	/^      T release()$/;"	f	class:openvpn::CF::Wrap
release	common/scoped_asio_stream.hpp	/^    STREAM* release()$/;"	f	class:openvpn::ScopedAsioStream
release	common/scoped_fd.hpp	/^    int release()$/;"	f	class:openvpn::ScopedFD
release	server/vpnservpool.hpp	/^      void release(IP46& addr_pair)$/;"	f	class:openvpn::VPNServerPool::Pool
release	tun/persist/tunwrapasio.hpp	/^    void release()$/;"	f	class:openvpn::TunWrapAsioStream
release	win/scoped_handle.hpp	/^      HANDLE release()$/;"	f	class:openvpn::Win::ScopedHANDLE
release_addr	addr/pool.hpp	/^      void release_addr(const ADDR& addr)$/;"	f	class:openvpn::IP::PoolType
reliable	reliable/relcommon.hpp	/^  namespace reliable {$/;"	n	namespace:openvpn
reliable_window	ssl/proto.hpp	/^      reliable::id_t reliable_window = 0;$/;"	m	class:openvpn::ProtoContext::Config
remaining	addr/range.hpp	/^      size_t remaining;$/;"	m	class:openvpn::IP::RangePartitionType
remaining	buffer/buffer.hpp	/^    size_t remaining(const size_t tailroom = 0) const {$/;"	f	class:openvpn::BufferType
remaining_	addr/range.hpp	/^	size_t remaining_;$/;"	m	class:openvpn::IP::RangeType::Iterator
remaining_payload	frame/frame.hpp	/^      size_t remaining_payload(const Buffer& buf) const$/;"	f	class:openvpn::Frame::Context
remote	client/remotelist.hpp	/^      std::string remote;$/;"	m	struct:openvpn::RemoteList::Directives
remote	server/peeraddr.hpp	/^    AddrPort remote;$/;"	m	struct:openvpn::PeerAddr
remote_address	tun/builder/capture.hpp	/^    RemoteAddress remote_address;          \/\/ real address of server$/;"	m	class:openvpn::TunBuilderCapture
remote_bypass	tun/client/tunprop.hpp	/^      bool remote_bypass = false;$/;"	m	struct:openvpn::TunProp::Config
remote_cert_eku	ssl/kuparse.hpp	/^    inline void remote_cert_eku(const OptionList& opt, std::string& eku)$/;"	f	namespace:openvpn::KUParse
remote_cert_ku	ssl/kuparse.hpp	/^    inline void remote_cert_ku(const OptionList& opt, std::vector<unsigned int>& ku)$/;"	f	namespace:openvpn::KUParse
remote_cert_tls	ssl/kuparse.hpp	/^    inline void remote_cert_tls(const OptionList& opt, std::vector<unsigned int>& ku, std::string& eku)$/;"	f	namespace:openvpn::KUParse
remote_cert_tls	ssl/kuparse.hpp	/^    inline void remote_cert_tls(const TLSWebType wt, std::vector<unsigned int>& ku, std::string& eku)$/;"	f	namespace:openvpn::KUParse
remote_list	client/cliopt.hpp	/^    RemoteList::Ptr remote_list;$/;"	m	class:openvpn::ClientOptions
remote_list	client/remotelist.hpp	/^      RemoteList::Ptr remote_list;$/;"	m	class:openvpn::RemoteList::PreResolve
remote_list	transport/altproxy.hpp	/^      RemoteList::Ptr remote_list;$/;"	m	struct:openvpn::AltProxy::Config
remote_list	transport/client/httpcli.hpp	/^      RemoteList& remote_list() const { return *config->remote_list; }$/;"	f	class:openvpn::HTTPProxyTransport::Client
remote_list	transport/client/httpcli.hpp	/^      RemoteList::Ptr remote_list;$/;"	m	class:openvpn::HTTPProxyTransport::ClientConfig
remote_list	transport/client/tcpcli.hpp	/^      RemoteList::Ptr remote_list;$/;"	m	class:openvpn::TCPTransport::ClientConfig
remote_list	transport/client/udpcli.hpp	/^      RemoteList::Ptr remote_list;$/;"	m	class:openvpn::UDPTransport::ClientConfig
remote_list	transport/dco.hpp	/^      RemoteList::Ptr remote_list;$/;"	m	struct:openvpn::DCO::TransportConfig
remote_list	tun/client/tunprop.hpp	/^      RemoteList::Ptr remote_list;$/;"	m	struct:openvpn::TunProp::Config
remote_list_precache	client/cliopt.hpp	/^    RemoteList::Ptr remote_list_precache() const$/;"	f	class:openvpn::ClientOptions
remote_override	client/cliopt.hpp	/^      RemoteList::RemoteOverride* remote_override = nullptr;$/;"	m	struct:openvpn::ClientOptions::Config
remote_override	client/remotelist.hpp	/^    RemoteOverride* remote_override = nullptr;$/;"	m	class:openvpn::RemoteList
remote_peer_id	ssl/proto.hpp	/^      int remote_peer_id = -1; \/\/ -1 to disable$/;"	m	class:openvpn::ProtoContext::Config
remote_peer_id	ssl/proto.hpp	/^      int remote_peer_id; \/\/ -1 to disable$/;"	m	class:openvpn::ProtoContext::KeyContext
remote_reset_cache_item	client/cliopt.hpp	/^    void remote_reset_cache_item()$/;"	f	class:openvpn::ClientOptions
remove_all_ipv4_routes_on_iface	tun/win/tunutil.hpp	/^	static void remove_all_ipv4_routes_on_iface(DWORD index, ActionList& actions)$/;"	f	class:openvpn::TunWin::Util::ActionDeleteAllRoutesOnInterface
remove_all_ipv6_routes_on_iface	tun/win/tunutil.hpp	/^	static void remove_all_ipv6_routes_on_iface(DWORD index, ActionList& actions)$/;"	f	class:openvpn::TunWin::Util::ActionDeleteAllRoutesOnInterface
remove_blanks	common/string.hpp	/^    inline std::string remove_blanks(const std::string& str)$/;"	f	namespace:openvpn::string
remove_cmds	tun/linux/client/tuncli.hpp	/^      ActionList::Ptr remove_cmds;$/;"	m	class:openvpn::TunLinux::Client
remove_cmds	tun/mac/client/tunsetup.hpp	/^      ActionList::Ptr remove_cmds;$/;"	m	class:openvpn::TunMac::Setup
remove_cmds	tun/win/client/tunsetup.hpp	/^      ActionList::Ptr remove_cmds;$/;"	m	class:openvpn::TunWin::Setup
remove_first	common/options.hpp	/^    void remove_first(const size_t n_elements)$/;"	f	class:openvpn::Option
remove_from_store	tun/mac/macdns.hpp	/^      bool remove_from_store()$/;"	f	class:openvpn::MacDNS::DSDict
remove_label	common/exception.hpp	/^    void remove_label(const std::string& label)$/;"	f	class:openvpn::Exception
remove_thread	common/runcontext.hpp	/^    void remove_thread()$/;"	f	class:openvpn::RunContext
render	addr/addrpair.hpp	/^	std::string render() const$/;"	f	class:openvpn::IP::AddrMaskPair::StringPair
render	buffer/bufhex.hpp	/^    inline std::string render(const T obj)$/;"	f	namespace:openvpn::BufHex
render	client/clievent.hpp	/^      virtual std::string render() const$/;"	f	class:openvpn::ClientEvent::Base
render	client/clievent.hpp	/^      virtual std::string render() const$/;"	f	struct:openvpn::ClientEvent::Connected
render	client/clievent.hpp	/^      virtual std::string render() const$/;"	f	struct:openvpn::ClientEvent::ReasonBase
render	client/clihalt.hpp	/^    std::string render() const {$/;"	f	class:openvpn::ClientHalt
render	common/options.hpp	/^    std::string render(const unsigned int flags) const$/;"	f	class:openvpn::Option
render	common/options.hpp	/^    std::string render(const unsigned int flags) const$/;"	f	class:openvpn::OptionList
render	crypto/static_key.hpp	/^    std::string render() const$/;"	f	class:openvpn::OpenVPNStaticKey
render	netconf/enumiface.hpp	/^      static void render(const ifaddrs* i, std::ostream& os)$/;"	f	class:openvpn::EnumIface
render_code	auth/authcert.hpp	/^	static const char *render_code(const Type code)$/;"	f	class:openvpn::AuthCert::Fail
render_flags	applecrypto/util/reachable.hpp	/^    static std::string render_flags(const SCNetworkReachabilityFlags flags)$/;"	f	class:openvpn::ReachabilityBase
render_flags	common/options.hpp	/^    enum render_flags {$/;"	g	class:openvpn::Option
render_flags	netconf/enumiface.hpp	/^      static std::string render_flags(const u_int flags)$/;"	f	class:openvpn::EnumIface
render_hex	common/hexstr.hpp	/^  inline std::string render_hex(const unsigned char *data, size_t size, const bool caps=false)$/;"	f	namespace:openvpn
render_hex	crypto/static_key.hpp	/^    std::string render_hex() const { return openvpn::render_hex_generic(key_data_); }$/;"	f	class:openvpn::StaticKey
render_hex_char	common/hexstr.hpp	/^  inline char render_hex_char(const int c, const bool caps=false)$/;"	f	namespace:openvpn
render_hex_generic	common/hexstr.hpp	/^  inline std::string render_hex_generic(const V& data, const bool caps=false)$/;"	f	namespace:openvpn
render_hex_number	common/hexstr.hpp	/^  std::string render_hex_number(T value, const bool caps=false)$/;"	f	namespace:openvpn
render_hex_number	common/hexstr.hpp	/^  std::string render_hex_number(unsigned char uc, const bool caps=false)$/;"	f	namespace:openvpn
render_hex_sep	common/hexstr.hpp	/^  inline std::string render_hex_sep(const unsigned char *data, size_t size, const char sep, const bool caps=false)$/;"	f	namespace:openvpn
render_list	tun/builder/capture.hpp	/^    static void render_list(std::ostream& os, const std::string& title, const LIST& list)$/;"	f	class:openvpn::TunBuilderCapture
render_map	common/options.hpp	/^    std::string render_map() const$/;"	f	class:openvpn::OptionList
render_options_sanitized	options/sanitize.hpp	/^  inline std::string render_options_sanitized(const OptionList& opt, const unsigned int render_flags)$/;"	f	namespace:openvpn
render_pem	openssl/pki/crl.hpp	/^      std::string render_pem() const$/;"	f	class:openvpn::OpenSSLPKI::CRL
render_pem	openssl/pki/crl.hpp	/^      std::string render_pem() const$/;"	f	class:openvpn::OpenSSLPKI::CRLList
render_pem	openssl/pki/dh.hpp	/^      std::string render_pem() const$/;"	f	class:openvpn::OpenSSLPKI::DH
render_pem	openssl/pki/pkey.hpp	/^      std::string render_pem() const$/;"	f	class:openvpn::OpenSSLPKI::PKey
render_pem	openssl/pki/x509.hpp	/^      std::string render_pem() const$/;"	f	class:openvpn::OpenSSLPKI::X509Base
render_pem	openssl/pki/x509.hpp	/^      std::string render_pem() const$/;"	f	class:openvpn::OpenSSLPKI::X509List
render_pem	pki/cclist.hpp	/^    std::string render_pem() const$/;"	f	class:openvpn::CertCRLListTemplate
render_status	applecrypto/util/reachable.hpp	/^    static std::string render_status(const Status status)$/;"	f	class:openvpn::ReachabilityBase
render_type	applecrypto/util/reachable.hpp	/^    static std::string render_type(Type type)$/;"	f	class:openvpn::ReachabilityBase
renegotiate	ssl/proto.hpp	/^      Time::Duration renegotiate;      \/\/ start SSL\/TLS renegotiation at this time$/;"	m	class:openvpn::ProtoContext::Config
renegotiate	ssl/proto.hpp	/^    void renegotiate()$/;"	f	class:openvpn::ProtoContext
renegotiate_request	ssl/proto.hpp	/^    bool renegotiate_request(Packet& pkt)$/;"	f	class:openvpn::ProtoContext
rep	time/asiotimer.hpp	/^    typedef olong rep;$/;"	t	struct:openvpn::AsioClock
replace	common/scoped_asio_stream.hpp	/^    void replace(STREAM* obj)$/;"	f	class:openvpn::ScopedAsioStream
replace	common/scoped_fd.hpp	/^    void replace(const int fd_arg)$/;"	f	class:openvpn::ScopedFD
replace	win/scoped_handle.hpp	/^      void replace(HANDLE h)$/;"	f	class:openvpn::Win::ScopedHANDLE
replace_copy	common/string.hpp	/^    inline std::string replace_copy(const std::string& str, const char from, const char to)$/;"	f	namespace:openvpn::string
replace_password_with_session_id	client/clicreds.hpp	/^    bool replace_password_with_session_id;$/;"	m	class:openvpn::ClientCreds
replace_spaces	common/string.hpp	/^    inline std::string replace_spaces(const std::string& str, const char rep)$/;"	f	namespace:openvpn::string
request	http/urlparm.hpp	/^      const std::string& request() const$/;"	f	class:openvpn::URL::ParmList
request	http/urlparm.hpp	/^      std::string request(const bool remove_leading_slash) const$/;"	f	class:openvpn::URL::ParmList
request_	http/urlparm.hpp	/^      std::string request_;$/;"	m	class:openvpn::URL::ParmList
required_argument	common/getopt.hpp	/^    required_argument=1,$/;"	e	enum:openvpn::__anon19
reroute_gw	tun/builder/capture.hpp	/^    RerouteGW reroute_gw;                  \/\/ redirect-gateway info$/;"	m	class:openvpn::TunBuilderCapture
res	random/randbytestore.hpp	/^    Result res;$/;"	m	class:openvpn::RandomByteStore
res_addr_list	client/remotelist.hpp	/^      ResolvedAddrList::Ptr res_addr_list;$/;"	m	struct:openvpn::RemoteList::Item
res_addr_list_defined	client/remotelist.hpp	/^      bool res_addr_list_defined() const$/;"	f	struct:openvpn::RemoteList::Item
reserve	buffer/buffer.hpp	/^    void reserve(const size_t n)$/;"	f	class:openvpn::BufferType
reserve	buffer/safestr.hpp	/^    void reserve(const size_t n)$/;"	f	class:openvpn::SafeString
reserve	common/options.hpp	/^    void reserve(const size_t n) { data.reserve(n); }$/;"	f	class:openvpn::Option
reset	addr/ip.hpp	/^      void reset()$/;"	f	class:openvpn::IP::Addr
reset	addr/macaddr.hpp	/^    void reset(const unsigned char *addr)$/;"	f	class:openvpn::MACAddr
reset	apple/ver.hpp	/^    void reset()$/;"	f	class:openvpn::AppleVersion
reset	applecrypto/cf/cf.hpp	/^      void reset(T obj=nullptr, const Own own=OWN)$/;"	f	class:openvpn::CF::Wrap
reset	applecrypto/crypto/cipher.hpp	/^      void reset(const unsigned char *iv)$/;"	f	class:openvpn::AppleCrypto::CipherContext
reset	applecrypto/crypto/hmac.hpp	/^      void reset() \/\/ Apple HMAC API is missing reset method, so we have to reinit$/;"	f	class:openvpn::AppleCrypto::HMACContext
reset	buffer/buffer.hpp	/^    void reset(const size_t headroom, const size_t min_capacity, const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
reset	buffer/buffer.hpp	/^    void reset(const size_t headroom, const size_t min_capacity, const unsigned int flags)$/;"	f	class:openvpn::BufferType
reset	buffer/buffer.hpp	/^    void reset(const size_t min_capacity, const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
reset	buffer/buffer.hpp	/^    void reset(const size_t min_capacity, const unsigned int flags)$/;"	f	class:openvpn::BufferType
reset	buffer/buflimit.hpp	/^    void reset()$/;"	f	class:openvpn::BufferLimit
reset	client/remotelist.hpp	/^      void reset()$/;"	f	class:openvpn::RemoteList::Index
reset	common/circ_list.hpp	/^    void reset()$/;"	f	class:openvpn::CircList
reset	common/glob.hpp	/^    void reset()$/;"	f	class:openvpn::Glob
reset	common/hostlist.hpp	/^      void reset()$/;"	f	class:openvpn::HostList::Iterator
reset	common/hostlist.hpp	/^      void reset()$/;"	f	struct:openvpn::HostList::Host
reset	common/lex.hpp	/^    void reset() { ch = -1; }$/;"	f	class:openvpn::NullLex
reset	common/lex.hpp	/^    void reset() { ch = -1; }$/;"	f	class:openvpn::StandardLex
reset	common/options.hpp	/^      void reset() { ch = -1; }$/;"	f	class:openvpn::OptionList::LexComment
reset	common/scoped_asio_stream.hpp	/^    void reset(STREAM* obj)$/;"	f	class:openvpn::ScopedAsioStream
reset	common/scoped_fd.hpp	/^    void reset()$/;"	f	class:openvpn::ScopedFD
reset	common/scoped_fd.hpp	/^    void reset(const int fd_arg)$/;"	f	class:openvpn::ScopedFD
reset	crypto/cryptodc.hpp	/^    void reset()$/;"	f	class:openvpn::CryptoDCSettings
reset	crypto/digestapi.hpp	/^    virtual void reset()$/;"	f	class:openvpn::CryptoHMACInstance
reset	crypto/packet_id.hpp	/^    void reset()$/;"	f	struct:openvpn::PacketID
reset	http/reply.hpp	/^      void reset()$/;"	f	class:openvpn::HTTP::ReplyParser
reset	http/reply.hpp	/^      void reset()$/;"	f	struct:openvpn::HTTP::Reply
reset	http/request.hpp	/^      void reset()$/;"	f	class:openvpn::HTTP::RequestParser
reset	http/request.hpp	/^      void reset()$/;"	f	struct:openvpn::HTTP::Request
reset	openssl/crypto/cipher.hpp	/^      void reset(const unsigned char *iv)$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
reset	openssl/crypto/hmac.hpp	/^      void reset()$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
reset	polarssl/crypto/cipher.hpp	/^      void reset(const unsigned char *iv)$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
reset	polarssl/crypto/hmac.hpp	/^      void reset()$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
reset	ssl/proto.hpp	/^      void reset()$/;"	f	class:openvpn::ProtoContext::Packet
reset	ssl/proto.hpp	/^    void reset()$/;"	f	class:openvpn::ProtoContext
reset	ssl/psid.hpp	/^    void reset()$/;"	f	class:openvpn::ProtoSessionID
reset	time/coarsetime.hpp	/^    void reset() { time_.reset(); }$/;"	f	class:openvpn::CoarseTime
reset	time/coarsetime.hpp	/^    void reset(const Time& t) { time_ = t; }$/;"	f	class:openvpn::CoarseTime
reset	time/time.hpp	/^    void reset() { time_ = 0; }$/;"	f	class:openvpn::TimeType
reset	transport/client/httpcli.hpp	/^      void reset()$/;"	f	class:openvpn::HTTPProxyTransport::Client
reset	transport/protocol.hpp	/^    void reset() { type_ = NONE; }$/;"	f	class:openvpn::Protocol
reset	tun/client/dhcp_capture.hpp	/^    void reset()$/;"	f	class:openvpn::DHCPCapture
reset	tun/win/wfp.hpp	/^	void reset(std::ostream* log)$/;"	f	class:openvpn::TunWin::WFP::WFPEngine
reset	tun/win/wfp.hpp	/^      void reset(std::ostream& log)$/;"	f	class:openvpn::TunWin::WFP
reset	win/scoped_handle.hpp	/^      void reset()$/;"	f	class:openvpn::Win::ScopedHANDLE
reset	win/scoped_handle.hpp	/^      void reset(HANDLE h)$/;"	f	class:openvpn::Win::ScopedHANDLE
reset_align_adjust	frame/frame.hpp	/^      void reset_align_adjust(const size_t align_adjust)$/;"	f	class:openvpn::Frame::Context
reset_align_adjust	transport/client/httpcli.hpp	/^      virtual void reset_align_adjust(const size_t align_adjust)$/;"	f	class:openvpn::HTTPProxyTransport::Client
reset_align_adjust	transport/client/tcpcli.hpp	/^      virtual void reset_align_adjust(const size_t align_adjust)$/;"	f	class:openvpn::TCPTransport::Client
reset_align_adjust	transport/client/udpcli.hpp	/^      virtual void reset_align_adjust(const size_t align_adjust)$/;"	f	class:openvpn::UDPTransport::Client
reset_align_adjust	transport/tcplink.hpp	/^      void reset_align_adjust(const size_t align_adjust)$/;"	f	class:openvpn::TCPTransport::Link
reset_align_adjust	transport/udplink.hpp	/^      void reset_align_adjust(const size_t align_adjust)$/;"	f	class:openvpn::UDPTransport::Link
reset_all	ssl/proto.hpp	/^    void reset_all()$/;"	f	class:openvpn::ProtoContext
reset_base	time/time.hpp	/^    static void reset_base()$/;"	f	class:openvpn::TimeType
reset_base_conditional	time/time.hpp	/^    static void reset_base_conditional()$/;"	f	class:openvpn::TimeType
reset_buf	buffer/bufcomplete.hpp	/^    void reset_buf()$/;"	f	class:openvpn::BufferComplete
reset_buf	buffer/bufcomplete.hpp	/^    void reset_buf(const Buffer& buf_arg)$/;"	f	class:openvpn::BufferComplete
reset_cache	client/remotelist.hpp	/^    void reset_cache()$/;"	f	class:openvpn::RemoteList
reset_cache_item	client/remotelist.hpp	/^    void reset_cache_item()$/;"	f	class:openvpn::RemoteList
reset_content	buffer/buffer.hpp	/^    void reset_content()$/;"	f	class:openvpn::BufferType
reset_dc_factory	ssl/proto.hpp	/^    void reset_dc_factory()$/;"	f	class:openvpn::ProtoContext
reset_dns_servers	tun/builder/capture.hpp	/^    void reset_dns_servers()$/;"	f	class:openvpn::TunBuilderCapture
reset_event	ssl/proto.hpp	/^      void reset_event() { current_event = KEV_NONE; }$/;"	f	class:openvpn::ProtoContext::KeyContext
reset_impl	buffer/buffer.hpp	/^    virtual void reset_impl(const size_t min_capacity, const unsigned int flags)$/;"	f	class:openvpn::BufferAllocatedType
reset_impl	buffer/buffer.hpp	/^    virtual void reset_impl(const size_t min_capacity, const unsigned int flags)$/;"	f	class:openvpn::BufferType
reset_ipv4_from_uint32	addr/ip.hpp	/^      void reset_ipv4_from_uint32(const IPv4::Addr::base_type addr)$/;"	f	class:openvpn::IP::Addr
reset_item	client/remotelist.hpp	/^    void reset_item(const size_t i)$/;"	f	class:openvpn::RemoteList
reset_non_buf	ssl/proto.hpp	/^      void reset_non_buf()$/;"	f	class:openvpn::ProtoContext::Packet
reset_op	ssl/proto.hpp	/^      unsigned int reset_op;$/;"	m	class:openvpn::ProtoContext::TLSAuthPreValidate
reset_partial	transport/client/httpcli.hpp	/^      void reset_partial()$/;"	f	class:openvpn::HTTPProxyTransport::Client
reset_pod	client/cliopthelper.hpp	/^    void reset_pod()$/;"	f	class:openvpn::ParseClientConfig
reset_primary_dns	tun/mac/macdns.hpp	/^    bool reset_primary_dns(Info* info)$/;"	f	class:openvpn::MacDNS
reset_retransmit	reliable/relsend.hpp	/^      void reset_retransmit(const Time& now, const Time::Duration& tls_timeout)$/;"	f	class:openvpn::ReliableSendTemplate::Message
reset_secondary	client/remotelist.hpp	/^      void reset_secondary()$/;"	f	class:openvpn::RemoteList::Index
reset_size	buffer/buffer.hpp	/^    void reset_size()$/;"	f	class:openvpn::BufferType
reset_tunnel_addresses	tun/builder/capture.hpp	/^    void reset_tunnel_addresses()$/;"	f	class:openvpn::TunBuilderCapture
resetdns	tun/mac/macdns.hpp	/^    bool resetdns()$/;"	f	class:openvpn::MacDNS
residual	http/htmlskip.hpp	/^      BufferAllocated residual;$/;"	m	class:openvpn::HTTP::HTMLSkip
resize	buffer/buffer.hpp	/^    virtual void resize(const size_t new_capacity)$/;"	f	class:openvpn::BufferAllocatedType
resize	buffer/buffer.hpp	/^    virtual void resize(const size_t new_capacity)$/;"	f	class:openvpn::BufferType
resize	buffer/memq.hpp	/^    void resize(const size_t cap)$/;"	f	class:openvpn::MemQBase
resize	common/options.hpp	/^    void resize(const size_t n) { data.resize(n); }$/;"	f	class:openvpn::Option
resolve_callback	client/remotelist.hpp	/^      void resolve_callback(const asio::error_code& error,$/;"	f	class:openvpn::RemoteList::PreResolve
resolver	client/remotelist.hpp	/^      asio::ip::tcp::resolver resolver;$/;"	m	class:openvpn::RemoteList::PreResolve
resolver	transport/client/httpcli.hpp	/^      asio::ip::tcp::resolver resolver;$/;"	m	class:openvpn::HTTPProxyTransport::Client
resolver	transport/client/tcpcli.hpp	/^      asio::ip::tcp::resolver resolver;$/;"	m	class:openvpn::TCPTransport::Client
resolver	transport/client/udpcli.hpp	/^      asio::ip::udp::resolver resolver;$/;"	m	class:openvpn::UDPTransport::Client
response	client/clicreds.hpp	/^    std::string response;$/;"	m	class:openvpn::ClientCreds
response_required	auth/cr.hpp	/^    bool response_required;$/;"	m	class:openvpn::ChallengeResponse
restart	client/clihalt.hpp	/^    bool restart() const { return restart_; }$/;"	f	class:openvpn::ClientHalt
restart_	client/clihalt.hpp	/^    bool restart_ = false;$/;"	m	class:openvpn::ClientHalt
restart_wait_callback	client/cliconnect.hpp	/^    void restart_wait_callback(unsigned int gen, const asio::error_code& e)$/;"	f	class:openvpn::ClientConnect
restart_wait_timer	client/cliconnect.hpp	/^    AsioTimer restart_wait_timer;$/;"	m	class:openvpn::ClientConnect
restore_orig	tun/mac/macdns.hpp	/^      void restore_orig()$/;"	f	class:openvpn::MacDNS::DSDict
result_type	random/randapi.hpp	/^    typedef unsigned int result_type;$/;"	t	class:openvpn::RandomAPI
resume	client/cliconnect.hpp	/^    void resume()$/;"	f	class:openvpn::ClientConnect
retain_obj_	tun/persist/tunwrap.hpp	/^    const bool retain_obj_;$/;"	m	class:openvpn::TunWrapTemplate
retain_sd	tun/builder/client.hpp	/^      bool retain_sd;$/;"	m	class:openvpn::TunBuilderClient::ClientConfig
retain_stream	tun/tunio.hpp	/^    bool retain_stream;  \/\/ don't close tun stream$/;"	m	class:openvpn::TunIO
retransmit	ssl/proto.hpp	/^      void retransmit()$/;"	f	class:openvpn::ProtoContext::KeyContext
retransmit	ssl/protostack.hpp	/^    void retransmit()$/;"	f	class:openvpn::ProtoStackBase
retransmit_at_	reliable/relsend.hpp	/^      Time retransmit_at_;$/;"	m	class:openvpn::ReliableSendTemplate::Message
reuseaddr	common/sockopt.hpp	/^    inline void reuseaddr(const int fd)$/;"	f	namespace:openvpn::SockOpt
reuseport	common/sockopt.hpp	/^    inline void reuseport(const int fd)$/;"	f	namespace:openvpn::SockOpt
reverse_	common/action.hpp	/^    bool reverse_ = false;$/;"	m	class:openvpn::ActionList
rg_enabled	client/rgopt.hpp	/^    bool rg_enabled() const$/;"	f	class:openvpn::RedirectGatewayFlags
rg_flags	netconf/linux/route.hpp	/^    RedirectGatewayFlags rg_flags;$/;"	m	class:openvpn::RouteListLinux
rg_flags_	client/ipverflags.hpp	/^    const RedirectGatewayFlags rg_flags_;$/;"	m	class:openvpn::IPVerFlags
rg_ver_flags	client/ipverflags.hpp	/^    IP::Addr::VersionMask rg_ver_flags() const$/;"	f	class:openvpn::IPVerFlags
rgv4	client/ipverflags.hpp	/^    bool rgv4() const$/;"	f	class:openvpn::IPVerFlags
rgv6	client/ipverflags.hpp	/^    bool rgv6() const$/;"	f	class:openvpn::IPVerFlags
ri	transport/gremlin.hpp	/^      MTRand ri;$/;"	m	class:openvpn::Gremlin::SendRecvQueue
rm_by_id	common/msgwin.hpp	/^    void rm_by_id(const id_t id)$/;"	f	class:openvpn::MessageWindow
rm_head	common/msgwin.hpp	/^    void rm_head()$/;"	f	class:openvpn::MessageWindow
rm_head_nocheck	common/msgwin.hpp	/^    void rm_head_nocheck()$/;"	f	class:openvpn::MessageWindow
rmx_expire	netconf/ios/net-route.h	/^	int32_t		rmx_expire;	\/* lifetime for route, e.g. redirect *\/$/;"	m	struct:rt_metrics
rmx_filler	netconf/ios/net-route.h	/^	u_int32_t	rmx_filler[4];	\/* will be used for T\/TCP later *\/$/;"	m	struct:rt_metrics
rmx_hopcount	netconf/ios/net-route.h	/^	u_int32_t	rmx_hopcount;	\/* max hops expected *\/$/;"	m	struct:rt_metrics
rmx_locks	netconf/ios/net-route.h	/^	u_int32_t	rmx_locks;	\/* Kernel leaves these values alone *\/$/;"	m	struct:rt_metrics
rmx_mtu	netconf/ios/net-route.h	/^	u_int32_t	rmx_mtu;	\/* MTU for this path *\/$/;"	m	struct:rt_metrics
rmx_pksent	netconf/ios/net-route.h	/^	u_int32_t	rmx_pksent;	\/* packets sent using this route *\/$/;"	m	struct:rt_metrics
rmx_recvpipe	netconf/ios/net-route.h	/^	u_int32_t	rmx_recvpipe;	\/* inbound delay-bandwidth product *\/$/;"	m	struct:rt_metrics
rmx_rtt	netconf/ios/net-route.h	/^	u_int32_t	rmx_rtt;	\/* estimated round trip time *\/$/;"	m	struct:rt_metrics
rmx_rttvar	netconf/ios/net-route.h	/^	u_int32_t	rmx_rttvar;	\/* estimated rtt variance *\/$/;"	m	struct:rt_metrics
rmx_sendpipe	netconf/ios/net-route.h	/^	u_int32_t	rmx_sendpipe;	\/* outbound delay-bandwidth product *\/$/;"	m	struct:rt_metrics
rmx_ssthresh	netconf/ios/net-route.h	/^	u_int32_t	rmx_ssthresh;	\/* outbound gateway buffer limit *\/$/;"	m	struct:rt_metrics
rndbytes	applecrypto/util/rand.hpp	/^    bool rndbytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::AppleRandom
rndbytes	openssl/util/rand.hpp	/^    bool rndbytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::OpenSSLRandom
rndbytes	polarssl/util/rand.hpp	/^    bool rndbytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::PolarSSLRandom
rndbytes	random/devurand.hpp	/^    bool rndbytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::DevURand
rndbytes	random/mtrandapi.hpp	/^    bool rndbytes(unsigned char *buf, size_t size)$/;"	f	class:openvpn::MTRand
rng	client/cliopt.hpp	/^    RandomAPI::Ptr rng;$/;"	m	class:openvpn::ClientOptions
rng	client/remotelist.hpp	/^    RandomAPI::Ptr rng;$/;"	m	class:openvpn::RemoteList
rng	polarssl/ssl/sslctx.hpp	/^      RandomAPI::Ptr rng;      \/\/ random data source$/;"	m	class:openvpn::PolarSSLContext::SSL
rng	polarssl/ssl/sslctx.hpp	/^      RandomAPI::Ptr rng;   \/\/ random data source$/;"	m	class:openvpn::PolarSSLContext::Config
rng	random/mtrandapi.hpp	/^    rand_type rng;$/;"	m	class:openvpn::MTRand
rng	ssl/proto.hpp	/^      RandomAPI::Ptr rng;$/;"	m	class:openvpn::ProtoContext::Config
rng	transport/altproxy.hpp	/^      RandomAPI::Ptr rng;$/;"	m	struct:openvpn::AltProxy::Config
rng	transport/client/httpcli.hpp	/^      RandomAPI::Ptr rng; \/\/ random data source$/;"	m	class:openvpn::HTTPProxyTransport::ClientConfig
rng_callback	polarssl/ssl/sslctx.hpp	/^      static int rng_callback(void *arg, unsigned char *data, size_t len)$/;"	f	class:openvpn::PolarSSLContext::SSL
root	common/path.hpp	/^    inline std::string root(const std::string& basename)$/;"	f	namespace:openvpn::path
root_or_self_uid	common/peercred.hpp	/^      bool root_or_self_uid() const$/;"	f	struct:openvpn::SockOpt::Creds
root_port	apple/macsleep.hpp	/^    io_connect_t root_port;$/;"	m	class:openvpn::MacSleep
root_uid	common/peercred.hpp	/^      bool root_uid() const$/;"	f	struct:openvpn::SockOpt::Creds
route_from_string	addr/route.hpp	/^    inline Route route_from_string(const std::string& rtstr,$/;"	f	namespace:openvpn::IP
route_from_string_prefix	addr/route.hpp	/^    inline Route route_from_string_prefix(const std::string& addrstr,$/;"	f	namespace:openvpn::IP
route_gateway	netconf/linux/route.hpp	/^    IP::Addr route_gateway;$/;"	m	class:openvpn::RouteListLinux
route_gateway	tun/client/tunprop.hpp	/^    static IP::Addr route_gateway(const OptionList& opt)$/;"	f	class:openvpn::TunProp
route_metric_default	tun/builder/capture.hpp	/^    int route_metric_default = -1;         \/\/ route-metric directive$/;"	m	class:openvpn::TunBuilderCapture
route_metric_opt	tun/win/client/tunsetup.hpp	/^      static std::string route_metric_opt(const TunBuilderCapture& pull,$/;"	f	class:openvpn::TunWin::Setup
route_nopull_	client/optfilt.hpp	/^    bool route_nopull_;$/;"	m	class:openvpn::PushedOptionsFilter
route_target	tun/client/tunprop.hpp	/^    static bool route_target(const Option& o, const size_t target_index)$/;"	f	class:openvpn::TunProp
router	tun/mac/macgw.hpp	/^      IP::Addr router;$/;"	m	struct:openvpn::MacGWInfo::Variant
rsa_finish	openssl/ssl/sslctx.hpp	/^      static int rsa_finish(RSA *rsa)$/;"	f	class:openvpn::OpenSSLContext::ExternalPKIImpl
rsa_priv_dec	openssl/ssl/sslctx.hpp	/^      rsa_priv_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	class:openvpn::OpenSSLContext::ExternalPKIImpl
rsa_priv_enc	openssl/ssl/sslctx.hpp	/^      static int rsa_priv_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	class:openvpn::OpenSSLContext::ExternalPKIImpl
rsa_pub_dec	openssl/ssl/sslctx.hpp	/^      rsa_pub_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	class:openvpn::OpenSSLContext::ExternalPKIImpl
rsa_pub_enc	openssl/ssl/sslctx.hpp	/^      static int rsa_pub_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	class:openvpn::OpenSSLContext::ExternalPKIImpl
rt	random/randbytestore.hpp	/^      typename RAND_TYPE::result_type rt;$/;"	m	union:openvpn::RandomByteStore::Result
rt_addrinfo	netconf/ios/net-route.h	/^struct rt_addrinfo {$/;"	s
rt_metrics	netconf/ios/net-route.h	/^struct rt_metrics {$/;"	s
rt_msghdr	netconf/ios/net-route.h	/^struct rt_msghdr {$/;"	s
rt_msghdr2	netconf/ios/net-route.h	/^struct rt_msghdr2 {$/;"	s
rti_addrs	netconf/ios/net-route.h	/^	int	rti_addrs;$/;"	m	struct:rt_addrinfo
rti_info	netconf/ios/net-route.h	/^	struct	sockaddr *rti_info[RTAX_MAX];$/;"	m	struct:rt_addrinfo	typeref:struct:rt_addrinfo::sockaddr
rtm_addrs	netconf/ios/net-route.h	/^	int	rtm_addrs;	\/* bitmask identifying sockaddrs in msg *\/$/;"	m	struct:rt_msghdr
rtm_addrs	netconf/ios/net-route.h	/^	int	rtm_addrs;	\/* bitmask identifying sockaddrs in msg *\/$/;"	m	struct:rt_msghdr2
rtm_errno	netconf/ios/net-route.h	/^	int	rtm_errno;	\/* why failed *\/$/;"	m	struct:rt_msghdr
rtm_flags	netconf/ios/net-route.h	/^	int	rtm_flags;	\/* flags, incl. kern & message, e.g. DONE *\/$/;"	m	struct:rt_msghdr
rtm_flags	netconf/ios/net-route.h	/^	int	rtm_flags;	\/* flags, incl. kern & message, e.g. DONE *\/$/;"	m	struct:rt_msghdr2
rtm_index	netconf/ios/net-route.h	/^	u_short	rtm_index;	\/* index for associated ifp *\/$/;"	m	struct:rt_msghdr
rtm_index	netconf/ios/net-route.h	/^	u_short	rtm_index;	\/* index for associated ifp *\/$/;"	m	struct:rt_msghdr2
rtm_inits	netconf/ios/net-route.h	/^	u_int32_t rtm_inits;	\/* which metrics we are initializing *\/$/;"	m	struct:rt_msghdr
rtm_inits	netconf/ios/net-route.h	/^	u_int32_t rtm_inits;	\/* which metrics we are initializing *\/$/;"	m	struct:rt_msghdr2
rtm_msglen	netconf/ios/net-route.h	/^	u_short	rtm_msglen;	\/* to skip over non-understood messages *\/$/;"	m	struct:rt_msghdr
rtm_msglen	netconf/ios/net-route.h	/^	u_short	rtm_msglen;	\/* to skip over non-understood messages *\/$/;"	m	struct:rt_msghdr2
rtm_parentflags	netconf/ios/net-route.h	/^	int	rtm_parentflags; \/* flags of the parent route *\/$/;"	m	struct:rt_msghdr2
rtm_pid	netconf/ios/net-route.h	/^	pid_t	rtm_pid;	\/* identify sender *\/$/;"	m	struct:rt_msghdr
rtm_refcnt	netconf/ios/net-route.h	/^	int32_t	rtm_refcnt;	\/* reference count *\/$/;"	m	struct:rt_msghdr2
rtm_reserved	netconf/ios/net-route.h	/^	int	rtm_reserved;	\/* reserved field set to 0 *\/$/;"	m	struct:rt_msghdr2
rtm_rmx	netconf/ios/net-route.h	/^	struct rt_metrics rtm_rmx; \/* metrics themselves *\/$/;"	m	struct:rt_msghdr	typeref:struct:rt_msghdr::rt_metrics
rtm_rmx	netconf/ios/net-route.h	/^	struct rt_metrics rtm_rmx; \/* metrics themselves *\/$/;"	m	struct:rt_msghdr2	typeref:struct:rt_msghdr2::rt_metrics
rtm_seq	netconf/ios/net-route.h	/^	int	rtm_seq;	\/* for sender to identify action *\/$/;"	m	struct:rt_msghdr
rtm_type	netconf/ios/net-route.h	/^	u_char	rtm_type;	\/* message type *\/$/;"	m	struct:rt_msghdr
rtm_type	netconf/ios/net-route.h	/^	u_char	rtm_type;	\/* message type *\/$/;"	m	struct:rt_msghdr2
rtm_use	netconf/ios/net-route.h	/^	int	rtm_use;	\/* from rtentry *\/$/;"	m	struct:rt_msghdr
rtm_use	netconf/ios/net-route.h	/^	int	rtm_use;	\/* from rtentry *\/$/;"	m	struct:rt_msghdr2
rtm_version	netconf/ios/net-route.h	/^	u_char	rtm_version;	\/* future binary compatibility *\/$/;"	m	struct:rt_msghdr
rtm_version	netconf/ios/net-route.h	/^	u_char	rtm_version;	\/* future binary compatibility *\/$/;"	m	struct:rt_msghdr2
rtmsg	tun/mac/gwv4.hpp	/^    struct rtmsg {$/;"	s	class:openvpn::MacGatewayInfoV4
rts_badredirect	netconf/ios/net-route.h	/^	short	rts_badredirect;	\/* bogus redirect calls *\/$/;"	m	struct:rtstat
rts_dynamic	netconf/ios/net-route.h	/^	short	rts_dynamic;		\/* routes created by redirects *\/$/;"	m	struct:rtstat
rts_newgateway	netconf/ios/net-route.h	/^	short	rts_newgateway;		\/* routes modified by redirects *\/$/;"	m	struct:rtstat
rts_unreach	netconf/ios/net-route.h	/^	short	rts_unreach;		\/* lookups which failed *\/$/;"	m	struct:rtstat
rts_wildcard	netconf/ios/net-route.h	/^	short	rts_wildcard;		\/* lookups satisfied by a wildcard *\/$/;"	m	struct:rtstat
rtstat	netconf/ios/net-route.h	/^struct	rtstat {$/;"	s
run	common/runcontext.hpp	/^    void run()$/;"	f	class:openvpn::RunContext
runloop	apple/maclife.hpp	/^    CF::RunLoop runloop;           \/\/ run loop in thread$/;"	m	class:openvpn::MacLifeCycle
runloop	tun/mac/macdns_watchdog.hpp	/^    CF::RunLoop runloop;           \/\/ run loop in watcher thread$/;"	m	class:openvpn::MacDNSWatchdog
rx_bytes	server/peerstats.hpp	/^    std::uint64_t rx_bytes;$/;"	m	struct:openvpn::PeerStats
s	buffer/zlib.hpp	/^      z_stream s;$/;"	m	class:openvpn::ZLib::ZStreamBase
saddr	ip/ip.hpp	/^    std::uint32_t   saddr;$/;"	m	struct:openvpn::IPHeader
sanitize_common_name	ssl/tls_remote.hpp	/^    inline std::string sanitize_common_name(const std::string& str)$/;"	f	namespace:openvpn::TLSRemote
sanitize_control_message	options/sanitize.hpp	/^  inline std::string sanitize_control_message(const std::string& src_str)$/;"	f	namespace:openvpn
sanitize_x509_name	ssl/tls_remote.hpp	/^    inline std::string sanitize_x509_name(const std::string& str)$/;"	f	namespace:openvpn::TLSRemote
save_replace_sock	tun/persist/tunwrap.hpp	/^    void save_replace_sock(const typename SCOPED_OBJ::base_type obj)$/;"	f	class:openvpn::TunWrapTemplate
sc	tun/mac/macdns.hpp	/^      CF::DynamicStore sc;$/;"	m	class:openvpn::MacDNS::DSDict
schedule	applecrypto/util/reachable.hpp	/^    bool schedule(ReachabilityBase& rb, SCNetworkReachabilityCallBack cb)$/;"	f	class:openvpn::ReachabilityTracker
schedule_action_timer	apple/maclife.hpp	/^    void schedule_action_timer(const int seconds)$/;"	f	class:openvpn::MacLifeCycle
schedule_inactive_timer	client/cliproto.hpp	/^      void schedule_inactive_timer()$/;"	f	class:openvpn::ClientProto::Session
schedule_info_hold_callback	client/cliproto.hpp	/^      void schedule_info_hold_callback()$/;"	f	class:openvpn::ClientProto::Session
schedule_key_limit_renegotiation	ssl/proto.hpp	/^      void schedule_key_limit_renegotiation()$/;"	f	class:openvpn::ProtoContext::KeyContext
schedule_push_request_callback	client/cliproto.hpp	/^      void schedule_push_request_callback(const Time::Duration& dur)$/;"	f	class:openvpn::ClientProto::Session
schedule_push_timer	tun/mac/macdns_watchdog.hpp	/^    void schedule_push_timer(const int seconds)$/;"	f	class:openvpn::MacDNSWatchdog
scheduled	applecrypto/util/reachable.hpp	/^    bool scheduled;$/;"	m	class:openvpn::ReachabilityTracker
scheme	http/urlparse.hpp	/^      std::string scheme;$/;"	m	class:openvpn::URL::Parse
scope_id	addr/ip.hpp	/^      int scope_id() const$/;"	f	class:openvpn::IP::Addr
scope_id	addr/ipv6.hpp	/^      int scope_id() const$/;"	f	class:openvpn::IPv6::Addr
scope_id_	addr/ipv6.hpp	/^      unsigned int scope_id_;$/;"	m	class:openvpn::IPv6::Addr
scopes	common/stop.hpp	/^    std::vector<Scope*> scopes;$/;"	m	class:openvpn::Stop
sd	common/redir.hpp	/^      std::unique_ptr<asio::posix::stream_descriptor> sd;$/;"	m	class:openvpn::RedirectPipe::SD
search_domain	tun/win/tunutil.hpp	/^	const std::string search_domain;$/;"	m	class:openvpn::TunWin::Util::ActionSetAdapterDomainSuffix
search_domains	tun/builder/capture.hpp	/^    std::vector<SearchDomain> search_domains;  \/\/ domain suffixes whose DNS requests should be tunnel-routed$/;"	m	class:openvpn::TunBuilderCapture
search_domains	tun/mac/macdns.hpp	/^      CF::Array search_domains;$/;"	m	class:openvpn::MacDNS::Config
search_domains_exist	tun/client/tunprop.hpp	/^    static bool search_domains_exist(const OptionList& opt, const bool quiet)$/;"	f	class:openvpn::TunProp
search_order	tun/mac/macdns.hpp	/^      int search_order = 5000;$/;"	m	class:openvpn::MacDNS::Config
search_server_host	client/remotelist.hpp	/^    Item* search_server_host(const std::string& server_host)$/;"	f	class:openvpn::RemoteList
secondary	client/remotelist.hpp	/^      size_t secondary() const { return secondary_; }$/;"	f	class:openvpn::RemoteList::Index
secondary	ssl/proto.hpp	/^    KeyContext::Ptr secondary;$/;"	m	class:openvpn::ProtoContext
secondary_	client/remotelist.hpp	/^      size_t secondary_;$/;"	m	class:openvpn::RemoteList::Index
secondary_length	client/remotelist.hpp	/^    size_t secondary_length(const size_t i) const$/;"	f	class:openvpn::RemoteList
seconds	time/time.hpp	/^      static Duration seconds(const T v) { return Duration(v * prec); }$/;"	f	class:openvpn::TimeType::Duration
seconds_since_epoch	time/time.hpp	/^    base_type seconds_since_epoch() const { return base_ + time_ \/ prec; }$/;"	f	class:openvpn::TimeType
seconds_until	ssl/proto.hpp	/^      int seconds_until(const Time& next_time)$/;"	f	class:openvpn::ProtoContext::KeyContext
secs	ip/dhcp.hpp	/^    std::uint16_t secs;       \/* seconds since request process began, set by client *\/$/;"	m	struct:openvpn::DHCP
seed_	common/hash.hpp	/^      std::size_t seed_;$/;"	m	class:openvpn::Hash::InitialSeed
select_control_send_context	ssl/proto.hpp	/^    KeyContext& select_control_send_context()$/;"	f	class:openvpn::ProtoContext
select_key_context	ssl/proto.hpp	/^    KeyContext& select_key_context(const PacketType& type, const bool control)$/;"	f	class:openvpn::ProtoContext
self	ssl/tlsprf.hpp	/^    TLSPRF<CRYPTO_API> self;$/;"	m	class:openvpn::CryptoTLSPRFInstance
self_randomize	ssl/tlsprf.hpp	/^    virtual void self_randomize(RandomAPI& rng)$/;"	f	class:openvpn::CryptoTLSPRFInstance
self_write	ssl/tlsprf.hpp	/^    virtual void self_write(Buffer& buf)$/;"	f	class:openvpn::CryptoTLSPRFInstance
send	common/link.hpp	/^    typename SEND::Ptr send;$/;"	m	class:openvpn::Link
send	reliable/relsend.hpp	/^    Message& send(const Time& now, const Time::Duration& tls_timeout)$/;"	f	class:openvpn::ReliableSendTemplate
send	transport/client/httpcli.hpp	/^      bool send(BufferAllocated& buf)$/;"	f	class:openvpn::HTTPProxyTransport::Client
send	transport/client/tcpcli.hpp	/^      bool send(BufferAllocated& buf)$/;"	f	class:openvpn::TCPTransport::Client
send	transport/client/udpcli.hpp	/^      bool send(const Buffer& buf)$/;"	f	class:openvpn::UDPTransport::Client
send	transport/gremlin.hpp	/^      DelayedQueue::Ptr send;$/;"	m	class:openvpn::Gremlin::SendRecvQueue
send	transport/tcplink.hpp	/^      bool send(BufferAllocated& b)$/;"	f	class:openvpn::TCPTransport::Link
send	transport/udplink.hpp	/^      int send(const Buffer& buf, const AsioEndpoint* endpoint)$/;"	f	class:openvpn::UDPTransport::Link
send	tun/builder/client.hpp	/^      bool send(Buffer& buf)$/;"	f	class:openvpn::TunBuilderClient::Client
send	tun/linux/client/tuncli.hpp	/^      bool send(Buffer& buf)$/;"	f	class:openvpn::TunLinux::Client
send	tun/mac/client/tuncli.hpp	/^      bool send(Buffer& buf)$/;"	f	class:openvpn::TunMac::Client
send	tun/win/client/tuncli.hpp	/^      bool send(Buffer& buf)$/;"	f	class:openvpn::TunWin::Client
send_auth	ssl/proto.hpp	/^      void send_auth()$/;"	f	class:openvpn::ProtoContext::KeyContext
send_const	transport/client/httpcli.hpp	/^      bool send_const(const Buffer& cbuf)$/;"	f	class:openvpn::HTTPProxyTransport::Client
send_const	transport/client/tcpcli.hpp	/^      bool send_const(const Buffer& cbuf)$/;"	f	class:openvpn::TCPTransport::Client
send_data_channel_message	ssl/proto.hpp	/^      void send_data_channel_message(const unsigned char *data, const size_t size)$/;"	f	class:openvpn::ProtoContext::KeyContext
send_delay_ms	transport/gremlin.hpp	/^      unsigned int send_delay_ms = 0;$/;"	m	class:openvpn::Gremlin::Config
send_drop_probability	transport/gremlin.hpp	/^      unsigned int send_drop_probability = 0;$/;"	m	class:openvpn::Gremlin::Config
send_explicit_exit_notify	client/cliconnect.hpp	/^    void send_explicit_exit_notify()$/;"	f	class:openvpn::ClientConnect
send_explicit_exit_notify	client/cliproto.hpp	/^      void send_explicit_exit_notify()$/;"	f	class:openvpn::ClientProto::Session
send_explicit_exit_notify	ssl/proto.hpp	/^      void send_explicit_exit_notify()$/;"	f	class:openvpn::ProtoContext::KeyContext
send_explicit_exit_notify	ssl/proto.hpp	/^    void send_explicit_exit_notify()$/;"	f	class:openvpn::ProtoContext
send_keepalive	ssl/proto.hpp	/^      void send_keepalive()$/;"	f	class:openvpn::ProtoContext::KeyContext
send_pending_acks	ssl/protostack.hpp	/^    void send_pending_acks()$/;"	f	class:openvpn::ProtoStackBase
send_push_request_callback	client/cliproto.hpp	/^      void send_push_request_callback(const Time::Duration& dur,$/;"	f	class:openvpn::ClientProto::Session
send_queue	transport/gremlin.hpp	/^      void send_queue(F&& func_arg)$/;"	f	class:openvpn::Gremlin::SendRecvQueue
send_queue_empty	transport/tcplink.hpp	/^      bool send_queue_empty() const$/;"	f	class:openvpn::TCPTransport::Link
send_queue_max_size	transport/tcplink.hpp	/^      const size_t send_queue_max_size;$/;"	m	class:openvpn::TCPTransport::Link
send_queue_size	transport/tcplink.hpp	/^      unsigned int send_queue_size() const$/;"	f	class:openvpn::TCPTransport::Link
send_reset	ssl/proto.hpp	/^      void send_reset()$/;"	f	class:openvpn::ProtoContext::KeyContext
send_size	transport/gremlin.hpp	/^      size_t send_size() const$/;"	f	class:openvpn::Gremlin::SendRecvQueue
sender_endpoint	transport/udplink.hpp	/^      AsioEndpoint sender_endpoint;$/;"	m	struct:openvpn::UDPTransport::PacketFrom
sent_push_request	client/cliproto.hpp	/^      bool sent_push_request = false;$/;"	m	class:openvpn::ClientProto::Session
seq_num	ip/icmp.hpp	/^	std::uint16_t seq_num;$/;"	m	struct:openvpn::ICMP::__anon48::__anon49
server	client/cliopthelper.hpp	/^      std::string server;$/;"	m	struct:openvpn::ParseClientConfig::ServerEntry
serverList	client/cliopthelper.hpp	/^    const ServerList& serverList() const { return serverList_; }$/;"	f	class:openvpn::ParseClientConfig
serverList_	client/cliopthelper.hpp	/^    ServerList serverList_;$/;"	m	class:openvpn::ParseClientConfig
server_	ssl/tlsprf.hpp	/^    bool server_;$/;"	m	class:openvpn::TLSPRF
server_addr	netconf/linux/route.hpp	/^    IP::Addr server_addr;$/;"	m	class:openvpn::RouteListLinux
server_addr_float	client/cliopt.hpp	/^    bool server_addr_float;$/;"	m	class:openvpn::ClientOptions
server_addr_float	transport/client/udpcli.hpp	/^      bool server_addr_float;$/;"	m	class:openvpn::UDPTransport::ClientConfig
server_addr_float	transport/dco.hpp	/^      bool server_addr_float;$/;"	m	struct:openvpn::DCO::TransportConfig
server_auth	server/servproto.hpp	/^      virtual void server_auth(const std::string& username,$/;"	f	class:openvpn::ServerProto::Session
server_auth	ssl/proto.hpp	/^    virtual void server_auth(const std::string& username,$/;"	f	class:openvpn::ProtoContext
server_endpoint	transport/client/httpcli.hpp	/^      LinkImpl::protocol::endpoint server_endpoint;$/;"	m	class:openvpn::HTTPProxyTransport::Client
server_endpoint	transport/client/tcpcli.hpp	/^      LinkImpl::protocol::endpoint server_endpoint;$/;"	m	class:openvpn::TCPTransport::Client
server_endpoint	transport/client/udpcli.hpp	/^      UDPTransport::AsioEndpoint server_endpoint;$/;"	m	class:openvpn::UDPTransport::Client
server_endpoint_addr	transport/client/httpcli.hpp	/^      virtual IP::Addr server_endpoint_addr() const$/;"	f	class:openvpn::HTTPProxyTransport::Client
server_endpoint_addr	transport/client/tcpcli.hpp	/^      virtual IP::Addr server_endpoint_addr() const$/;"	f	class:openvpn::TCPTransport::Client
server_endpoint_addr	transport/client/udpcli.hpp	/^      virtual IP::Addr server_endpoint_addr() const$/;"	f	class:openvpn::UDPTransport::Client
server_endpoint_info	transport/client/httpcli.hpp	/^      virtual void server_endpoint_info(std::string& host, std::string& port, std::string& proto, std::string& ip_addr) const$/;"	f	class:openvpn::HTTPProxyTransport::Client
server_endpoint_info	transport/client/tcpcli.hpp	/^      virtual void server_endpoint_info(std::string& host, std::string& port, std::string& proto, std::string& ip_addr) const$/;"	f	class:openvpn::TCPTransport::Client
server_endpoint_info	transport/client/udpcli.hpp	/^      virtual void server_endpoint_info(std::string& host, std::string& port, std::string& proto, std::string& ip_addr) const$/;"	f	class:openvpn::UDPTransport::Client
server_endpoint_render	client/cliproto.hpp	/^      std::string server_endpoint_render()$/;"	f	class:openvpn::ClientProto::Session
server_gw	server/vpnservnetblock.hpp	/^      IP::Addr server_gw;$/;"	m	struct:openvpn::VPNServerNetblock::Netblock
server_host	client/clievent.hpp	/^      std::string server_host;$/;"	m	struct:openvpn::ClientEvent::Connected
server_host	client/remotelist.hpp	/^      std::string server_host;$/;"	m	struct:openvpn::RemoteList::Item
server_host	transport/client/httpcli.hpp	/^      std::string server_host;$/;"	m	class:openvpn::HTTPProxyTransport::Client
server_host	transport/client/tcpcli.hpp	/^      std::string server_host;$/;"	m	class:openvpn::TCPTransport::Client
server_host	transport/client/udpcli.hpp	/^      std::string server_host;$/;"	m	class:openvpn::UDPTransport::Client
server_ip	client/clievent.hpp	/^      std::string server_ip;$/;"	m	struct:openvpn::ClientEvent::Connected
server_override	client/cliopt.hpp	/^      std::string server_override;$/;"	m	struct:openvpn::ClientOptions::Config
server_override	client/cliopt.hpp	/^    std::string server_override;$/;"	m	class:openvpn::ClientOptions
server_poll_callback	client/cliconnect.hpp	/^    void server_poll_callback(unsigned int gen, const asio::error_code& e)$/;"	f	class:openvpn::ClientConnect
server_poll_timeout	client/cliopt.hpp	/^    Time::Duration server_poll_timeout() const$/;"	f	class:openvpn::ClientOptions
server_poll_timeout_	client/cliopt.hpp	/^    unsigned int server_poll_timeout_;$/;"	m	class:openvpn::ClientOptions
server_poll_timeout_enabled	client/cliopt.hpp	/^    bool server_poll_timeout_enabled() const$/;"	f	class:openvpn::ClientOptions
server_poll_timer	client/cliconnect.hpp	/^    AsioTimer server_poll_timer;$/;"	m	class:openvpn::ClientConnect
server_port	client/clievent.hpp	/^      std::string server_port;$/;"	m	struct:openvpn::ClientEvent::Connected
server_port	client/remotelist.hpp	/^      std::string server_port;$/;"	m	struct:openvpn::RemoteList::Item
server_port	transport/client/httpcli.hpp	/^      std::string server_port;$/;"	m	class:openvpn::HTTPProxyTransport::Client
server_port	transport/client/tcpcli.hpp	/^      std::string server_port;$/;"	m	class:openvpn::TCPTransport::Client
server_port	transport/client/udpcli.hpp	/^      std::string server_port;$/;"	m	class:openvpn::UDPTransport::Client
server_proto	client/clievent.hpp	/^      std::string server_proto;$/;"	m	struct:openvpn::ClientEvent::Connected
servlist	common/runcontext.hpp	/^    std::vector<ServerThread*> servlist;$/;"	m	class:openvpn::RunContext
session_id_defined	client/clicreds.hpp	/^    bool session_id_defined() const$/;"	f	class:openvpn::ClientCreds
session_name	tun/builder/capture.hpp	/^    std::string session_name;$/;"	m	class:openvpn::TunBuilderCapture
session_name	tun/client/tunprop.hpp	/^      std::string session_name;$/;"	m	struct:openvpn::TunProp::Config
session_stats_set_verbose	log/sessionstats.hpp	/^    void session_stats_set_verbose(const bool v) { verbose_ = v; }$/;"	f	class:openvpn::SessionStats
set_async_stop	common/runcontext.hpp	/^    void set_async_stop(Stop* async_stop)$/;"	f	class:openvpn::RunContext
set_bit	addr/ipv6.hpp	/^      void set_bit(unsigned int pos, bool value)$/;"	f	class:openvpn::IPv6::Addr
set_cipher	crypto/cryptodc.hpp	/^    void set_cipher(const CryptoAlgs::Type cipher)$/;"	f	class:openvpn::CryptoDCSettings
set_clear_bit	addr/ipv6.hpp	/^      void set_clear_bit(unsigned int pos, bool value)$/;"	f	class:openvpn::IPv6::Addr
set_cloexec	common/asiopolysock.hpp	/^      virtual void set_cloexec() {}$/;"	f	class:openvpn::AsioPolySock::Base
set_cloexec	common/sockopt.hpp	/^    inline void set_cloexec(const int fd)$/;"	f	namespace:openvpn::SockOpt
set_code	error/excode.hpp	/^    void set_code(const Error::Type code)$/;"	f	class:openvpn::ExceptionCode
set_code	error/excode.hpp	/^    void set_code(const Error::Type code, const bool fatal)$/;"	f	class:openvpn::ExceptionCode
set_debug_level	applecrypto/ssl/sslctx.hpp	/^      virtual void set_debug_level(const int debug_level)$/;"	f	class:openvpn::AppleSSLContext::Config
set_debug_level	openssl/ssl/sslctx.hpp	/^      virtual void set_debug_level(const int debug_level)$/;"	f	class:openvpn::OpenSSLContext::Config
set_debug_level	polarssl/ssl/sslctx.hpp	/^      virtual void set_debug_level(const int debug_level)$/;"	f	class:openvpn::PolarSSLContext::Config
set_default_context	frame/frame.hpp	/^    void set_default_context(const Context& c)$/;"	f	class:openvpn::Frame
set_digest	crypto/cryptodc.hpp	/^    void set_digest(const CryptoAlgs::Type digest)$/;"	f	class:openvpn::CryptoDCSettings
set_disconnect	tun/client/tunnull.hpp	/^      virtual void set_disconnect()$/;"	f	class:openvpn::TunNull::Client
set_disconnect	tun/linux/client/tuncli.hpp	/^      virtual void set_disconnect()$/;"	f	class:openvpn::TunLinux::Client
set_disconnect	tun/persist/tunpersist.hpp	/^    void set_disconnect()$/;"	f	class:openvpn::TunPersistTemplate
set_duration_parm	time/durhelper.hpp	/^  inline void set_duration_parm(Time::Duration& dur,$/;"	f	namespace:openvpn
set_dynamic_challenge_cookie	client/clicreds.hpp	/^    void set_dynamic_challenge_cookie(const std::string& cookie, const std::string& username)$/;"	f	class:openvpn::ClientCreds
set_emulate_exclude_routes	client/ipverflags.hpp	/^    void set_emulate_exclude_routes()$/;"	f	class:openvpn::IPVerFlags
set_enable_cache	client/remotelist.hpp	/^    void set_enable_cache(const bool enable_cache_arg)$/;"	f	class:openvpn::RemoteList
set_enable_renegotiation	applecrypto/ssl/sslctx.hpp	/^      virtual void set_enable_renegotiation(const bool v)$/;"	f	class:openvpn::AppleSSLContext::Config
set_enable_renegotiation	openssl/ssl/sslctx.hpp	/^      virtual void set_enable_renegotiation(const bool v)$/;"	f	class:openvpn::OpenSSLContext::Config
set_enable_renegotiation	polarssl/ssl/sslctx.hpp	/^      virtual void set_enable_renegotiation(const bool v)$/;"	f	class:openvpn::PolarSSLContext::Config
set_endpoint_range	client/remotelist.hpp	/^      void set_endpoint_range(EPRANGE& endpoint_range, RandomAPI* rng)$/;"	f	struct:openvpn::RemoteList::Item
set_endpoint_range	client/remotelist.hpp	/^    void set_endpoint_range(EPRANGE& endpoint_range)$/;"	f	class:openvpn::RemoteList
set_errtxt	applecrypto/cf/error.hpp	/^    void set_errtxt(const std::string& text, const OSStatus status)$/;"	f	class:openvpn::CFException
set_event	ssl/proto.hpp	/^      void set_event(const EventType current)$/;"	f	class:openvpn::ProtoContext::KeyContext
set_event	ssl/proto.hpp	/^      void set_event(const EventType current, const EventType next, const Time& next_time)$/;"	f	class:openvpn::ProtoContext::KeyContext
set_exit_socket	common/runcontext.hpp	/^    void set_exit_socket(ScopedFD& fd)$/;"	f	class:openvpn::RunContext
set_external_pki_callback	applecrypto/ssl/sslctx.hpp	/^      virtual void set_external_pki_callback(ExternalPKIBase* external_pki_arg)$/;"	f	class:openvpn::AppleSSLContext::Config
set_external_pki_callback	openssl/ssl/sslctx.hpp	/^      virtual void set_external_pki_callback(ExternalPKIBase* external_pki_arg)$/;"	f	class:openvpn::OpenSSLContext::Config
set_external_pki_callback	polarssl/ssl/sslctx.hpp	/^      virtual void set_external_pki_callback(ExternalPKIBase* external_pki_arg)$/;"	f	class:openvpn::PolarSSLContext::Config
set_factory	crypto/cryptodc.hpp	/^    void set_factory(const CryptoDCFactory::Ptr& factory)$/;"	f	class:openvpn::CryptoDCSettings
set_flags	applecrypto/ssl/sslctx.hpp	/^      virtual void set_flags(const unsigned int flags_arg)$/;"	f	class:openvpn::AppleSSLContext::Config
set_flags	openssl/ssl/sslctx.hpp	/^      virtual void set_flags(const unsigned int flags_arg)$/;"	f	class:openvpn::OpenSSLContext::Config
set_flags	polarssl/ssl/sslctx.hpp	/^      virtual void set_flags(const unsigned int flags_arg)$/;"	f	class:openvpn::PolarSSLContext::Config
set_force_aes_cbc_ciphersuites	applecrypto/ssl/sslctx.hpp	/^      virtual void set_force_aes_cbc_ciphersuites(const bool v)$/;"	f	class:openvpn::AppleSSLContext::Config
set_force_aes_cbc_ciphersuites	openssl/ssl/sslctx.hpp	/^      virtual void set_force_aes_cbc_ciphersuites(const bool v)$/;"	f	class:openvpn::OpenSSLContext::Config
set_force_aes_cbc_ciphersuites	polarssl/ssl/sslctx.hpp	/^      virtual void set_force_aes_cbc_ciphersuites(const bool v)$/;"	f	class:openvpn::PolarSSLContext::Config
set_frame	applecrypto/ssl/sslctx.hpp	/^      virtual void set_frame(const Frame::Ptr& frame_arg)$/;"	f	class:openvpn::AppleSSLContext::Config
set_frame	frame/memq_dgram.hpp	/^    void set_frame(const Frame::Ptr& frame) { frame_ = frame; }$/;"	f	class:openvpn::MemQDgram
set_frame	frame/memq_stream.hpp	/^    void set_frame(const Frame::Ptr& frame) { frame_ = frame; }$/;"	f	class:openvpn::MemQStream
set_frame	openssl/ssl/sslctx.hpp	/^      virtual void set_frame(const Frame::Ptr& frame_arg)$/;"	f	class:openvpn::OpenSSLContext::Config
set_frame	polarssl/ssl/sslctx.hpp	/^      virtual void set_frame(const Frame::Ptr& frame_arg)$/;"	f	class:openvpn::PolarSSLContext::Config
set_fwmark	server/servproto.hpp	/^      virtual void set_fwmark(const unsigned int fwmark)$/;"	f	class:openvpn::ServerProto::Session
set_housekeeping_timer	client/cliproto.hpp	/^      void set_housekeeping_timer()$/;"	f	class:openvpn::ClientProto::Session
set_housekeeping_timer	server/servproto.hpp	/^      void set_housekeeping_timer()$/;"	f	class:openvpn::ServerProto::Session
set_infinite	time/time.hpp	/^      void set_infinite() { duration_ = std::numeric_limits<T>::max(); }$/;"	f	class:openvpn::TimeType::Duration
set_infinite	time/time.hpp	/^    void set_infinite() { time_ = std::numeric_limits<T>::max(); }$/;"	f	class:openvpn::TimeType
set_ip_addr	client/remotelist.hpp	/^      void set_ip_addr(const IP::Addr& addr)$/;"	f	struct:openvpn::RemoteList::Item
set_limit	common/pthreadcond.hpp	/^    void set_limit(const int new_limit)$/;"	f	class:openvpn::PThreadBarrier
set_local_cert_enabled	applecrypto/ssl/sslctx.hpp	/^      virtual void set_local_cert_enabled(const bool v)$/;"	f	class:openvpn::AppleSSLContext::Config
set_local_cert_enabled	openssl/ssl/sslctx.hpp	/^      virtual void set_local_cert_enabled(const bool v)$/;"	f	class:openvpn::OpenSSLContext::Config
set_local_cert_enabled	polarssl/ssl/sslctx.hpp	/^      virtual void set_local_cert_enabled(const bool v)$/;"	f	class:openvpn::PolarSSLContext::Config
set_local_peer_id	ssl/proto.hpp	/^    void set_local_peer_id(const int local_peer_id)$/;"	f	class:openvpn::ProtoContext
set_max	buffer/buflimit.hpp	/^    void set_max(const T max_lines_arg,$/;"	f	class:openvpn::BufferLimit
set_mem	compress/lzoasym_impl.hpp	/^    inline T set_mem(void *p, const T value)$/;"	f	namespace:openvpn::lzo_asym_impl
set_mode	applecrypto/ssl/sslctx.hpp	/^      virtual void set_mode(const Mode& mode_arg)$/;"	f	class:openvpn::AppleSSLContext::Config
set_mode	openssl/ssl/sslctx.hpp	/^      virtual void set_mode(const Mode& mode_arg)$/;"	f	class:openvpn::OpenSSLContext::Config
set_mode	polarssl/ssl/sslctx.hpp	/^      virtual void set_mode(const Mode& mode_arg)$/;"	f	class:openvpn::PolarSSLContext::Config
set_mtu	openssl/bio/bio_memq_dgram.hpp	/^      void set_mtu(long mtu) { query_mtu_return = mtu; }$/;"	f	class:openvpn::bmq_dgram::MemQ
set_mutate	transport/tcplink.hpp	/^      void set_mutate(const TransportMutateStream::Ptr& mutate_arg)$/;"	f	class:openvpn::TCPTransport::Link
set_next_event_if_unspecified	ssl/proto.hpp	/^      void set_next_event_if_unspecified()$/;"	f	class:openvpn::ProtoContext::KeyContext
set_ns_cert_type	applecrypto/ssl/sslctx.hpp	/^      virtual void set_ns_cert_type(const NSCert::Type ns_cert_type_arg)$/;"	f	class:openvpn::AppleSSLContext::Config
set_ns_cert_type	openssl/ssl/sslctx.hpp	/^      virtual void set_ns_cert_type(const NSCert::Type ns_cert_type_arg)$/;"	f	class:openvpn::OpenSSLContext::Config
set_ns_cert_type	polarssl/ssl/sslctx.hpp	/^      virtual void set_ns_cert_type(const NSCert::Type ns_cert_type_arg)$/;"	f	class:openvpn::PolarSSLContext::Config
set_password	client/clicreds.hpp	/^    void set_password(const std::string& password_arg)$/;"	f	class:openvpn::ClientCreds
set_pid_mode	ssl/proto.hpp	/^      void set_pid_mode(const bool tcp_linear)$/;"	f	class:openvpn::ProtoContext::Config
set_prefix	common/runcontext.hpp	/^    void set_prefix(const std::string& pre)$/;"	f	class:openvpn::RunContext
set_private_key_password	applecrypto/ssl/sslctx.hpp	/^      virtual void set_private_key_password(const std::string& pwd)$/;"	f	class:openvpn::AppleSSLContext::Config
set_private_key_password	openssl/pki/pkey.hpp	/^      void set_private_key_password(const std::string& pwd)$/;"	f	class:openvpn::OpenSSLPKI::PKey
set_private_key_password	openssl/ssl/sslctx.hpp	/^      virtual void set_private_key_password(const std::string& pwd)$/;"	f	class:openvpn::OpenSSLContext::Config
set_private_key_password	polarssl/ssl/sslctx.hpp	/^      virtual void set_private_key_password(const std::string& pwd)$/;"	f	class:openvpn::PolarSSLContext::Config
set_proto_override	client/remotelist.hpp	/^    void set_proto_override(const Protocol& proto_override)$/;"	f	class:openvpn::RemoteList
set_protocol	ssl/proto.hpp	/^      void set_protocol(const Protocol& p)$/;"	f	class:openvpn::ProtoContext::Config
set_proxy_server	transport/client/httpcli.hpp	/^      void set_proxy_server(const std::string& host, const std::string& port)$/;"	f	class:openvpn::HTTPProxyTransport::Options
set_random	client/remotelist.hpp	/^    void set_random(const RandomAPI::Ptr& rng_arg)$/;"	f	class:openvpn::RemoteList
set_raw_mode	transport/tcplink.hpp	/^      void set_raw_mode(const bool mode)$/;"	f	class:openvpn::TCPTransport::Link
set_raw_mode_read	transport/tcplink.hpp	/^      void set_raw_mode_read(const bool mode)$/;"	f	class:openvpn::TCPTransport::Link
set_raw_mode_write	transport/tcplink.hpp	/^      void set_raw_mode_write(const bool mode)$/;"	f	class:openvpn::TCPTransport::Link
set_remote_cert_tls	applecrypto/ssl/sslctx.hpp	/^      virtual void set_remote_cert_tls(const KUParse::TLSWebType wt)$/;"	f	class:openvpn::AppleSSLContext::Config
set_remote_cert_tls	openssl/ssl/sslctx.hpp	/^      virtual void set_remote_cert_tls(const KUParse::TLSWebType wt)$/;"	f	class:openvpn::OpenSSLContext::Config
set_remote_cert_tls	polarssl/ssl/sslctx.hpp	/^      virtual void set_remote_cert_tls(const KUParse::TLSWebType wt)$/;"	f	class:openvpn::PolarSSLContext::Config
set_replace_password_with_session_id	client/clicreds.hpp	/^    void set_replace_password_with_session_id(const bool value)$/;"	f	class:openvpn::ClientCreds
set_response	client/clicreds.hpp	/^    void set_response(const std::string& response_arg)$/;"	f	class:openvpn::ClientCreds
set_rng	applecrypto/ssl/sslctx.hpp	/^      virtual void set_rng(const RandomAPI::Ptr& rng_arg)$/;"	f	class:openvpn::AppleSSLContext::Config
set_rng	openssl/ssl/sslctx.hpp	/^      virtual void set_rng(const RandomAPI::Ptr& rng_arg)$/;"	f	class:openvpn::OpenSSLContext::Config
set_rng	polarssl/ssl/sslctx.hpp	/^      virtual void set_rng(const RandomAPI::Ptr& rng_arg)$/;"	f	class:openvpn::PolarSSLContext::Config
set_server	common/runcontext.hpp	/^    void set_server(const unsigned int unit, ServerThread* serv)$/;"	f	class:openvpn::RunContext
set_server_override	client/remotelist.hpp	/^    void set_server_override(const std::string& server_override)$/;"	f	class:openvpn::RemoteList
set_service_fail_handler	tun/win/client/setupbase.hpp	/^      virtual void set_service_fail_handler(std::function<void()>&& handler)$/;"	f	struct:openvpn::TunWin::SetupBase
set_session_id	client/clicreds.hpp	/^    void set_session_id(const std::string& user, const std::string& sess_id)$/;"	f	class:openvpn::ClientCreds
set_size	buffer/buffer.hpp	/^    void set_size(const size_t size)$/;"	f	class:openvpn::BufferType
set_state	ssl/proto.hpp	/^      void set_state(const int newstate)$/;"	f	class:openvpn::ProtoContext::KeyContext
set_stats_obj	common/runcontext.hpp	/^    void set_stats_obj(const typename Stats::Ptr& stats_arg)$/;"	f	class:openvpn::RunContext
set_tail	crypto/crypto_aead.hpp	/^	void set_tail(const StaticKey& sk)$/;"	f	class:openvpn::AEAD::Crypto::Nonce
set_thread	common/runcontext.hpp	/^    void set_thread(const unsigned int unit, std::thread* thread)$/;"	f	class:openvpn::RunContext
set_timer	transport/gremlin.hpp	/^      void set_timer()$/;"	f	struct:openvpn::Gremlin::DelayedQueue
set_tls_auth_digest	ssl/proto.hpp	/^      void set_tls_auth_digest(const CryptoAlgs::Type digest)$/;"	f	class:openvpn::ProtoContext::Config
set_tls_remote	applecrypto/ssl/sslctx.hpp	/^      virtual void set_tls_remote(const std::string& tls_remote_arg)$/;"	f	class:openvpn::AppleSSLContext::Config
set_tls_remote	openssl/ssl/sslctx.hpp	/^      virtual void set_tls_remote(const std::string& tls_remote_arg)$/;"	f	class:openvpn::OpenSSLContext::Config
set_tls_remote	polarssl/ssl/sslctx.hpp	/^      virtual void set_tls_remote(const std::string& tls_remote_arg)$/;"	f	class:openvpn::PolarSSLContext::Config
set_tls_version_min	applecrypto/ssl/sslctx.hpp	/^      virtual void set_tls_version_min(const TLSVersion::Type tvm)$/;"	f	class:openvpn::AppleSSLContext::Config
set_tls_version_min	openssl/ssl/sslctx.hpp	/^      virtual void set_tls_version_min(const TLSVersion::Type tvm)$/;"	f	class:openvpn::OpenSSLContext::Config
set_tls_version_min	polarssl/ssl/sslctx.hpp	/^      virtual void set_tls_version_min(const TLSVersion::Type tvm)$/;"	f	class:openvpn::PolarSSLContext::Config
set_tls_version_min_override	openssl/ssl/sslctx.hpp	/^      virtual void set_tls_version_min_override(const std::string& override)$/;"	f	class:openvpn::OpenSSLContext::Config
set_tls_version_min_override	polarssl/ssl/sslctx.hpp	/^      virtual void set_tls_version_min_override(const std::string& override)$/;"	f	class:openvpn::PolarSSLContext::Config
set_trailer	buffer/buffer.hpp	/^    void set_trailer(const T& value)$/;"	f	class:openvpn::BufferType
set_username	client/clicreds.hpp	/^    void set_username(const std::string& username_arg)$/;"	f	class:openvpn::ClientCreds
set_x509_track	openssl/ssl/sslctx.hpp	/^      virtual void set_x509_track(X509Track::ConfigSet x509_track_config_arg)$/;"	f	class:openvpn::OpenSSLContext::Config
set_x509_track	polarssl/ssl/sslctx.hpp	/^      virtual void set_x509_track(X509Track::ConfigSet x509_track_config_arg)$/;"	f	class:openvpn::PolarSSLContext::Config
set_xmit_creds	ssl/proto.hpp	/^      void set_xmit_creds(const bool xmit_creds_arg)$/;"	f	class:openvpn::ProtoContext::Config
set_zero	time/time.hpp	/^      void set_zero() { duration_ = T(0); }$/;"	f	class:openvpn::TimeType::Duration
setdns	tun/mac/macdns.hpp	/^    bool setdns(const Config& config)$/;"	f	class:openvpn::MacDNS
setdns	tun/mac/macdns_watchdog.hpp	/^    bool setdns(const MacDNS::Config::Ptr& config, const unsigned int flags)$/;"	f	class:openvpn::MacDNSWatchdog
setup_methods	common/function.hpp	/^    void setup_methods()$/;"	f	class:openvpn::Function
shiftl128	addr/ipv6.hpp	/^      static void shiftl128(std::uint64_t& low,$/;"	f	class:openvpn::IPv6::Addr
shiftr128	addr/ipv6.hpp	/^      static void shiftr128(std::uint64_t& low,$/;"	f	class:openvpn::IPv6::Addr
show	applecrypto/cf/cf.hpp	/^      void show() const$/;"	f	class:openvpn::CF::Wrap
show_options	ssl/proto.hpp	/^      std::string show_options() const$/;"	f	class:openvpn::ProtoContext::Config
siaddr	ip/dhcp.hpp	/^    std::uint32_t siaddr;     \/* server IP address *\/$/;"	m	struct:openvpn::DHCP
sigact	common/signal.hpp	/^    static void sigact(struct sigaction& sa, const int sig)$/;"	f	class:openvpn::Signal
sigconf	common/signal.hpp	/^    static void sigconf(struct sigaction& sa, const unsigned int flags)$/;"	f	class:openvpn::Signal
signal	common/pthreadcond.hpp	/^    void signal()$/;"	f	class:openvpn::PThreadBarrier
signal	common/runcontext.hpp	/^    void signal(const asio::error_code& error, int signum)$/;"	f	class:openvpn::RunContext
signal_	common/pthreadcond.hpp	/^    void signal_(const State newstate)$/;"	f	class:openvpn::PThreadBarrier
signal_network_reconfiguration	tun/mac/macdns.hpp	/^    bool signal_network_reconfiguration()$/;"	f	class:openvpn::MacDNS
signal_rearm	common/runcontext.hpp	/^    void signal_rearm()$/;"	f	class:openvpn::RunContext
signals	common/runcontext.hpp	/^    ASIOSignals::Ptr signals;$/;"	m	class:openvpn::RunContext
signals_	common/asiosignal.hpp	/^    asio::signal_set signals_;$/;"	m	class:openvpn::ASIOSignals
signed_base_type	addr/ipv4.hpp	/^      typedef std::int32_t signed_base_type;$/;"	t	class:openvpn::IPv4::Addr
similar	time/coarsetime.hpp	/^    bool similar(const Time& t) const$/;"	f	class:openvpn::CoarseTime
singleton	options/continuation.hpp	/^    OptionList singleton;$/;"	m	struct:openvpn::PushOptionsBase
singular_arg	common/options.hpp	/^      static bool singular_arg(const std::string& key)$/;"	f	class:openvpn::OptionList::KeyValue
size	addr/addrpair.hpp	/^	size_t size() const { return size_; }$/;"	f	class:openvpn::IP::AddrMaskPair::StringPair
size	addr/ip.hpp	/^      unsigned int size() const$/;"	f	class:openvpn::IP::Addr
size	addr/ipv4.hpp	/^      static unsigned int size()$/;"	f	class:openvpn::IPv4::Addr
size	addr/ipv6.hpp	/^      static unsigned int size()$/;"	f	class:openvpn::IPv6::Addr
size	applecrypto/crypto/digest.hpp	/^      size_t size() const { return CryptoAlgs::size(type_); }$/;"	f	class:openvpn::AppleCrypto::DigestInfo
size	applecrypto/crypto/digest.hpp	/^      size_t size() const$/;"	f	class:openvpn::AppleCrypto::DigestContext
size	applecrypto/crypto/hmac.hpp	/^      size_t size() const$/;"	f	class:openvpn::AppleCrypto::HMACContext
size	buffer/asiobuf.hpp	/^    const size_t size() const$/;"	f	class:openvpn::AsioConstBufferSeq2
size	buffer/bufcomposed.hpp	/^    size_t size() const$/;"	f	class:openvpn::BufferComposed
size	buffer/buffer.hpp	/^    size_t size() const { return size_; }$/;"	f	class:openvpn::BufferType
size	buffer/memq.hpp	/^    size_t size() const$/;"	f	class:openvpn::MemQBase
size	client/remotelist.hpp	/^    size_t size() const { return list.size(); }$/;"	f	class:openvpn::RemoteList
size	common/base64.hpp	/^      size_t size() const { return size_; }$/;"	f	class:openvpn::Base64::UCharWrap
size	common/circ_list.hpp	/^    size_t size() const$/;"	f	class:openvpn::CircList
size	common/glob.hpp	/^    size_t size() const$/;"	f	class:openvpn::Glob
size	common/options.hpp	/^    size_t size() const { return data.size(); }$/;"	f	class:openvpn::Option
size	common/splitlines.hpp	/^    size_t size;$/;"	m	class:openvpn::SplitLinesType
size	common/unicode.hpp	/^      unsigned int size;$/;"	m	class:openvpn::Unicode::UTF8Iterator
size	crypto/cryptoalgs.hpp	/^      size_t size() const { return size_; }              \/\/ digest size$/;"	f	class:openvpn::CryptoAlgs::Alg
size	crypto/cryptoalgs.hpp	/^    inline size_t size(const Type type)$/;"	f	namespace:openvpn::CryptoAlgs
size	crypto/digestapi.hpp	/^    size_t size() const$/;"	f	class:openvpn::CryptoHMACInstance
size	crypto/digestapi.hpp	/^    virtual size_t size() const$/;"	f	class:openvpn::CryptoDigestContext
size	crypto/digestapi.hpp	/^    virtual size_t size() const$/;"	f	class:openvpn::CryptoDigestInstance
size	crypto/ovpnhmac.hpp	/^    virtual size_t size() const$/;"	f	class:openvpn::CryptoOvpnHMACContext
size	crypto/packet_id.hpp	/^    static size_t size(const int form)$/;"	f	struct:openvpn::PacketID
size	crypto/static_key.hpp	/^    size_t size() const { return key_data_.size(); }$/;"	f	class:openvpn::StaticKey
size	openssl/crypto/digest.hpp	/^      size_t size() const$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
size	openssl/crypto/hmac.hpp	/^      size_t size() const$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
size	polarssl/crypto/digest.hpp	/^      size_t size() const$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
size	polarssl/crypto/hmac.hpp	/^      size_t size() const$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
size	reliable/relack.hpp	/^    size_t size() const        { return data.size(); }$/;"	f	class:openvpn::ReliableAck
size	server/vpnservnetblock.hpp	/^    const size_t size() const { return thr.size(); }$/;"	f	class:openvpn::VPNServerNetblock
size	transport/gremlin.hpp	/^      size_t size() const$/;"	f	struct:openvpn::Gremlin::DelayedQueue
size_	addr/addrpair.hpp	/^	unsigned int size_;$/;"	m	class:openvpn::IP::AddrMaskPair::StringPair
size_	buffer/buffer.hpp	/^    size_t size_;      \/\/ number of T objects in array starting at data_ + offset_$/;"	m	class:openvpn::BufferType
size_	common/base64.hpp	/^      size_t size_;$/;"	m	class:openvpn::Base64::UCharWrap
size_	crypto/cryptoalgs.hpp	/^      unsigned int size_;$/;"	m	class:openvpn::CryptoAlgs::Alg
size_	openssl/crypto/hmac.hpp	/^      size_t size_() const$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
size_	polarssl/crypto/digest.hpp	/^      size_t size_() const$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
size_	polarssl/crypto/hmac.hpp	/^      size_t size_() const$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
size_defined	transport/pktstream.hpp	/^    static bool size_defined(const Buffer& buf)$/;"	f	class:openvpn::PacketStream
size_type	ssl/datalimit.hpp	/^    typedef unsigned int size_type;$/;"	t	class:openvpn::DataLimit
skew_duration	time/durhelper.hpp	/^  inline Time::Duration skew_duration(const Time::Duration& dur,$/;"	f	namespace:openvpn
skip_html	transport/client/httpcli.hpp	/^      bool skip_html;$/;"	m	class:openvpn::HTTPProxyTransport::ClientConfig
skip_string	ssl/proto.hpp	/^    static unsigned char *skip_string(Buffer& buf)$/;"	f	class:openvpn::ProtoContext
sleep	apple/maclife.hpp	/^      bool sleep;$/;"	m	struct:openvpn::MacLifeCycle::State
sleep_milliseconds	common/sleep.hpp	/^  inline bool sleep_milliseconds(const unsigned int milliseconds)$/;"	f	namespace:openvpn
slice	crypto/static_key.hpp	/^    StaticKey slice(unsigned int key_specifier) const$/;"	f	class:openvpn::OpenVPNStaticKey
slowest_handshake	ssl/proto.hpp	/^    const Time::Duration& slowest_handshake() { return slowest_handshake_; }$/;"	f	class:openvpn::ProtoContext
slowest_handshake_	ssl/proto.hpp	/^    Time::Duration slowest_handshake_; \/\/ longest time to reach a successful handshake$/;"	m	class:openvpn::ProtoContext
sn	auth/authcert.hpp	/^      long sn;                       \/\/ serial number$/;"	m	struct:openvpn::AuthCert
sname	ip/dhcp.hpp	/^    std::uint8_t  sname[64];  \/* optional server host name *\/$/;"	m	struct:openvpn::DHCP
sname	tun/mac/macdns.hpp	/^      const std::string sname;$/;"	m	class:openvpn::MacDNS::DSDict
sname	tun/mac/macdns.hpp	/^    const std::string sname;$/;"	m	class:openvpn::MacDNS
snb4	server/vpnservnetblock.hpp	/^    Netblock snb4;$/;"	m	class:openvpn::VPNServerNetblock
snb6	server/vpnservnetblock.hpp	/^    Netblock snb6;$/;"	m	class:openvpn::VPNServerNetblock
sockaddr_defined	addr/ip.hpp	/^      static bool sockaddr_defined(const struct sockaddr *sa)$/;"	f	class:openvpn::IP::Addr
socket	common/asiopolysock.hpp	/^      asio::ip::tcp::socket socket;$/;"	m	struct:openvpn::AsioPolySock::TCP
socket	common/asiopolysock.hpp	/^      asio::local::stream_protocol::socket socket;$/;"	m	struct:openvpn::AsioPolySock::Unix
socket	transport/client/httpcli.hpp	/^      asio::ip::tcp::socket socket;$/;"	m	class:openvpn::HTTPProxyTransport::Client
socket	transport/client/tcpcli.hpp	/^      asio::ip::tcp::socket socket;$/;"	m	class:openvpn::TCPTransport::Client
socket	transport/client/udpcli.hpp	/^      asio::ip::udp::socket socket;$/;"	m	class:openvpn::UDPTransport::Client
socket	transport/tcplink.hpp	/^      typename Protocol::socket& socket;$/;"	m	class:openvpn::TCPTransport::Link
socket	transport/udplink.hpp	/^      asio::ip::udp::socket& socket;$/;"	m	class:openvpn::UDPTransport::Link
socket_protect	client/cliopt.hpp	/^      SocketProtect* socket_protect = nullptr;$/;"	m	struct:openvpn::ClientOptions::Config
socket_protect	client/cliopt.hpp	/^    SocketProtect* socket_protect;$/;"	m	class:openvpn::ClientOptions
socket_protect	transport/altproxy.hpp	/^      SocketProtect* socket_protect;$/;"	m	struct:openvpn::AltProxy::Config
socket_protect	transport/client/httpcli.hpp	/^      SocketProtect* socket_protect;$/;"	m	class:openvpn::HTTPProxyTransport::ClientConfig
socket_protect	transport/client/tcpcli.hpp	/^      SocketProtect* socket_protect;$/;"	m	class:openvpn::TCPTransport::ClientConfig
socket_protect	transport/client/udpcli.hpp	/^      SocketProtect* socket_protect;$/;"	m	class:openvpn::UDPTransport::ClientConfig
sort	common/options.hpp	/^      void sort()$/;"	f	struct:openvpn::OptionList::KeyValueList
source	ip/udp.hpp	/^    std::uint16_t   source;$/;"	m	struct:openvpn::UDPHeader
sourceExhausted	common/unicode-impl.hpp	/^      sourceExhausted, \/* partial character in source, but hit end *\/$/;"	e	enum:openvpn::Unicode::__anon25
sourceIllegal	common/unicode-impl.hpp	/^      sourceIllegal  \/* source sequence is illegal\/malformed *\/$/;"	e	enum:openvpn::Unicode::__anon25
space_before_header_value	http/reply.hpp	/^	  space_before_header_value,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
space_before_header_value	http/request.hpp	/^	  space_before_header_value,$/;"	e	enum:openvpn::HTTP::RequestParser::state
spaces	common/string.hpp	/^    inline std::string spaces(int n)$/;"	f	namespace:openvpn::string
span	common/msgwin.hpp	/^    id_t span() const { return span_; }$/;"	f	class:openvpn::MessageWindow
span	reliable/relsend.hpp	/^    id_t span() const { return window_.span(); }$/;"	f	class:openvpn::ReliableSendTemplate
span_	common/msgwin.hpp	/^    id_t span_;$/;"	m	class:openvpn::MessageWindow
specified	addr/ip.hpp	/^      bool specified() const$/;"	f	class:openvpn::IP::Addr
specified	addr/ipv4.hpp	/^      bool specified() const$/;"	f	class:openvpn::IPv4::Addr
specified	addr/ipv6.hpp	/^      bool specified() const$/;"	f	class:openvpn::IPv6::Addr
split	addr/route.hpp	/^      bool split(RouteType& r1, RouteType& r2) const \/\/ assumes we are canonical$/;"	f	struct:openvpn::IP::RouteType
split	common/string.hpp	/^    inline std::vector<std::string> split(const std::string& str,$/;"	f	namespace:openvpn::string
split_domain_username	proxy/ntlm.hpp	/^      static void split_domain_username(const std::string& combined, std::string& domain, std::string& username)$/;"	f	class:openvpn::HTTPProxy::NTLM
split_host_port	common/hostport.hpp	/^    inline bool split_host_port(const std::string& str,$/;"	f	namespace:openvpn::HostPort
split_priority	common/options.hpp	/^      void split_priority()$/;"	f	class:openvpn::OptionList::KeyValue
split_priority	common/options.hpp	/^      void split_priority()$/;"	f	struct:openvpn::OptionList::KeyValueList
src_mac	ip/eth.hpp	/^    std::uint8_t   src_mac[6];$/;"	m	struct:openvpn::EthHeader
ssize_t	common/size.hpp	/^typedef SSIZE_T ssize_t;$/;"	t
ssl	applecrypto/ssl/sslctx.hpp	/^      SSLContextRef ssl; \/\/ underlying SSL connection object$/;"	m	class:openvpn::AppleSSLContext::SSL
ssl	applecrypto/ssl/sslctx.hpp	/^    virtual SSLAPI::Ptr ssl()$/;"	f	class:openvpn::AppleSSLContext
ssl	applecrypto/ssl/sslctx.hpp	/^    virtual SSLAPI::Ptr ssl(const std::string& hostname)$/;"	f	class:openvpn::AppleSSLContext
ssl	openssl/ssl/sslctx.hpp	/^      ::SSL *ssl;	   \/\/ OpenSSL SSL object$/;"	m	class:openvpn::OpenSSLContext::SSL
ssl	openssl/ssl/sslctx.hpp	/^    virtual SSLAPI::Ptr ssl()$/;"	f	class:openvpn::OpenSSLContext
ssl	openssl/ssl/sslctx.hpp	/^    virtual SSLAPI::Ptr ssl(const std::string& hostname)$/;"	f	class:openvpn::OpenSSLContext
ssl	polarssl/ssl/sslctx.hpp	/^      ssl_context *ssl;	       \/\/ underlying SSL connection object$/;"	m	class:openvpn::PolarSSLContext::SSL
ssl	polarssl/ssl/sslctx.hpp	/^    virtual SSLAPI::Ptr ssl()$/;"	f	class:openvpn::PolarSSLContext
ssl	polarssl/ssl/sslctx.hpp	/^    virtual SSLAPI::Ptr ssl(const std::string& hostname)$/;"	f	class:openvpn::PolarSSLContext
ssl	server/listenlist.hpp	/^      SSLMode ssl = SSLUnspecified;$/;"	m	struct:openvpn::Listen::Item
ssl23_method_client	openssl/ssl/sslctx.hpp	/^      static const SSL_METHOD* ssl23_method_client()$/;"	f	class:openvpn::OpenSSLContext::SSL
ssl23_method_client_	openssl/ssl/sslctx.hpp	/^      static SSL_METHOD ssl23_method_client_;$/;"	m	class:openvpn::OpenSSLContext::SSL
ssl23_method_client_	openssl/ssl/sslctx.hpp	/^  SSL_METHOD OpenSSLContext::SSL::ssl23_method_client_;$/;"	m	class:openvpn::OpenSSLContext::SSL
ssl23_method_server	openssl/ssl/sslctx.hpp	/^      static const SSL_METHOD* ssl23_method_server()$/;"	f	class:openvpn::OpenSSLContext::SSL
ssl23_method_server_	openssl/ssl/sslctx.hpp	/^      static SSL_METHOD ssl23_method_server_;$/;"	m	class:openvpn::OpenSSLContext::SSL
ssl23_method_server_	openssl/ssl/sslctx.hpp	/^  SSL_METHOD OpenSSLContext::SSL::ssl23_method_server_;$/;"	m	class:openvpn::OpenSSLContext::SSL
ssl_	ssl/protostack.hpp	/^    typename SSLAPI::Ptr ssl_;$/;"	m	class:openvpn::ProtoStackBase
ssl_bio	openssl/ssl/sslctx.hpp	/^      BIO *ssl_bio;        \/\/ read\/write cleartext from here$/;"	m	class:openvpn::OpenSSLContext::SSL
ssl_bio_linkage	openssl/ssl/sslctx.hpp	/^      bool ssl_bio_linkage;$/;"	m	class:openvpn::OpenSSLContext::SSL
ssl_clear	applecrypto/ssl/sslctx.hpp	/^      void ssl_clear()$/;"	f	class:openvpn::AppleSSLContext::SSL
ssl_clear	openssl/ssl/sslctx.hpp	/^      void ssl_clear()$/;"	f	class:openvpn::OpenSSLContext::SSL
ssl_debug_level	client/cliopt.hpp	/^      int ssl_debug_level = 0;$/;"	m	struct:openvpn::ClientOptions::Config
ssl_debug_level	openssl/ssl/sslctx.hpp	/^      int ssl_debug_level;$/;"	m	class:openvpn::OpenSSLContext::Config
ssl_debug_level	polarssl/ssl/sslctx.hpp	/^      int ssl_debug_level;$/;"	m	class:openvpn::PolarSSLContext::Config
ssl_erase	applecrypto/ssl/sslctx.hpp	/^      void ssl_erase()$/;"	f	class:openvpn::AppleSSLContext::SSL
ssl_erase	openssl/ssl/sslctx.hpp	/^      void ssl_erase()$/;"	f	class:openvpn::OpenSSLContext::SSL
ssl_err	openssl/util/error.hpp	/^    int ssl_err;$/;"	m	class:openvpn::OpenSSLException
ssl_error	openssl/util/error.hpp	/^    int ssl_error() const { return ssl_err; }$/;"	f	class:openvpn::OpenSSLException
ssl_error_text	openssl/util/error.hpp	/^    static const char *ssl_error_text(const int ssl_error, bool *unknown = nullptr)$/;"	f	class:openvpn::OpenSSLException
ssl_factory	ssl/proto.hpp	/^      SSLFactoryAPI::Ptr ssl_factory;$/;"	m	class:openvpn::ProtoContext::Config
ssl_handshake_details	applecrypto/ssl/sslctx.hpp	/^      virtual std::string ssl_handshake_details() const \/\/ fixme -- code me$/;"	f	class:openvpn::AppleSSLContext::SSL
ssl_handshake_details	openssl/ssl/sslctx.hpp	/^      static std::string ssl_handshake_details (const ::SSL *c_ssl)$/;"	f	class:openvpn::OpenSSLContext::SSL
ssl_handshake_details	openssl/ssl/sslctx.hpp	/^      virtual std::string ssl_handshake_details() const$/;"	f	class:openvpn::OpenSSLContext::SSL
ssl_handshake_details	polarssl/ssl/sslctx.hpp	/^      virtual std::string ssl_handshake_details() const$/;"	f	class:openvpn::PolarSSLContext::SSL
ssl_handshake_details	ssl/protostack.hpp	/^    std::string ssl_handshake_details() const$/;"	f	class:openvpn::ProtoStackBase
ssl_pending_override	openssl/ssl/sslctx.hpp	/^      static int ssl_pending_override(const ::SSL *)$/;"	f	class:openvpn::OpenSSLContext::SSL
ssl_started	ssl/protostack.hpp	/^    bool ssl_started() const { return ssl_started_; }$/;"	f	class:openvpn::ProtoStackBase
ssl_started_	ssl/protostack.hpp	/^    bool ssl_started_;$/;"	m	class:openvpn::ProtoStackBase
standardize_capacity	frame/frame.hpp	/^      void standardize_capacity(const size_t newcap)$/;"	f	class:openvpn::Frame::Context
standardize_capacity	frame/frame.hpp	/^    void standardize_capacity(const unsigned int context_mask)$/;"	f	class:openvpn::Frame
start	addr/range.hpp	/^      const ADDR& start() const { return start_; }$/;"	f	class:openvpn::IP::RangeType
start	apple/maclife.hpp	/^    virtual void start(NotifyCallback* nc_arg)$/;"	f	class:openvpn::MacLifeCycle
start	client/cliconnect.hpp	/^    void start()$/;"	f	class:openvpn::ClientConnect
start	client/cliproto.hpp	/^      void start()$/;"	f	class:openvpn::ClientProto::Session
start	client/remotelist.hpp	/^      void start(NotifyCallback* notify_callback_arg)$/;"	f	class:openvpn::RemoteList::PreResolve
start	server/servproto.hpp	/^      virtual void start(const TransportClientInstanceSend::Ptr& parent,$/;"	f	class:openvpn::ServerProto::Session
start	ssl/proto.hpp	/^      void start()$/;"	f	class:openvpn::ProtoContext::KeyContext
start	ssl/proto.hpp	/^    void start()$/;"	f	class:openvpn::ProtoContext
start	transport/tcplink.hpp	/^      void start()$/;"	f	class:openvpn::TCPTransport::Link
start	transport/udplink.hpp	/^      void start(const int n_parallel)$/;"	f	class:openvpn::UDPTransport::Link
start	tun/tunio.hpp	/^    void start(const int n_parallel)$/;"	f	class:openvpn::TunIO
start_	addr/range.hpp	/^      ADDR start_;$/;"	m	class:openvpn::IP::RangeType
start_	log/logperiod.hpp	/^    olong start_;$/;"	m	class:openvpn::LogPeriod
start_connect_	transport/client/httpcli.hpp	/^      void start_connect_()$/;"	f	class:openvpn::HTTPProxyTransport::Client
start_connect_	transport/client/tcpcli.hpp	/^      void start_connect_()$/;"	f	class:openvpn::TCPTransport::Client
start_connect_	transport/client/udpcli.hpp	/^      void start_connect_()$/;"	f	class:openvpn::UDPTransport::Client
start_handshake	applecrypto/ssl/sslctx.hpp	/^      virtual void start_handshake()$/;"	f	class:openvpn::AppleSSLContext::SSL
start_handshake	openssl/ssl/sslctx.hpp	/^      virtual void start_handshake()$/;"	f	class:openvpn::OpenSSLContext::SSL
start_handshake	polarssl/ssl/sslctx.hpp	/^      virtual void start_handshake()$/;"	f	class:openvpn::PolarSSLContext::SSL
start_handshake	ssl/protostack.hpp	/^    void start_handshake()$/;"	f	class:openvpn::ProtoStackBase
start_impl_	transport/client/httpcli.hpp	/^      void start_impl_(const asio::error_code& error)$/;"	f	class:openvpn::HTTPProxyTransport::Client
start_impl_	transport/client/tcpcli.hpp	/^      void start_impl_(const asio::error_code& error)$/;"	f	class:openvpn::TCPTransport::Client
start_impl_	transport/client/udpcli.hpp	/^      void start_impl_(const asio::error_code& error)$/;"	f	class:openvpn::UDPTransport::Client
starts_with	common/string.hpp	/^    inline bool starts_with(const std::string& str, const char *prefix)$/;"	f	namespace:openvpn::string
starts_with	common/string.hpp	/^    inline bool starts_with(const std::string& str, const std::string& prefix)$/;"	f	namespace:openvpn::string
stat	common/persistfile.hpp	/^    struct stat stat()$/;"	f	class:openvpn::PersistentFile
stat	ssl/proto.hpp	/^    SessionStats& stat() const { return *stats; }$/;"	f	class:openvpn::ProtoContext
stat_name	log/sessionstats.hpp	/^    static const char *stat_name(const size_t type)$/;"	f	class:openvpn::SessionStats
state	apple/maclife.hpp	/^    State state;$/;"	m	class:openvpn::MacLifeCycle
state	applecrypto/crypto/hmac.hpp	/^      int state;$/;"	m	class:openvpn::AppleCrypto::HMACContext
state	http/htmlskip.hpp	/^      State state;$/;"	m	class:openvpn::HTTP::HTMLSkip
state	http/reply.hpp	/^      enum state$/;"	g	class:openvpn::HTTP::ReplyParser
state	http/request.hpp	/^      enum state$/;"	g	class:openvpn::HTTP::RequestParser
state	ssl/datalimit.hpp	/^      State state = None;$/;"	m	class:openvpn::DataLimit::Component
state	ssl/proto.hpp	/^      int state;$/;"	m	class:openvpn::ProtoContext::KeyContext
state	tun/builder/client.hpp	/^      TunProp::State::Ptr state;$/;"	m	class:openvpn::TunBuilderClient::Client
state	tun/linux/client/tuncli.hpp	/^      TunProp::State::Ptr state;$/;"	m	class:openvpn::TunLinux::Client
state	tun/mac/client/tuncli.hpp	/^      TunProp::State::Ptr state;$/;"	m	class:openvpn::TunMac::Client
state	tun/persist/tunpersist.hpp	/^    const TunProp::State::Ptr& state() const$/;"	f	class:openvpn::TunPersistTemplate
state	tun/win/client/tuncli.hpp	/^      TunProp::State::Ptr state;$/;"	m	class:openvpn::TunWin::Client
state_	http/reply.hpp	/^      state state_;$/;"	m	class:openvpn::HTTP::ReplyParser
state_	http/request.hpp	/^      state state_;$/;"	m	class:openvpn::HTTP::RequestParser
state_	tun/persist/tunpersist.hpp	/^    TunProp::State::Ptr state_;$/;"	m	class:openvpn::TunPersistTemplate
state_id	auth/cr.hpp	/^    std::string state_id;$/;"	m	class:openvpn::ChallengeResponse
state_str	ssl/datalimit.hpp	/^    static const char *state_str(const State s)$/;"	f	class:openvpn::DataLimit
state_string	ssl/proto.hpp	/^      static const char *state_string(const int s)$/;"	f	class:openvpn::ProtoContext::KeyContext
staticChallenge	client/cliopthelper.hpp	/^    const std::string& staticChallenge() const { return staticChallenge_; }$/;"	f	class:openvpn::ParseClientConfig
staticChallengeEcho	client/cliopthelper.hpp	/^    bool staticChallengeEcho() const { return staticChallengeEcho_; }$/;"	f	class:openvpn::ParseClientConfig
staticChallengeEcho_	client/cliopthelper.hpp	/^    bool staticChallengeEcho_;$/;"	m	class:openvpn::ParseClientConfig
staticChallenge_	client/cliopthelper.hpp	/^    std::string staticChallenge_;$/;"	m	class:openvpn::ParseClientConfig
static_key_foot	crypto/static_key.hpp	/^    static const char *static_key_foot()$/;"	f	class:openvpn::OpenVPNStaticKey
static_key_head	crypto/static_key.hpp	/^    static const char *static_key_head()$/;"	f	class:openvpn::OpenVPNStaticKey
stats	client/cliopt.hpp	/^    SessionStats& stats() { return *cli_stats; }$/;"	f	class:openvpn::ClientOptions
stats	client/remotelist.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::RemoteList::PreResolve
stats	common/runcontext.hpp	/^    typename Stats::Ptr stats;$/;"	m	class:openvpn::RunContext
stats	compress/compress.hpp	/^    SessionStats::Ptr stats;$/;"	m	class:openvpn::Compress
stats	crypto/crypto_aead.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::AEAD::Crypto
stats	crypto/crypto_aead.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::AEAD::CryptoContext
stats	crypto/crypto_chm.hpp	/^    SessionStats::Ptr stats;$/;"	m	class:openvpn::CryptoCHM
stats	crypto/crypto_chm.hpp	/^    SessionStats::Ptr stats;$/;"	m	class:openvpn::CryptoContextCHM
stats	crypto/cryptodcsel.hpp	/^    SessionStats::Ptr stats;$/;"	m	class:openvpn::CryptoDCSelect
stats	crypto/packet_id.hpp	/^    SessionStats::Ptr stats;$/;"	m	class:openvpn::PacketIDReceiveType
stats	server/servproto.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::ServerProto::Factory
stats	server/servproto.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::ServerProto::Session
stats	ssl/proto.hpp	/^    SessionStats::Ptr stats;$/;"	m	class:openvpn::ProtoContext
stats	ssl/protostack.hpp	/^    SessionStats::Ptr stats;$/;"	m	class:openvpn::ProtoStackBase
stats	transport/altproxy.hpp	/^      SessionStats::Ptr stats;$/;"	m	struct:openvpn::AltProxy::Config
stats	transport/client/httpcli.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::HTTPProxyTransport::ClientConfig
stats	transport/client/tcpcli.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::TCPTransport::ClientConfig
stats	transport/client/udpcli.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::UDPTransport::ClientConfig
stats	transport/dco.hpp	/^      SessionStats::Ptr stats;$/;"	m	struct:openvpn::DCO::TransportConfig
stats	transport/tcplink.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::TCPTransport::Link
stats	transport/udplink.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::UDPTransport::Link
stats	tun/builder/client.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::TunBuilderClient::ClientConfig
stats	tun/client/tunnull.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::TunNull::ClientConfig
stats	tun/linux/client/tuncli.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::TunLinux::ClientConfig
stats	tun/mac/client/tuncli.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::TunMac::ClientConfig
stats	tun/tunio.hpp	/^    SessionStats::Ptr stats;$/;"	m	class:openvpn::TunIO
stats	tun/win/client/tuncli.hpp	/^      SessionStats::Ptr stats;$/;"	m	class:openvpn::TunWin::ClientConfig
stats_	log/sessionstats.hpp	/^    volatile count_t stats_[N_STATS];$/;"	m	class:openvpn::SessionStats
stats_notify	server/servproto.hpp	/^      virtual void stats_notify(const PeerStats& ps, const bool final)$/;"	f	class:openvpn::ServerProto::Session
stats_poll	server/servproto.hpp	/^      virtual PeerStats stats_poll()$/;"	f	class:openvpn::ServerProto::Session
stats_ptr	client/cliopt.hpp	/^    const SessionStats::Ptr& stats_ptr() const { return cli_stats; }$/;"	f	class:openvpn::ClientOptions
status	applecrypto/util/reachable.hpp	/^    Status status() const$/;"	f	class:openvpn::ReachabilityBase
status	buffer/buffer.hpp	/^    Status status() const { return status_; }$/;"	f	class:openvpn::BufferException
status	common/glob.hpp	/^    int status() const$/;"	f	class:openvpn::Glob
status	http/reply.hpp	/^      enum status {$/;"	g	class:openvpn::HTTP::ReplyParser
status	http/request.hpp	/^      enum status {$/;"	g	class:openvpn::HTTP::RequestParser
status	http/webexcept.hpp	/^      int status() const { return status_; }$/;"	f	class:openvpn::HTTP::WebException
status	options/merge.hpp	/^    Status status() const { return status_; }$/;"	f	class:openvpn::ProfileMerge
status	server/peerstats.hpp	/^    int status;$/;"	m	struct:openvpn::PeerStats
status_	buffer/buffer.hpp	/^    Status status_;$/;"	m	class:openvpn::BufferException
status_	common/glob.hpp	/^    int status_;$/;"	m	class:openvpn::Glob
status_	http/webexcept.hpp	/^      const int status_;$/;"	m	class:openvpn::HTTP::WebException
status_	options/merge.hpp	/^    Status status_;$/;"	m	class:openvpn::ProfileMerge
status_code	http/reply.hpp	/^	  status_code,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
status_code	http/reply.hpp	/^      int status_code;$/;"	m	struct:openvpn::HTTP::Reply
status_code_start	http/reply.hpp	/^	  status_code_start,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
status_from_flags	applecrypto/util/reachable.hpp	/^    static Status status_from_flags(const SCNetworkReachabilityFlags flags)$/;"	f	class:openvpn::ReachabilityViaInternet
status_from_flags	applecrypto/util/reachable.hpp	/^    static Status status_from_flags(const SCNetworkReachabilityFlags flags)$/;"	f	class:openvpn::ReachabilityViaWiFi
status_string	buffer/buffer.hpp	/^    const char *status_string() const$/;"	f	class:openvpn::BufferException
status_string	options/merge.hpp	/^    const char *status_string() const$/;"	f	class:openvpn::ProfileMerge
status_string	polarssl/ssl/sslctx.hpp	/^    static std::string status_string(const x509_crt *cert, const int depth, const int *flags)$/;"	f	class:openvpn::PolarSSLContext
status_text	http/reply.hpp	/^	  status_text,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
status_text	http/reply.hpp	/^      std::string status_text;$/;"	m	struct:openvpn::HTTP::Reply
status_text_start	http/reply.hpp	/^	  status_text_start,$/;"	e	enum:openvpn::HTTP::ReplyParser::state
std_input	win/console.hpp	/^	HANDLE std_input;$/;"	m	class:openvpn::Win::Console::Input
stop	apple/maclife.hpp	/^    virtual void stop()$/;"	f	class:openvpn::MacLifeCycle
stop	client/cliconnect.hpp	/^    void stop()$/;"	f	class:openvpn::ClientConnect
stop	client/cliopt.hpp	/^      Stop* stop = nullptr;$/;"	m	struct:openvpn::ClientOptions::Config
stop	client/cliproto.hpp	/^      void stop(const bool call_terminate_callback)$/;"	f	class:openvpn::ClientProto::Session
stop	common/actionthread.hpp	/^    void stop(const bool halt)$/;"	f	class:openvpn::ActionThread
stop	common/pthreadcond.hpp	/^    Stop* stop;$/;"	m	class:openvpn::PThreadBarrier
stop	common/stop.hpp	/^      Stop *const stop;$/;"	m	class:openvpn::Stop::Scope
stop	common/stop.hpp	/^    void stop()$/;"	f	class:openvpn::Stop
stop	netconf/linux/route.hpp	/^    void stop()$/;"	f	class:openvpn::RouteListLinux
stop	server/servproto.hpp	/^      virtual void stop()$/;"	f	class:openvpn::ServerProto::Session
stop	transport/client/httpcli.hpp	/^      virtual void stop() { stop_(); }$/;"	f	class:openvpn::HTTPProxyTransport::Client
stop	transport/client/tcpcli.hpp	/^      virtual void stop() { stop_(); }$/;"	f	class:openvpn::TCPTransport::Client
stop	transport/client/udpcli.hpp	/^      virtual void stop() { stop_(); }$/;"	f	class:openvpn::UDPTransport::Client
stop	transport/dco.hpp	/^      Stop* stop = nullptr;$/;"	m	struct:openvpn::DCO::TunConfig
stop	transport/gremlin.hpp	/^      void stop()$/;"	f	class:openvpn::Gremlin::SendRecvQueue
stop	transport/gremlin.hpp	/^      void stop()$/;"	f	struct:openvpn::Gremlin::DelayedQueue
stop	transport/tcplink.hpp	/^      void stop()$/;"	f	class:openvpn::TCPTransport::Link
stop	transport/udplink.hpp	/^      void stop()$/;"	f	class:openvpn::UDPTransport::Link
stop	tun/client/tunnull.hpp	/^      virtual void stop() {}$/;"	f	class:openvpn::TunNull::Client
stop	tun/linux/client/tuncli.hpp	/^      virtual void stop() { stop_(); }$/;"	f	class:openvpn::TunLinux::Client
stop	tun/mac/client/tuncli.hpp	/^      Stop* stop = nullptr;$/;"	m	class:openvpn::TunMac::ClientConfig
stop	tun/tunio.hpp	/^    void stop()$/;"	f	class:openvpn::TunIO
stop	tun/win/client/tuncli.hpp	/^      Stop* stop = nullptr;$/;"	m	class:openvpn::TunWin::ClientConfig
stop_	transport/client/httpcli.hpp	/^      void stop_()$/;"	f	class:openvpn::HTTPProxyTransport::Client
stop_	transport/client/tcpcli.hpp	/^      void stop_()$/;"	f	class:openvpn::TCPTransport::Client
stop_	transport/client/udpcli.hpp	/^      void stop_()$/;"	f	class:openvpn::UDPTransport::Client
stop_	tun/builder/client.hpp	/^      void stop_()$/;"	f	class:openvpn::TunBuilderClient::Client
stop_	tun/linux/client/tuncli.hpp	/^      void stop_()$/;"	f	class:openvpn::TunLinux::Client
stop_	tun/mac/client/tuncli.hpp	/^      void stop_()$/;"	f	class:openvpn::TunMac::Client
stop_	tun/win/client/tuncli.hpp	/^      void stop_()$/;"	f	class:openvpn::TunWin::Client
stop_called	common/stop.hpp	/^    bool stop_called = false;$/;"	m	class:openvpn::Stop
stop_on_signal	client/cliconnect.hpp	/^    void stop_on_signal(const asio::error_code& error, int signal_number)$/;"	f	class:openvpn::ClientConnect
stop_on_signal	client/cliproto.hpp	/^      void stop_on_signal(const asio::error_code& error, int signal_number)$/;"	f	class:openvpn::ClientProto::Session
stop_thread	apple/maclife.hpp	/^    void stop_thread()$/;"	f	class:openvpn::MacLifeCycle
stop_thread	tun/mac/macdns_watchdog.hpp	/^    void stop_thread()$/;"	f	class:openvpn::MacDNSWatchdog
stopped	netconf/linux/route.hpp	/^    bool stopped;$/;"	m	class:openvpn::RouteListLinux
store_win_time	proxy/ntlm.hpp	/^      static void store_win_time(unsigned char *dest)$/;"	f	class:openvpn::HTTPProxy::NTLM
str	common/format.hpp	/^      std::string str()$/;"	f	class:openvpn::print_formatted_detail::Output
str	common/format.hpp	/^    std::string str()$/;"	f	class:openvpn::PrintFormatted
str	common/mode.hpp	/^    const char *str() const$/;"	f	class:openvpn::Mode
str	common/unicode.hpp	/^	std::string str(const char *malformed)$/;"	f	struct:openvpn::Unicode::UTF8Iterator::Char
str	common/unicode.hpp	/^      const unsigned char *str;$/;"	m	class:openvpn::Unicode::UTF8Iterator
str	compress/compress.hpp	/^    const char *str() const$/;"	f	class:openvpn::CompressContext
str	crypto/packet_id.hpp	/^    std::string str() const$/;"	f	class:openvpn::PacketIDReceiveType
str	crypto/packet_id.hpp	/^    std::string str() const$/;"	f	class:openvpn::PacketIDSend
str	crypto/packet_id.hpp	/^    std::string str() const$/;"	f	struct:openvpn::PacketID
str	ssl/psid.hpp	/^    std::string str() const$/;"	f	class:openvpn::ProtoSessionID
str	transport/protocol.hpp	/^    const char *str() const$/;"	f	class:openvpn::Protocol
str	tun/layer.hpp	/^    const char *str() const$/;"	f	class:openvpn::Layer
str_	common/format.hpp	/^      std::string str_;$/;"	m	class:openvpn::print_formatted_detail::Output
str_client	transport/protocol.hpp	/^    const char *str_client(const bool force_ipv4) const$/;"	f	class:openvpn::Protocol
strcasecmp	common/string.hpp	/^    inline int strcasecmp(const char *s1, const char *s2)$/;"	f	namespace:openvpn::string
strcasecmp	common/string.hpp	/^    inline int strcasecmp(const char *s1, const std::string& s2)$/;"	f	namespace:openvpn::string
strcasecmp	common/string.hpp	/^    inline int strcasecmp(const std::string& s1, const char *s2)$/;"	f	namespace:openvpn::string
strcasecmp	common/string.hpp	/^    inline int strcasecmp(const std::string& s1, const std::string& s2)$/;"	f	namespace:openvpn::string
stream	tun/tunio.hpp	/^    STREAM *stream;$/;"	m	class:openvpn::TunIO
strictConversion	common/unicode-impl.hpp	/^      strictConversion = 0,$/;"	e	enum:openvpn::Unicode::__anon26
string	applecrypto/cf/cf.hpp	/^    inline String string(CFStringRef str)$/;"	f	namespace:openvpn::CF
string	applecrypto/cf/cf.hpp	/^    inline String string(const String& str)$/;"	f	namespace:openvpn::CF
string	applecrypto/cf/cf.hpp	/^    inline String string(const char *str)$/;"	f	namespace:openvpn::CF
string	applecrypto/cf/cf.hpp	/^    inline String string(const std::string& str)$/;"	f	namespace:openvpn::CF
string	applecrypto/cf/cf.hpp	/^    inline String string(const std::string* str)$/;"	f	namespace:openvpn::CF
string	common/string.hpp	/^  namespace string {$/;"	n	namespace:openvpn
string_alloc	common/argv.hpp	/^    static char *string_alloc(const std::string& s)$/;"	f	class:openvpn::ArgvWrapper
string_equal	applecrypto/cf/cf.hpp	/^    inline bool string_equal(const String& s1, const String& s2, const CFStringCompareFlags compareOptions = 0)$/;"	f	namespace:openvpn::CF
string_to_utf16	common/unicode.hpp	/^    inline BufferPtr string_to_utf16(const STRING& str)$/;"	f	namespace:openvpn::Unicode
strncpynt	common/string.hpp	/^    inline void strncpynt (char *dest, const char *src, size_t maxlen)$/;"	f	namespace:openvpn::string
stub	compress/compress.hpp	/^    static Type stub(const Type t)$/;"	f	class:openvpn::CompressContext
sub	addr/ipv6.hpp	/^      static void sub(ipv6addr& dest, const ipv6addr& src) {$/;"	f	class:openvpn::IPv6::Addr
subkey	tun/win/nrpt.hpp	/^      static const char *subkey()$/;"	f	class:openvpn::TunWin::NRPT
submit_creds	client/cliopt.hpp	/^    void submit_creds(const ClientCreds::Ptr& creds_arg)$/;"	f	class:openvpn::ClientOptions
success	http/reply.hpp	/^	success,$/;"	e	enum:openvpn::HTTP::ReplyParser::status
success	http/request.hpp	/^	success,$/;"	e	enum:openvpn::HTTP::RequestParser::status
support_swap	compress/compstub.hpp	/^    const bool support_swap;$/;"	m	class:openvpn::CompressStub
support_swap	compress/lzo.hpp	/^    const bool support_swap;$/;"	m	class:openvpn::CompressLZO
support_swap	compress/lzoasym.hpp	/^    const bool support_swap;$/;"	m	class:openvpn::CompressLZOAsym
swap	applecrypto/cf/cf.hpp	/^      void swap(Wrap& other)$/;"	f	class:openvpn::CF::Wrap
swap	buffer/buffer.hpp	/^    void swap(BufferAllocatedType& other)$/;"	f	class:openvpn::BufferAllocatedType
syserr	common/persistfile.hpp	/^    void syserr(const char *type)$/;"	f	class:openvpn::PersistentFile
system_cmd	common/process.hpp	/^  inline int system_cmd(const Argv& argv)$/;"	f	namespace:openvpn
system_cmd	common/process.hpp	/^  inline int system_cmd(const std::string& cmd, const Argv& argv)$/;"	f	namespace:openvpn
system_cmd	common/process.hpp	/^  inline int system_cmd(const std::string& cmd,$/;"	f	namespace:openvpn
system_cmd_async	common/process.hpp	/^  inline pid_t system_cmd_async(const std::string& cmd,$/;"	f	namespace:openvpn
system_cmd_post	common/process.hpp	/^  inline int system_cmd_post(const pid_t pid)$/;"	f	namespace:openvpn
ta_hmac_recv	ssl/proto.hpp	/^      OvpnHMACInstance::Ptr ta_hmac_recv;$/;"	m	class:openvpn::ProtoContext::TLSAuthPreValidate
ta_hmac_recv	ssl/proto.hpp	/^    OvpnHMACInstance::Ptr ta_hmac_recv;$/;"	m	class:openvpn::ProtoContext
ta_hmac_send	ssl/proto.hpp	/^    OvpnHMACInstance::Ptr ta_hmac_send;$/;"	m	class:openvpn::ProtoContext
ta_pid_recv	ssl/proto.hpp	/^    PacketIDReceive ta_pid_recv;$/;"	m	class:openvpn::ProtoContext
ta_pid_send	ssl/proto.hpp	/^    PacketIDSend ta_pid_send;$/;"	m	class:openvpn::ProtoContext
tail_id	common/msgwin.hpp	/^    id_t tail_id() const { return head_id_ + span_; }$/;"	f	class:openvpn::MessageWindow
tail_id	reliable/relsend.hpp	/^    id_t tail_id() const { return window_.tail_id(); }$/;"	f	class:openvpn::ReliableSendTemplate
tailroom	frame/frame.hpp	/^      size_t tailroom() const { return tailroom_; }$/;"	f	class:openvpn::Frame::Context
tailroom_	frame/frame.hpp	/^      size_t tailroom_;$/;"	m	class:openvpn::Frame::Context
tap	tun/win/client/tunsetup.hpp	/^	Util::TapNameGuidPair tap;$/;"	m	struct:openvpn::TunWin::Setup::L2State
tap_configure_topology_net30	tun/win/tunutil.hpp	/^      inline void tap_configure_topology_net30(HANDLE th, const IP::Addr& local_addr, const unsigned int prefix_len)$/;"	f	namespace:openvpn::TunWin::Util
tap_configure_topology_subnet	tun/win/tunutil.hpp	/^      inline void tap_configure_topology_subnet(HANDLE th, const IP::Addr& local, const unsigned int prefix_len)$/;"	f	namespace:openvpn::TunWin::Util
tap_guid	tun/win/tunutil.hpp	/^	const std::string tap_guid;$/;"	m	class:openvpn::TunWin::Util::ActionSetAdapterDomainSuffix
tap_guids	tun/win/tunutil.hpp	/^      inline std::vector<std::string> tap_guids()$/;"	f	namespace:openvpn::TunWin::Util
tap_handle	tun/win/client/tuncli.hpp	/^      HANDLE tap_handle()$/;"	f	class:openvpn::TunWin::Client
tap_index	tun/win/wfp.hpp	/^      const NET_IFINDEX tap_index;$/;"	m	class:openvpn::TunWin::ActionWFP
tap_open	tun/win/tunutil.hpp	/^      inline HANDLE tap_open(const TapNameGuidPairList& guids,$/;"	f	namespace:openvpn::TunWin::Util
tap_path	tun/win/tunutil.hpp	/^      inline std::string tap_path(const std::string& tap_guid)$/;"	f	namespace:openvpn::TunWin::Util
tap_process_logging	tun/win/client/tuncli.hpp	/^      void tap_process_logging()$/;"	f	class:openvpn::TunWin::Client
tap_process_logging	tun/win/tunutil.hpp	/^      inline void tap_process_logging(HANDLE th)$/;"	f	namespace:openvpn::TunWin::Util
tap_set_media_status	tun/win/tunutil.hpp	/^      inline void tap_set_media_status(HANDLE th, bool media_status)$/;"	f	namespace:openvpn::TunWin::Util
targetExhausted	common/unicode-impl.hpp	/^      targetExhausted, \/* insuff. room in target for conversion *\/$/;"	e	enum:openvpn::Unicode::__anon25
tb_	tun/persist/tunpersist.hpp	/^    TunBuilderBase * const tb_;$/;"	m	class:openvpn::TunPersistTemplate
tcp	server/peeraddr.hpp	/^    bool tcp;$/;"	m	struct:openvpn::PeerAddr
tcp	transport/gremlin.hpp	/^      bool tcp;$/;"	m	class:openvpn::Gremlin::SendRecvQueue
tcp_eof_handler	transport/client/httpcli.hpp	/^      void tcp_eof_handler() \/\/ called by LinkImpl$/;"	f	class:openvpn::HTTPProxyTransport::Client
tcp_eof_handler	transport/client/tcpcli.hpp	/^      void tcp_eof_handler() \/\/ called by LinkImpl$/;"	f	class:openvpn::TCPTransport::Client
tcp_error_handler	transport/client/httpcli.hpp	/^      void tcp_error_handler(const char *error) \/\/ called by LinkImpl and internally$/;"	f	class:openvpn::HTTPProxyTransport::Client
tcp_error_handler	transport/client/tcpcli.hpp	/^      void tcp_error_handler(const char *error) \/\/ called by LinkImpl$/;"	f	class:openvpn::TCPTransport::Client
tcp_nodelay	common/asiopolysock.hpp	/^      virtual void tcp_nodelay() {}$/;"	f	class:openvpn::AsioPolySock::Base
tcp_nodelay	common/sockopt.hpp	/^    inline void tcp_nodelay(const int fd)$/;"	f	namespace:openvpn::SockOpt
tcp_queue_limit	client/cliopt.hpp	/^    unsigned int tcp_queue_limit;$/;"	m	class:openvpn::ClientOptions
tcp_queue_limit	client/cliproto.hpp	/^	unsigned int tcp_queue_limit = 0;$/;"	m	struct:openvpn::ClientProto::Session::Config
tcp_queue_limit	client/cliproto.hpp	/^      unsigned int tcp_queue_limit;$/;"	m	class:openvpn::ClientProto::Session
tcp_read_handler	transport/client/httpcli.hpp	/^      bool tcp_read_handler(BufferAllocated& buf) \/\/ called by LinkImpl$/;"	f	class:openvpn::HTTPProxyTransport::Client
tcp_read_handler	transport/client/tcpcli.hpp	/^      bool tcp_read_handler(BufferAllocated& buf) \/\/ called by LinkImpl$/;"	f	class:openvpn::TCPTransport::Client
tcp_write_queue_needs_send	transport/client/httpcli.hpp	/^      void tcp_write_queue_needs_send() \/\/ called by LinkImpl$/;"	f	class:openvpn::HTTPProxyTransport::Client
tcp_write_queue_needs_send	transport/client/tcpcli.hpp	/^      void tcp_write_queue_needs_send() \/\/ called by LinkImpl$/;"	f	class:openvpn::TCPTransport::Client
test	ssl/tls_remote.hpp	/^    inline bool test(const std::string& tls_remote, const std::string& subject, const std::string& common_name)$/;"	f	namespace:openvpn::TLSRemote
test_add	crypto/packet_id.hpp	/^    bool test_add(const PacketID& pin,$/;"	f	class:openvpn::PacketIDReceiveType
test_network	client/cliconnect.hpp	/^    bool test_network() const$/;"	f	class:openvpn::ClientConnect
text	common/runcontext.hpp	/^    std::string text;$/;"	m	struct:openvpn::RunContextLogEntry
the_instance	init/initprocess.hpp	/^    OPENVPN_EXTERN Init* the_instance; \/\/ GLOBAL$/;"	m	namespace:openvpn::InitProcess
the_instance_mutex	init/initprocess.hpp	/^    OPENVPN_EXTERN std::mutex the_instance_mutex; \/\/ GLOBAL$/;"	m	namespace:openvpn::InitProcess
thr	server/vpnservnetblock.hpp	/^    std::vector<PerThread> thr;$/;"	m	class:openvpn::VPNServerNetblock
thread	apple/maclife.hpp	/^    std::thread* thread;$/;"	m	class:openvpn::MacLifeCycle
thread	common/actionthread.hpp	/^    std::thread* thread;$/;"	m	class:openvpn::ActionThread
thread	tun/mac/macdns_watchdog.hpp	/^    std::thread* thread;            \/\/ watcher thread$/;"	m	class:openvpn::MacDNSWatchdog
thread_count	common/runcontext.hpp	/^    int thread_count = 0;$/;"	m	class:openvpn::RunContext
thread_func	apple/maclife.hpp	/^    void thread_func()$/;"	f	class:openvpn::MacLifeCycle
thread_func	common/actionthread.hpp	/^    void thread_func()$/;"	f	class:openvpn::ActionThread
thread_func	tun/mac/macdns_watchdog.hpp	/^    void thread_func()$/;"	f	class:openvpn::MacDNSWatchdog
thread_safe_pause	client/cliconnect.hpp	/^    void thread_safe_pause(const std::string& reason)$/;"	f	class:openvpn::ClientConnect
thread_safe_reconnect	client/cliconnect.hpp	/^    void thread_safe_reconnect(int seconds)$/;"	f	class:openvpn::ClientConnect
thread_safe_refcount	common/rc.hpp	/^  class thread_safe_refcount$/;"	c	namespace:openvpn
thread_safe_resume	client/cliconnect.hpp	/^    void thread_safe_resume()$/;"	f	class:openvpn::ClientConnect
thread_safe_stop	client/cliconnect.hpp	/^    void thread_safe_stop()$/;"	f	class:openvpn::ClientConnect
thread_unsafe_refcount	common/rc.hpp	/^  class thread_unsafe_refcount$/;"	c	namespace:openvpn
threadlist	common/runcontext.hpp	/^    std::vector<std::thread*> threadlist;$/;"	m	class:openvpn::RunContext
throw_ref	common/exception.hpp	/^  inline void throw_ref(const std::exception& e)$/;"	f	namespace:openvpn
time	crypto/packet_id.hpp	/^    time_t time;   \/\/ converted to PacketID::net_time_t before transmission$/;"	m	struct:openvpn::PacketID
time_	time/coarsetime.hpp	/^    Time time_;$/;"	m	class:openvpn::CoarseTime
time_	time/time.hpp	/^    T time_;$/;"	m	class:openvpn::TimeType
time_high	crypto/packet_id.hpp	/^    PacketID::time_t time_high;     \/\/ highest time stamp received$/;"	m	class:openvpn::PacketIDReceiveType
time_point	time/asiotimer.hpp	/^    typedef std::chrono::time_point<AsioClock> time_point;$/;"	t	struct:openvpn::AsioClock
time_t	crypto/packet_id.hpp	/^    typedef Time::base_type time_t;$/;"	t	struct:openvpn::PacketID
timestamp	common/runcontext.hpp	/^    time_t timestamp;$/;"	m	struct:openvpn::RunContextLogEntry
tls_auth_context	ssl/proto.hpp	/^      OvpnHMACContext::Ptr tls_auth_context;$/;"	m	class:openvpn::ProtoContext::Config
tls_auth_enabled	ssl/proto.hpp	/^      bool tls_auth_enabled() const$/;"	f	class:openvpn::ProtoContext::Config
tls_auth_factory	ssl/proto.hpp	/^      OvpnHMACFactory::Ptr tls_auth_factory;$/;"	m	class:openvpn::ProtoContext::Config
tls_auth_key	ssl/proto.hpp	/^      OpenVPNStaticKey tls_auth_key; \/\/ leave this undefined to disable tls_auth$/;"	m	class:openvpn::ProtoContext::Config
tls_remote	openssl/ssl/sslctx.hpp	/^      std::string tls_remote;$/;"	m	class:openvpn::OpenSSLContext::Config
tls_remote	polarssl/ssl/sslctx.hpp	/^      std::string tls_remote;$/;"	m	class:openvpn::PolarSSLContext::Config
tls_timeout	ssl/proto.hpp	/^      Time::Duration tls_timeout;      \/\/ Packet retransmit timeout on TLS control channel$/;"	m	class:openvpn::ProtoContext::Config
tls_timeout	ssl/protostack.hpp	/^    const Time::Duration tls_timeout;$/;"	m	class:openvpn::ProtoStackBase
tls_version_min	openssl/ssl/sslctx.hpp	/^      TLSVersion::Type tls_version_min; \/\/ minimum TLS version that we will negotiate$/;"	m	class:openvpn::OpenSSLContext::Config
tls_version_min	polarssl/ssl/sslctx.hpp	/^      TLSVersion::Type tls_version_min; \/\/ minimum TLS version that we will negotiate$/;"	m	class:openvpn::PolarSSLContext::Config
tls_version_min_override	client/cliopt.hpp	/^      std::string tls_version_min_override;$/;"	m	struct:openvpn::ClientOptions::Config
tlsprf	ssl/proto.hpp	/^      TLSPRFInstance::Ptr tlsprf;$/;"	m	class:openvpn::ProtoContext::KeyContext
tlsprf_factory	ssl/proto.hpp	/^      TLSPRFFactory::Ptr tlsprf_factory;$/;"	m	class:openvpn::ProtoContext::Config
to_app_buf	ssl/protostack.hpp	/^    BufferPtr to_app_buf; \/\/ cleartext data decrypted by SSL that is to be passed to app via app_recv method$/;"	m	class:openvpn::ProtoStackBase
to_asio	addr/ip.hpp	/^      asio::ip::address to_asio() const$/;"	f	class:openvpn::IP::Addr
to_asio	addr/ipv4.hpp	/^      asio::ip::address_v4 to_asio() const$/;"	f	class:openvpn::IPv4::Addr
to_asio	addr/ipv6.hpp	/^      asio::ip::address_v6 to_asio() const$/;"	f	class:openvpn::IPv6::Addr
to_binary_ms	time/time.hpp	/^      T to_binary_ms() const { return duration_; }$/;"	f	class:openvpn::TimeType::Duration
to_byte_string	addr/ip.hpp	/^      void to_byte_string(unsigned char *bytestr) const$/;"	f	class:openvpn::IP::Addr
to_byte_string	addr/ipv6.hpp	/^      void to_byte_string(unsigned char *bytestr) const$/;"	f	class:openvpn::IPv6::Addr
to_hex	addr/ip.hpp	/^      std::string to_hex() const$/;"	f	class:openvpn::IP::Addr
to_hex	addr/ipv4.hpp	/^      std::string to_hex() const$/;"	f	class:openvpn::IPv4::Addr
to_hex	addr/ipv6.hpp	/^      std::string to_hex() const$/;"	f	class:openvpn::IPv6::Addr
to_in6_addr	addr/ipv6.hpp	/^      struct in6_addr to_in6_addr() const$/;"	f	class:openvpn::IPv6::Addr
to_in_addr	addr/ipv4.hpp	/^      struct in_addr to_in_addr() const$/;"	f	class:openvpn::IPv4::Addr
to_ipv4	addr/ip.hpp	/^      const IPv4::Addr& to_ipv4() const$/;"	f	class:openvpn::IP::Addr
to_ipv4_nocheck	addr/ip.hpp	/^      const IPv4::Addr& to_ipv4_nocheck() const$/;"	f	class:openvpn::IP::Addr
to_ipv6	addr/ip.hpp	/^      const IPv6::Addr& to_ipv6() const$/;"	f	class:openvpn::IP::Addr
to_ipv6_nocheck	addr/ip.hpp	/^      const IPv6::Addr& to_ipv6_nocheck() const$/;"	f	class:openvpn::IP::Addr
to_json	common/action.hpp	/^    virtual Json::Value to_json() const$/;"	f	struct:openvpn::Action
to_json	tun/builder/capture.hpp	/^      Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture::DNSServer
to_json	tun/builder/capture.hpp	/^      Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture::ProxyAutoConfigURL
to_json	tun/builder/capture.hpp	/^      Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture::ProxyBypass
to_json	tun/builder/capture.hpp	/^      Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture::ProxyHostPort
to_json	tun/builder/capture.hpp	/^      Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture::RemoteAddress
to_json	tun/builder/capture.hpp	/^      Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture::RerouteGW
to_json	tun/builder/capture.hpp	/^      Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture::RouteBase
to_json	tun/builder/capture.hpp	/^      Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture::SearchDomain
to_json	tun/builder/capture.hpp	/^      Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture::WINSServer
to_json	tun/builder/capture.hpp	/^    Json::Value to_json() const$/;"	f	class:openvpn::TunBuilderCapture
to_long	addr/ip.hpp	/^      long to_long() const$/;"	f	class:openvpn::IP::Addr
to_long	addr/ipv4.hpp	/^      long to_long() const$/;"	f	class:openvpn::IPv4::Addr
to_long	addr/ipv6.hpp	/^      long to_long() const$/;"	f	class:openvpn::IPv6::Addr
to_lower	common/string.hpp	/^    inline void to_lower(std::string& str)$/;"	f	namespace:openvpn::string
to_lower_copy	common/string.hpp	/^    inline std::string to_lower_copy(const std::string& str)$/;"	f	namespace:openvpn::string
to_milliseconds	time/time.hpp	/^      T to_milliseconds() const$/;"	f	class:openvpn::TimeType::Duration
to_option_list	options/servpush.hpp	/^    OptionList to_option_list() const$/;"	f	class:openvpn::ServerPushList
to_seconds	time/time.hpp	/^      T to_seconds() const { return duration_ \/ prec; }$/;"	f	class:openvpn::TimeType::Duration
to_sockaddr	addr/ipv4.hpp	/^      struct sockaddr_in to_sockaddr() const$/;"	f	class:openvpn::IPv4::Addr
to_sockaddr	addr/ipv6.hpp	/^      struct sockaddr_in6 to_sockaddr() const$/;"	f	class:openvpn::IPv6::Addr
to_string	addr/addrpair.hpp	/^      std::string to_string(const bool netmask_form=false) const$/;"	f	struct:openvpn::IP::AddrMaskPair
to_string	addr/ip.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::IP::Addr
to_string	addr/ipv4.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::IPv4::Addr
to_string	addr/ipv6.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::IPv6::Addr
to_string	addr/macaddr.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::MACAddr
to_string	addr/range.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::IP::RangeType
to_string	addr/route.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::IP::RouteType
to_string	addr/route.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::IP::RouteTypeList
to_string	apple/maclife.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::MacLifeCycle::State
to_string	apple/ver.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::AppleVersion
to_string	applecrypto/util/iosactiveiface.hpp	/^    virtual std::string to_string() const$/;"	f	class:openvpn::iOSActiveInterface
to_string	applecrypto/util/reachable.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::ReachabilityBase
to_string	applecrypto/util/reachable.hpp	/^    std::string to_string(const SCNetworkReachabilityFlags f) const$/;"	f	class:openvpn::ReachabilityBase
to_string	applecrypto/util/reachable.hpp	/^    virtual std::string to_string() const$/;"	f	class:openvpn::Reachability
to_string	auth/authcert.hpp	/^	std::string to_string(const bool use_prefix) const$/;"	f	class:openvpn::AuthCert::Fail
to_string	auth/authcert.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::AuthCert
to_string	auth/authcreds.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::AuthCreds
to_string	buffer/buflist.hpp	/^    std::string to_string() const$/;"	f	struct:openvpn::BufferCollection
to_string	buffer/safestr.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::SafeString
to_string	client/cliopthelper.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::ParseClientConfig
to_string	client/remotelist.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::RemoteList::Item
to_string	client/remotelist.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::RemoteList::ResolvedAddr
to_string	client/remotelist.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::RemoteList::ResolvedAddrList
to_string	client/remotelist.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::RemoteList
to_string	client/rgopt.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::RedirectGatewayFlags
to_string	common/action.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::ActionList
to_string	common/argv.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::Argv
to_string	common/format.hpp	/^  inline std::string to_string(T value)$/;"	f	namespace:openvpn
to_string	common/format.hpp	/^  inline std::string to_string(const T& value)$/;"	f	namespace:openvpn
to_string	common/hostlist.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::HostList::List
to_string	common/hostlist.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::HostList::Host
to_string	common/process.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::Environ
to_string	http/header.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::HTTP::Header
to_string	http/header.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::HTTP::HeaderList
to_string	http/reply.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::HTTP::Reply
to_string	http/request.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::HTTP::Request
to_string	http/status.hpp	/^      inline const char *to_string(const int status)$/;"	f	namespace:openvpn::HTTP::Status
to_string	http/urlparm.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::URL::ParmList
to_string	http/urlparm.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::URL::Parm
to_string	http/urlparse.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::URL::Parse
to_string	log/logperiod.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::LogPeriod
to_string	netconf/enumiface.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::EnumIface
to_string	pki/x509track.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::X509Track::Config
to_string	pki/x509track.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::X509Track::ConfigSet
to_string	pki/x509track.hpp	/^      std::string to_string(const bool omi_form) const$/;"	f	struct:openvpn::X509Track::KeyValue
to_string	pki/x509track.hpp	/^      std::string to_string(const bool omi_form) const$/;"	f	struct:openvpn::X509Track::Set
to_string	proxy/proxyauth.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::HTTPProxy::ProxyAuthenticate
to_string	server/listenlist.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::Listen::Item
to_string	server/peeraddr.hpp	/^    std::string to_string() const$/;"	f	struct:openvpn::AddrPort
to_string	server/peeraddr.hpp	/^    std::string to_string() const$/;"	f	struct:openvpn::PeerAddr
to_string	server/vpnservnetblock.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::VPNServerNetblock::Netblock
to_string	server/vpnservnetblock.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::VPNServerNetblock
to_string	server/vpnservpool.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::VPNServerPool::IP46
to_string	ssl/peerinfo.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::PeerInfo::KeyValue
to_string	ssl/peerinfo.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::PeerInfo::Set
to_string	ssl/tlsver.hpp	/^    inline const std::string to_string(const Type version)$/;"	f	namespace:openvpn::TLSVersion
to_string	transport/gremlin.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::Gremlin::Config
to_string	tun/builder/capture.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture::DNSServer
to_string	tun/builder/capture.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture::ProxyAutoConfigURL
to_string	tun/builder/capture.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture::ProxyBypass
to_string	tun/builder/capture.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture::ProxyHostPort
to_string	tun/builder/capture.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture::RemoteAddress
to_string	tun/builder/capture.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture::RerouteGW
to_string	tun/builder/capture.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture::RouteBase
to_string	tun/builder/capture.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture::SearchDomain
to_string	tun/builder/capture.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture::WINSServer
to_string	tun/builder/capture.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::TunBuilderCapture
to_string	tun/ipv6_setting.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::IPv6Setting
to_string	tun/mac/macdns.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::MacDNS::Config
to_string	tun/mac/macdns.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::MacDNS::DSDict
to_string	tun/mac/macdns.hpp	/^      std::string to_string() const$/;"	f	class:openvpn::MacDNS::Info
to_string	tun/mac/macdns.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::MacDNS
to_string	tun/mac/macdns_watchdog.hpp	/^      virtual std::string to_string() const$/;"	f	class:openvpn::MacDNSWatchdog::DNSAction
to_string	tun/mac/macdns_watchdog.hpp	/^    std::string to_string() const$/;"	f	class:openvpn::MacDNSWatchdog
to_string	tun/mac/macgw.hpp	/^      std::string to_string() const$/;"	f	struct:openvpn::MacGWInfo::Variant
to_string	tun/mac/macgw.hpp	/^    std::string to_string() const$/;"	f	struct:openvpn::MacGWInfo
to_string	tun/win/tunutil.hpp	/^	std::string to_string() const$/;"	f	struct:openvpn::TunWin::Util::TapNameGuidPairList
to_string	tun/win/tunutil.hpp	/^	std::string to_string()$/;"	f	class:openvpn::TunWin::Util::TAPDriverVersion
to_string_bracket_ipv6	addr/ip.hpp	/^      std::string to_string_bracket_ipv6() const$/;"	f	class:openvpn::IP::Addr
to_string_by_netmask	addr/route.hpp	/^      std::string to_string_by_netmask() const$/;"	f	struct:openvpn::IP::RouteType
to_string_compact	http/request.hpp	/^      std::string to_string_compact() const$/;"	f	struct:openvpn::HTTP::Request
to_string_verbose	log/logperiod.hpp	/^    std::string to_string_verbose() const$/;"	f	class:openvpn::LogPeriod
to_time_point	time/asiotimer.hpp	/^    static time_point to_time_point(const Time& t)$/;"	f	struct:openvpn::AsioClock
to_uint32	addr/ipv4.hpp	/^      std::uint32_t to_uint32() const \/\/ host byte order$/;"	f	class:openvpn::IPv4::Addr
to_uint32_net	addr/ip.hpp	/^      std::uint32_t to_uint32_net() const \/\/ return value in net byte order$/;"	f	class:openvpn::IP::Addr
to_uint32_net	addr/ipv4.hpp	/^      std::uint32_t to_uint32_net() const \/\/ return value in net byte order$/;"	f	class:openvpn::IPv4::Addr
to_ulong	addr/ip.hpp	/^      unsigned long to_ulong() const$/;"	f	class:openvpn::IP::Addr
to_ulong	addr/ipv4.hpp	/^      unsigned long to_ulong() const$/;"	f	class:openvpn::IPv4::Addr
to_ulong	addr/ipv6.hpp	/^      unsigned long to_ulong() const$/;"	f	class:openvpn::IPv6::Addr
to_upper	common/string.hpp	/^    inline void to_upper(std::string& str)$/;"	f	namespace:openvpn::string
to_upper_copy	common/string.hpp	/^    inline std::string to_upper_copy(const std::string& str)$/;"	f	namespace:openvpn::string
to_utf8	common/wstring.hpp	/^    inline std::string to_utf8(const std::wstring& wstr)$/;"	f	namespace:openvpn::wstring
to_wchar_t	common/wstring.hpp	/^    inline std::unique_ptr<wchar_t[]> to_wchar_t(const std::wstring& wstr)$/;"	f	namespace:openvpn::wstring
token_decode	common/base64.hpp	/^    unsigned int token_decode(const char *token, unsigned int& marker) const$/;"	f	class:openvpn::Base64
tos	ip/ip.hpp	/^    std::uint8_t    tos;$/;"	m	struct:openvpn::IPHeader
tot_len	ip/ip.hpp	/^    std::uint16_t   tot_len;$/;"	m	struct:openvpn::IPHeader
total_length	buffer/memq.hpp	/^    size_t total_length() const { return length; }$/;"	f	class:openvpn::MemQBase
total_threads	server/listenlist.hpp	/^      unsigned int total_threads() const$/;"	f	class:openvpn::Listen::List
touch	common/options.hpp	/^    void touch() const$/;"	f	class:openvpn::Option
touch	common/options.hpp	/^    void touch(const std::string& name) const$/;"	f	class:openvpn::OptionList
touched	common/options.hpp	/^    bool touched() const { return touched_; }$/;"	f	class:openvpn::Option
touched_	common/options.hpp	/^    volatile mutable bool touched_ = false;$/;"	m	class:openvpn::Option
trail	buffer/safestr.hpp	/^    void trail()$/;"	f	class:openvpn::SafeString
trailingBytesForUTF8	common/unicode-impl.hpp	/^    const char trailingBytesForUTF8[256] = {$/;"	m	namespace:openvpn::Unicode
transact	common/redir.hpp	/^    void transact(InOut& inout)$/;"	f	class:openvpn::RedirectPipe
transition	ssl/datalimit.hpp	/^      State transition(State s) const$/;"	f	class:openvpn::DataLimit::Component
transport	client/cliproto.hpp	/^      TransportClient::Ptr transport;$/;"	m	class:openvpn::ClientProto::Session
transport_connecting	client/cliproto.hpp	/^      virtual void transport_connecting()$/;"	f	class:openvpn::ClientProto::Session
transport_error	client/cliproto.hpp	/^      virtual void transport_error(const Error::Type fatal_err, const std::string& err_text)$/;"	f	class:openvpn::ClientProto::Session
transport_factory	client/cliopt.hpp	/^    TransportClientFactory::Ptr transport_factory;$/;"	m	class:openvpn::ClientOptions
transport_factory	client/cliproto.hpp	/^	TransportClientFactory::Ptr transport_factory;$/;"	m	struct:openvpn::ClientProto::Session::Config
transport_factory	client/cliproto.hpp	/^      TransportClientFactory::Ptr transport_factory;$/;"	m	class:openvpn::ClientProto::Session
transport_has_send_queue	client/cliproto.hpp	/^      bool transport_has_send_queue = false;$/;"	m	class:openvpn::ClientProto::Session
transport_has_send_queue	transport/client/httpcli.hpp	/^      virtual bool transport_has_send_queue()$/;"	f	class:openvpn::HTTPProxyTransport::Client
transport_has_send_queue	transport/client/tcpcli.hpp	/^      virtual bool transport_has_send_queue()$/;"	f	class:openvpn::TCPTransport::Client
transport_has_send_queue	transport/client/udpcli.hpp	/^      virtual bool transport_has_send_queue()$/;"	f	class:openvpn::UDPTransport::Client
transport_is_openvpn_protocol	client/cliproto.hpp	/^      virtual bool transport_is_openvpn_protocol()$/;"	f	class:openvpn::ClientProto::Session
transport_match	transport/protocol.hpp	/^    bool transport_match(const Protocol& other) const$/;"	f	class:openvpn::Protocol
transport_needs_send	client/cliproto.hpp	/^      virtual void transport_needs_send()$/;"	f	class:openvpn::ClientProto::Session
transport_pre_resolve	client/cliproto.hpp	/^      virtual void transport_pre_resolve()$/;"	f	class:openvpn::ClientProto::Session
transport_proto	transport/protocol.hpp	/^    int transport_proto() const$/;"	f	class:openvpn::Protocol
transport_protocol	client/remotelist.hpp	/^      Protocol transport_protocol;$/;"	m	struct:openvpn::RemoteList::Item
transport_recv	client/cliproto.hpp	/^      virtual void transport_recv(BufferAllocated& buf)$/;"	f	class:openvpn::ClientProto::Session
transport_recv	server/servproto.hpp	/^      virtual bool transport_recv(BufferAllocated& buf)$/;"	f	class:openvpn::ServerProto::Session
transport_send	transport/client/httpcli.hpp	/^      virtual bool transport_send(BufferAllocated& buf)$/;"	f	class:openvpn::HTTPProxyTransport::Client
transport_send	transport/client/tcpcli.hpp	/^      virtual bool transport_send(BufferAllocated& buf)$/;"	f	class:openvpn::TCPTransport::Client
transport_send	transport/client/udpcli.hpp	/^      virtual bool transport_send(BufferAllocated& buf)$/;"	f	class:openvpn::UDPTransport::Client
transport_send_const	transport/client/httpcli.hpp	/^      virtual bool transport_send_const(const Buffer& buf)$/;"	f	class:openvpn::HTTPProxyTransport::Client
transport_send_const	transport/client/tcpcli.hpp	/^      virtual bool transport_send_const(const Buffer& buf)$/;"	f	class:openvpn::TCPTransport::Client
transport_send_const	transport/client/udpcli.hpp	/^      virtual bool transport_send_const(const Buffer& buf)$/;"	f	class:openvpn::UDPTransport::Client
transport_send_queue_empty	transport/client/httpcli.hpp	/^      virtual bool transport_send_queue_empty()$/;"	f	class:openvpn::HTTPProxyTransport::Client
transport_send_queue_empty	transport/client/tcpcli.hpp	/^      virtual bool transport_send_queue_empty()$/;"	f	class:openvpn::TCPTransport::Client
transport_send_queue_empty	transport/client/udpcli.hpp	/^      virtual bool transport_send_queue_empty() \/\/ really only has meaning for TCP$/;"	f	class:openvpn::UDPTransport::Client
transport_send_queue_size	transport/client/httpcli.hpp	/^      virtual unsigned int transport_send_queue_size()$/;"	f	class:openvpn::HTTPProxyTransport::Client
transport_send_queue_size	transport/client/tcpcli.hpp	/^      virtual unsigned int transport_send_queue_size()$/;"	f	class:openvpn::TCPTransport::Client
transport_send_queue_size	transport/client/udpcli.hpp	/^      virtual unsigned int transport_send_queue_size()$/;"	f	class:openvpn::UDPTransport::Client
transport_start	transport/client/httpcli.hpp	/^      virtual void transport_start()$/;"	f	class:openvpn::HTTPProxyTransport::Client
transport_start	transport/client/tcpcli.hpp	/^      virtual void transport_start()$/;"	f	class:openvpn::TCPTransport::Client
transport_start	transport/client/udpcli.hpp	/^      virtual void transport_start()$/;"	f	class:openvpn::UDPTransport::Client
transport_wait	client/cliproto.hpp	/^      virtual void transport_wait()$/;"	f	class:openvpn::ClientProto::Session
transport_wait_proxy	client/cliproto.hpp	/^      virtual void transport_wait_proxy()$/;"	f	class:openvpn::ClientProto::Session
trim	common/string.hpp	/^    inline void trim(std::string& str)$/;"	f	namespace:openvpn::string
trim_copy	common/string.hpp	/^    inline std::string trim_copy(const std::string& str)$/;"	f	namespace:openvpn::string
trim_crlf	common/string.hpp	/^    inline void trim_crlf(std::string& str)$/;"	f	namespace:openvpn::string
trim_crlf_copy	common/string.hpp	/^    inline std::string trim_crlf_copy(std::string str)$/;"	f	namespace:openvpn::string
trim_left	common/string.hpp	/^    inline void trim_left(std::string& str)$/;"	f	namespace:openvpn::string
trim_left_copy	common/string.hpp	/^    inline std::string trim_left_copy(const std::string& str)$/;"	f	namespace:openvpn::string
ttl	ip/ip.hpp	/^    std::uint8_t    ttl;$/;"	m	struct:openvpn::IPHeader
tun	client/cliproto.hpp	/^      TunClient::Ptr tun;$/;"	m	class:openvpn::ClientProto::Session
tun_builder_add_address	tun/builder/base.hpp	/^    virtual bool tun_builder_add_address(const std::string& address,$/;"	f	class:openvpn::TunBuilderBase
tun_builder_add_dns_server	tun/builder/base.hpp	/^    virtual bool tun_builder_add_dns_server(const std::string& address, bool ipv6)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_add_proxy_bypass	tun/builder/base.hpp	/^    virtual bool tun_builder_add_proxy_bypass(const std::string& bypass_host)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_add_route	tun/builder/base.hpp	/^    virtual bool tun_builder_add_route(const std::string& address,$/;"	f	class:openvpn::TunBuilderBase
tun_builder_add_search_domain	tun/builder/base.hpp	/^    virtual bool tun_builder_add_search_domain(const std::string& domain)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_add_wins_server	tun/builder/base.hpp	/^    virtual bool tun_builder_add_wins_server(const std::string& address)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_establish	tun/builder/base.hpp	/^    virtual int tun_builder_establish()$/;"	f	class:openvpn::TunBuilderBase
tun_builder_establish_lite	tun/builder/base.hpp	/^    virtual void tun_builder_establish_lite()$/;"	f	class:openvpn::TunBuilderBase
tun_builder_exclude_route	tun/builder/base.hpp	/^    virtual bool tun_builder_exclude_route(const std::string& address,$/;"	f	class:openvpn::TunBuilderBase
tun_builder_new	tun/builder/base.hpp	/^    virtual bool tun_builder_new()$/;"	f	class:openvpn::TunBuilderBase
tun_builder_persist	tun/builder/base.hpp	/^    virtual bool tun_builder_persist()$/;"	f	class:openvpn::TunBuilderBase
tun_builder_reroute_gw	tun/builder/base.hpp	/^    virtual bool tun_builder_reroute_gw(bool ipv4,$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_adapter_domain_suffix	tun/builder/base.hpp	/^    virtual bool tun_builder_set_adapter_domain_suffix(const std::string& name)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_block_ipv6	tun/builder/base.hpp	/^    virtual bool tun_builder_set_block_ipv6(bool block_ipv6)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_layer	tun/builder/base.hpp	/^    virtual bool tun_builder_set_layer(int layer)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_mtu	tun/builder/base.hpp	/^    virtual bool tun_builder_set_mtu(int mtu)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_proxy_auto_config_url	tun/builder/base.hpp	/^    virtual bool tun_builder_set_proxy_auto_config_url(const std::string& url)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_proxy_http	tun/builder/base.hpp	/^    virtual bool tun_builder_set_proxy_http(const std::string& host, int port)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_proxy_https	tun/builder/base.hpp	/^    virtual bool tun_builder_set_proxy_https(const std::string& host, int port)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_remote_address	tun/builder/base.hpp	/^    virtual bool tun_builder_set_remote_address(const std::string& address, bool ipv6)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_route_metric_default	tun/builder/base.hpp	/^    virtual bool tun_builder_set_route_metric_default(int metric)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_set_session_name	tun/builder/base.hpp	/^    virtual bool tun_builder_set_session_name(const std::string& name)$/;"	f	class:openvpn::TunBuilderBase
tun_builder_teardown	tun/builder/base.hpp	/^    virtual void tun_builder_teardown(bool disconnect) {}$/;"	f	class:openvpn::TunBuilderBase
tun_config	tun/linux/client/tuncli.hpp	/^    inline void tun_config(const std::string& iface_name,$/;"	f	namespace:openvpn::TunLinux
tun_config	tun/mac/client/tunsetup.hpp	/^      static void tun_config(const std::string& iface_name,$/;"	f	class:openvpn::TunMac::Setup
tun_connected	client/cliproto.hpp	/^      virtual void tun_connected()$/;"	f	class:openvpn::ClientProto::Session
tun_error	client/cliproto.hpp	/^      virtual void tun_error(const Error::Type fatal_err, const std::string& err_text)$/;"	f	class:openvpn::ClientProto::Session
tun_error	tun/tunio.hpp	/^    void tun_error(const Error::Type errtype, const asio::error_code* error)$/;"	f	class:openvpn::TunIO
tun_error_handler	tun/builder/client.hpp	/^      void tun_error_handler(const Error::Type errtype, \/\/ called by TunImpl$/;"	f	class:openvpn::TunBuilderClient::Client
tun_error_handler	tun/linux/client/tuncli.hpp	/^      void tun_error_handler(const Error::Type errtype, \/\/ called by TunImpl$/;"	f	class:openvpn::TunLinux::Client
tun_error_handler	tun/mac/client/tuncli.hpp	/^      void tun_error_handler(const Error::Type errtype, \/\/ called by TunImpl$/;"	f	class:openvpn::TunMac::Client
tun_error_handler	tun/win/client/tuncli.hpp	/^      void tun_error_handler(const Error::Type errtype, \/\/ called by TunImpl$/;"	f	class:openvpn::TunWin::Client
tun_factory	client/cliopt.hpp	/^    TunClientFactory::Ptr tun_factory;$/;"	m	class:openvpn::ClientOptions
tun_factory	client/cliproto.hpp	/^	TunClientFactory::Ptr tun_factory;$/;"	m	struct:openvpn::ClientProto::Session::Config
tun_factory	client/cliproto.hpp	/^      TunClientFactory::Ptr tun_factory;$/;"	m	class:openvpn::ClientProto::Session
tun_factory	server/servproto.hpp	/^      TunClientInstanceFactory::Ptr tun_factory;$/;"	m	class:openvpn::ServerProto::Factory
tun_factory	server/servproto.hpp	/^      TunClientInstanceFactory::Ptr tun_factory;$/;"	m	class:openvpn::ServerProto::Session
tun_ifconfig	tun/client/tunprop.hpp	/^    static IP::Addr::VersionMask tun_ifconfig(TunBuilderBase* tb,$/;"	f	class:openvpn::TunProp
tun_mtu	ssl/proto.hpp	/^      unsigned int tun_mtu = 1500;$/;"	m	class:openvpn::ProtoContext::Config
tun_name	client/clievent.hpp	/^      std::string tun_name;$/;"	m	struct:openvpn::ClientEvent::Connected
tun_name	tun/client/tunnull.hpp	/^      virtual std::string tun_name() const$/;"	f	class:openvpn::TunNull::Client
tun_name	tun/linux/client/tuncli.hpp	/^      virtual std::string tun_name() const$/;"	f	class:openvpn::TunLinux::Client
tun_name	tun/tunspec.hpp	/^    std::string tun_name;$/;"	m	struct:openvpn::ParseTunSpec
tun_persist	client/cliopt.hpp	/^      bool tun_persist = false;$/;"	m	struct:openvpn::ClientOptions::Config
tun_persist	tun/builder/client.hpp	/^      TunPersist::Ptr tun_persist; \/\/ owns the tun socket descriptor$/;"	m	class:openvpn::TunBuilderClient::Client
tun_persist	tun/builder/client.hpp	/^      TunPersist::Ptr tun_persist;$/;"	m	class:openvpn::TunBuilderClient::ClientConfig
tun_persist	tun/mac/client/tuncli.hpp	/^      TunPersist::Ptr tun_persist; \/\/ contains the tun device fd$/;"	m	class:openvpn::TunMac::Client
tun_persist	tun/mac/client/tuncli.hpp	/^      TunPersist::Ptr tun_persist;$/;"	m	class:openvpn::TunMac::ClientConfig
tun_persist	tun/win/client/tuncli.hpp	/^      TunPersist::Ptr tun_persist; \/\/ contains the TAP device HANDLE$/;"	m	class:openvpn::TunWin::Client
tun_persist	tun/win/client/tuncli.hpp	/^      TunPersist::Ptr tun_persist;$/;"	m	class:openvpn::TunWin::ClientConfig
tun_pre_route_config	client/cliproto.hpp	/^      virtual void tun_pre_route_config()$/;"	f	class:openvpn::ClientProto::Session
tun_pre_tun_config	client/cliproto.hpp	/^      virtual void tun_pre_tun_config()$/;"	f	class:openvpn::ClientProto::Session
tun_prefix	tun/builder/client.hpp	/^      bool tun_prefix;$/;"	m	class:openvpn::TunBuilderClient::ClientConfig
tun_prefix	tun/client/tunprop.hpp	/^      bool tun_prefix = false;$/;"	m	struct:openvpn::TunProp::State
tun_prefix	tun/mac/client/tunsetup.hpp	/^	bool tun_prefix = false;$/;"	m	struct:openvpn::TunMac::Setup::Config
tun_prefix	tun/tunio.hpp	/^    bool tun_prefix;$/;"	m	class:openvpn::TunIO
tun_prop	transport/dco.hpp	/^      TunProp::Config tun_prop;$/;"	m	struct:openvpn::DCO::TunConfig
tun_prop	tun/builder/client.hpp	/^      TunProp::Config tun_prop;$/;"	m	class:openvpn::TunBuilderClient::ClientConfig
tun_prop	tun/linux/client/tuncli.hpp	/^      TunProp::Config tun_prop;$/;"	m	class:openvpn::TunLinux::ClientConfig
tun_prop	tun/mac/client/tuncli.hpp	/^      TunProp::Config tun_prop;$/;"	m	class:openvpn::TunMac::ClientConfig
tun_prop	tun/win/client/tuncli.hpp	/^      TunProp::Config tun_prop;$/;"	m	class:openvpn::TunWin::ClientConfig
tun_read_handler	tun/builder/client.hpp	/^      void tun_read_handler(PacketFrom::SPtr& pfp) \/\/ called by TunImpl$/;"	f	class:openvpn::TunBuilderClient::Client
tun_read_handler	tun/linux/client/tuncli.hpp	/^      void tun_read_handler(PacketFrom::SPtr& pfp) \/\/ called by TunImpl$/;"	f	class:openvpn::TunLinux::Client
tun_read_handler	tun/mac/client/tuncli.hpp	/^      void tun_read_handler(PacketFrom::SPtr& pfp) \/\/ called by TunImpl$/;"	f	class:openvpn::TunMac::Client
tun_read_handler	tun/win/client/tuncli.hpp	/^      void tun_read_handler(PacketFrom::SPtr& pfp) \/\/ called by TunImpl$/;"	f	class:openvpn::TunWin::Client
tun_recv	client/cliproto.hpp	/^      virtual void tun_recv(BufferAllocated& buf)$/;"	f	class:openvpn::ClientProto::Session
tun_recv	server/servproto.hpp	/^      virtual void tun_recv(BufferAllocated& buf)$/;"	f	class:openvpn::ServerProto::Session
tun_send	tun/client/tunnull.hpp	/^      virtual bool tun_send(BufferAllocated& buf)$/;"	f	class:openvpn::TunNull::Client
tun_send	tun/linux/client/tuncli.hpp	/^      virtual bool tun_send(BufferAllocated& buf)$/;"	f	class:openvpn::TunLinux::Client
tun_set_disconnect	client/cliproto.hpp	/^      void tun_set_disconnect()$/;"	f	class:openvpn::ClientProto::Session
tun_setup	tun/mac/client/tuncli.hpp	/^      TunBuilderSetup::Base::Ptr tun_setup;$/;"	m	class:openvpn::TunMac::Client
tun_setup	tun/win/client/tuncli.hpp	/^      TunWin::SetupBase::Ptr tun_setup;$/;"	m	class:openvpn::TunWin::Client
tun_setup_factory	tun/mac/client/tuncli.hpp	/^      TunBuilderSetup::Factory::Ptr tun_setup_factory;$/;"	m	class:openvpn::TunMac::ClientConfig
tun_setup_factory	tun/win/client/tuncli.hpp	/^      TunWin::SetupFactory::Ptr tun_setup_factory;$/;"	m	class:openvpn::TunWin::ClientConfig
tun_start	tun/client/tunnull.hpp	/^      virtual void tun_start(const OptionList& opt, TransportClient& transcli, CryptoDCSettings&)$/;"	f	class:openvpn::TunNull::Client
tun_start	tun/linux/client/tuncli.hpp	/^      virtual void tun_start(const OptionList& opt, TransportClient& transcli, CryptoDCSettings&)$/;"	f	class:openvpn::TunLinux::Client
tun_wrap	tun/persist/tunwrapasio.hpp	/^    typename TunWrap::Ptr tun_wrap;$/;"	m	class:openvpn::TunWrapAsioStream
tunnel_address_index_ipv4	tun/builder/capture.hpp	/^    int tunnel_address_index_ipv4 = -1;    \/\/ index into tunnel_addresses for IPv4 entry (or -1 if undef)$/;"	m	class:openvpn::TunBuilderCapture
tunnel_address_index_ipv6	tun/builder/capture.hpp	/^    int tunnel_address_index_ipv6 = -1;    \/\/ index into tunnel_addresses for IPv6 entry (or -1 if undef)$/;"	m	class:openvpn::TunBuilderCapture
tunnel_addresses	tun/builder/capture.hpp	/^    std::vector<RouteAddress> tunnel_addresses;   \/\/ local tunnel addresses$/;"	m	class:openvpn::TunBuilderCapture
tuntap_open	tun/mac/tunutil.hpp	/^      inline int tuntap_open(const Layer& layer, std::string& name)$/;"	f	namespace:openvpn::TunMac::Util
tx_bytes	server/peerstats.hpp	/^    std::uint64_t tx_bytes;$/;"	m	struct:openvpn::PeerStats
txqueuelen	tun/linux/client/tuncli.hpp	/^      int txqueuelen = 200;$/;"	m	class:openvpn::TunLinux::ClientConfig
type	applecrypto/crypto/digest.hpp	/^      CryptoAlgs::Type type() const { return type_; }$/;"	f	class:openvpn::AppleCrypto::DigestInfo
type	buffer/buffer.hpp	/^    typedef T* type;$/;"	t	class:openvpn::BufferType
type	compress/compress.hpp	/^    Type type() const { return type_; }$/;"	f	class:openvpn::CompressContext
type	ip/icmp.hpp	/^    std::uint8_t type;$/;"	m	struct:openvpn::ICMP
type	pki/x509track.hpp	/^      Type type = UNDEF;$/;"	m	struct:openvpn::X509Track::KeyValue
type	pki/x509track.hpp	/^      Type type;$/;"	m	struct:openvpn::X509Track::Config
type	time/time.hpp	/^    typedef T type;$/;"	t	class:openvpn::TimeType
type_	applecrypto/crypto/digest.hpp	/^      CryptoAlgs::Type type_;$/;"	m	class:openvpn::AppleCrypto::DigestInfo
type_	common/mode.hpp	/^    Type type_;$/;"	m	class:openvpn::Mode
type_	compress/compress.hpp	/^    Type type_;$/;"	m	class:openvpn::CompressContext
type_	transport/protocol.hpp	/^    Type type_;$/;"	m	class:openvpn::Protocol
type_	tun/ipv6_setting.hpp	/^    Type type_ = DEFAULT;$/;"	m	class:openvpn::IPv6Setting
type_	tun/layer.hpp	/^    Type type_;$/;"	m	class:openvpn::Layer
u	addr/ip.hpp	/^      } u;$/;"	m	class:openvpn::IP::Addr	typeref:union:openvpn::IP::Addr::__anon2
u	addr/ipv4.hpp	/^      } u;$/;"	m	class:openvpn::IPv4::Addr	typeref:union:openvpn::IPv4::Addr::__anon4
u	addr/ipv6.hpp	/^      union ipv6addr u;$/;"	m	class:openvpn::IPv6::Addr	typeref:union:openvpn::IPv6::Addr::ipv6addr
u	applecrypto/crypto/digest.hpp	/^      } u;$/;"	m	struct:openvpn::AppleCrypto::DigestCTX	typeref:union:openvpn::AppleCrypto::DigestCTX::__anon9
u32	addr/ipv6.hpp	/^	std::uint32_t u32[4]; \/\/ generally stored in host byte order$/;"	m	union:openvpn::IPv6::Addr::ipv6addr
u64	addr/ipv6.hpp	/^	std::uint64_t u64[2];$/;"	m	union:openvpn::IPv6::Addr::ipv6addr
udp	ip/dhcp.hpp	/^    UDPHeader udp;$/;"	m	struct:openvpn::DHCPPacket
udp_checksum	ip/udp.hpp	/^  inline std::uint16_t udp_checksum (const std::uint8_t *buf,$/;"	f	namespace:openvpn
udp_read_handler	transport/client/udpcli.hpp	/^      void udp_read_handler(PacketFrom::SPtr& pfp) \/\/ called by LinkImpl$/;"	f	class:openvpn::UDPTransport::Client
uid	common/peercred.hpp	/^      int uid;$/;"	m	struct:openvpn::SockOpt::Creds
uid	common/usergroup.hpp	/^    int uid() const$/;"	f	class:openvpn::SetUserGroup
umask_save	common/umask.hpp	/^    mode_t umask_save;$/;"	m	class:openvpn::UMask
unblock	tun/win/wfp.hpp	/^      void unblock(std::ostream& log)$/;"	f	class:openvpn::TunWin::WFPContext
undefined	common/scoped_asio_stream.hpp	/^    static STREAM* undefined() { return nullptr; }$/;"	f	class:openvpn::ScopedAsioStream
undefined	common/scoped_fd.hpp	/^    static int undefined() { return -1; }$/;"	f	class:openvpn::ScopedFD
undefined	win/handle.hpp	/^      inline HANDLE undefined()$/;"	f	namespace:openvpn::Win::Handle
unescape	common/options.hpp	/^      static std::string unescape(const std::string& value, bool& newline_present)$/;"	f	class:openvpn::OptionList::KeyValue
uninit	init/initprocess.hpp	/^    inline void uninit()$/;"	f	namespace:openvpn::InitProcess
unit	crypto/packet_id.hpp	/^    int unit;                       \/\/ unit number of this object (for debugging)$/;"	m	class:openvpn::PacketIDReceiveType
unix2dos	common/string.hpp	/^    inline std::string unix2dos(const std::string& str, const bool force_eol=false)$/;"	f	namespace:openvpn::string
unlikely	common/likely.hpp	/^# define unlikely(/;"	d
unspecified	addr/ip.hpp	/^      bool unspecified() const$/;"	f	class:openvpn::IP::Addr
unspecified	addr/ipv4.hpp	/^      bool unspecified() const$/;"	f	class:openvpn::IPv4::Addr
unspecified	addr/ipv6.hpp	/^      bool unspecified() const$/;"	f	class:openvpn::IPv6::Addr
unsupported_in_connection_block	client/remotelist.hpp	/^    void unsupported_in_connection_block(const OptionList& options, const std::string& option)$/;"	f	class:openvpn::RemoteList
untag_open_meta_tag	common/options.hpp	/^    static void untag_open_meta_tag(std::string& str)$/;"	f	class:openvpn::OptionList
untag_open_tag	common/options.hpp	/^    static void untag_open_tag(std::string& str)$/;"	f	class:openvpn::OptionList
until_retransmit	reliable/relsend.hpp	/^      Time::Duration until_retransmit(const Time& now) const$/;"	f	class:openvpn::ReliableSendTemplate::Message
until_retransmit	reliable/relsend.hpp	/^    Time::Duration until_retransmit(const Time& now)$/;"	f	class:openvpn::ReliableSendTemplate
up_sequenced	ssl/protostack.hpp	/^    void up_sequenced()$/;"	f	class:openvpn::ProtoStackBase
up_stack	ssl/protostack.hpp	/^    bool up_stack(PACKET& recv)$/;"	f	class:openvpn::ProtoStackBase
up_stack_reentry_level	ssl/protostack.hpp	/^    int up_stack_reentry_level;$/;"	m	class:openvpn::ProtoStackBase
upcoming_key_id	ssl/proto.hpp	/^    unsigned int upcoming_key_id;$/;"	m	class:openvpn::ProtoContext
update	applecrypto/crypto/cipher.hpp	/^      bool update(unsigned char *out, const size_t max_out_size,$/;"	f	class:openvpn::AppleCrypto::CipherContext
update	applecrypto/crypto/digest.hpp	/^      void update(const unsigned char *in, const size_t size)$/;"	f	class:openvpn::AppleCrypto::DigestContext
update	applecrypto/crypto/hmac.hpp	/^      void update(const unsigned char *in, const size_t size)$/;"	f	class:openvpn::AppleCrypto::HMACContext
update	crypto/digestapi.hpp	/^    virtual void update(const unsigned char *in, const size_t size)$/;"	f	class:openvpn::CryptoDigestInstance
update	crypto/digestapi.hpp	/^    virtual void update(const unsigned char *in, const size_t size)$/;"	f	class:openvpn::CryptoHMACInstance
update	crypto/hashstr.hpp	/^    void update(const Buffer& buf)$/;"	f	class:openvpn::HashString
update	crypto/hashstr.hpp	/^    void update(const char *str)$/;"	f	class:openvpn::HashString
update	crypto/hashstr.hpp	/^    void update(const char c)$/;"	f	class:openvpn::HashString
update	crypto/hashstr.hpp	/^    void update(const std::string& str)$/;"	f	class:openvpn::HashString
update	openssl/crypto/cipher.hpp	/^      bool update(unsigned char *out, const size_t max_out_size,$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
update	openssl/crypto/digest.hpp	/^      void update(const unsigned char *in, const size_t size)$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
update	openssl/crypto/hmac.hpp	/^      void update(const unsigned char *in, const size_t size)$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
update	polarssl/crypto/cipher.hpp	/^      bool update(unsigned char *out, const size_t max_out_size,$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
update	polarssl/crypto/digest.hpp	/^      void update(const unsigned char *in, const size_t size)$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
update	polarssl/crypto/hmac.hpp	/^      void update(const unsigned char *in, const size_t size)$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
update	time/time.hpp	/^    void update() { time_ = now_(); }$/;"	f	class:openvpn::TimeType
update_last_packet_received	log/sessionstats.hpp	/^    void update_last_packet_received(const Time& now)$/;"	f	class:openvpn::SessionStats
update_last_received	ssl/proto.hpp	/^    void update_last_received()$/;"	f	class:openvpn::ProtoContext
update_last_sent	ssl/proto.hpp	/^    void update_last_sent()$/;"	f	class:openvpn::ProtoContext
update_map	common/options.hpp	/^    void update_map()$/;"	f	class:openvpn::OptionList
update_now	client/cliopt.hpp	/^    void update_now()$/;"	f	class:openvpn::ClientOptions
update_now	ssl/proto.hpp	/^    void update_now() { now_->update(); }$/;"	f	class:openvpn::ProtoContext
update_retransmit	ssl/protostack.hpp	/^    void update_retransmit()$/;"	f	class:openvpn::ProtoStackBase
update_state	ssl/datalimit.hpp	/^      State update_state(const State newstate)$/;"	f	class:openvpn::DataLimit::Component
update_state	ssl/datalimit.hpp	/^    State update_state(const Mode mode, const State newstate)$/;"	f	class:openvpn::DataLimit
update_trust	openssl/ssl/sslctx.hpp	/^    void update_trust(const CertCRLList& cc)$/;"	f	class:openvpn::OpenSSLContext
uri	http/request.hpp	/^	  uri,$/;"	e	enum:openvpn::HTTP::RequestParser::state
uri	http/request.hpp	/^      std::string uri;$/;"	m	struct:openvpn::HTTP::Request
uri	http/urlparse.hpp	/^      std::string uri;$/;"	m	class:openvpn::URL::Parse
url	tun/builder/capture.hpp	/^      std::string url;$/;"	m	class:openvpn::TunBuilderCapture::ProxyAutoConfigURL
use_persisted_tun	tun/persist/tunpersist.hpp	/^    bool use_persisted_tun(const IP::Addr server_addr,$/;"	f	class:openvpn::TunPersistTemplate
use_persisted_tun_	tun/persist/tunpersist.hpp	/^    bool use_persisted_tun_;$/;"	m	class:openvpn::TunPersistTemplate
use_tls_auth	ssl/proto.hpp	/^    bool use_tls_auth;$/;"	m	class:openvpn::ProtoContext
user	client/clievent.hpp	/^      std::string user;$/;"	m	struct:openvpn::ClientEvent::Connected
user_agent	transport/client/httpcli.hpp	/^      std::string user_agent;$/;"	m	class:openvpn::HTTPProxyTransport::Options
user_name	common/usergroup.hpp	/^    std::string user_name;$/;"	m	class:openvpn::SetUserGroup
userlockedUsername	client/cliopthelper.hpp	/^    const std::string& userlockedUsername() const { return userlockedUsername_; }$/;"	f	class:openvpn::ParseClientConfig
userlockedUsername_	client/cliopthelper.hpp	/^    std::string userlockedUsername_;$/;"	m	class:openvpn::ParseClientConfig
userlocked_username	client/cliopt.hpp	/^    std::string userlocked_username;$/;"	m	class:openvpn::ClientOptions
username	auth/authcreds.hpp	/^      std::string username;$/;"	m	class:openvpn::AuthCreds
username	auth/cr.hpp	/^    std::string username;$/;"	m	class:openvpn::ChallengeResponse
username	client/clicreds.hpp	/^    std::string username;$/;"	m	class:openvpn::ClientCreds
username	transport/client/httpcli.hpp	/^      std::string username;$/;"	m	class:openvpn::HTTPProxyTransport::Options
username_defined	client/clicreds.hpp	/^    bool username_defined() const$/;"	f	class:openvpn::ClientCreds
utf16	win/unicode.hpp	/^    inline wchar_t* utf16(const std::string& str)$/;"	f	namespace:openvpn::Win
utf16_strlen	win/unicode.hpp	/^    inline size_t utf16_strlen(const wchar_t *str)$/;"	f	namespace:openvpn::Win
utf8_index	common/unicode.hpp	/^    inline int utf8_index(STRING& str, size_t& index)$/;"	f	namespace:openvpn::Unicode
utf8_length	common/unicode.hpp	/^    inline size_t utf8_length(const STRING& str)$/;"	f	namespace:openvpn::Unicode
utf8_printable	common/unicode.hpp	/^    inline STRING utf8_printable(const STRING& str, size_t max_len_flags)$/;"	f	namespace:openvpn::Unicode
utf8_truncate	common/unicode.hpp	/^    inline void utf8_truncate(STRING& str, size_t max_len)$/;"	f	namespace:openvpn::Unicode
utun_open	tun/mac/utun.hpp	/^      inline int utun_open(std::string& name)$/;"	f	namespace:openvpn::TunMac::UTun
utun_open	tun/mac/utun.hpp	/^      inline int utun_open(std::string& name, const int unit)$/;"	f	namespace:openvpn::TunMac::UTun
v2_pull	compress/compress.hpp	/^    int v2_pull(Buffer& buf)$/;"	f	class:openvpn::Compress
v2_push	compress/compress.hpp	/^    void v2_push(Buffer& buf, int value)$/;"	f	class:openvpn::Compress
v4	addr/ip.hpp	/^	IPv4::Addr v4;$/;"	m	union:openvpn::IP::Addr::__anon2
v4	client/ipverflags.hpp	/^    bool v4() const$/;"	f	class:openvpn::IPVerFlags
v4	tun/mac/macgw.hpp	/^    Variant v4;$/;"	m	struct:openvpn::MacGWInfo
v4_from_byte_string	addr/ipv6.hpp	/^      static std::uint32_t v4_from_byte_string(const unsigned char *bytestr)$/;"	f	class:openvpn::IPv6::Addr
v4_regex	addr/regex.hpp	/^    inline std::string v4_regex()$/;"	f	namespace:openvpn::IP
v4_to_byte_string	addr/ipv6.hpp	/^      static void v4_to_byte_string(unsigned char *bytestr,$/;"	f	class:openvpn::IPv6::Addr
v6	addr/ip.hpp	/^	IPv6::Addr v6;$/;"	m	union:openvpn::IP::Addr::__anon2
v6	client/ipverflags.hpp	/^    bool v6() const$/;"	f	class:openvpn::IPVerFlags
v6	tun/mac/macgw.hpp	/^    Variant v6;$/;"	m	struct:openvpn::MacGWInfo
v6_regex	addr/regex.hpp	/^    inline std::string v6_regex()$/;"	f	namespace:openvpn::IP
val	common/getopt.hpp	/^    int val;$/;"	m	struct:openvpn::option
valid	common/unicode.hpp	/^	bool valid;$/;"	m	struct:openvpn::Unicode::UTF8Iterator::Char
validate	addr/ip.hpp	/^      static std::string validate(const std::string& ipstr, const char *title = nullptr, Version required_version = UNSPEC)$/;"	f	class:openvpn::IP::Addr
validate	addr/ip.hpp	/^      static std::string validate(const std::string& ipstr, const std::string& title, Version required_version = UNSPEC)$/;"	f	class:openvpn::IP::Addr
validate	common/options.hpp	/^    static validate_status validate(const std::string& str, const size_t max_len)$/;"	f	class:openvpn::Option
validate	http/urlparse.hpp	/^      void validate() const$/;"	f	class:openvpn::URL::Parse
validate	ssl/proto.hpp	/^      bool validate(const Buffer& net_buf)$/;"	f	class:openvpn::ProtoContext::TLSAuthPreValidate
validate	ssl/proto.hpp	/^      static bool validate(const Buffer& net_buf, ProtoContext& proto, TimePtr now)$/;"	f	class:openvpn::ProtoContext::KeyContext
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::DNSServer
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::ProxyAutoConfigURL
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::ProxyBypass
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::ProxyHostPort
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::RemoteAddress
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::RerouteGW
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::Route
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::RouteAddress
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::SearchDomain
validate	tun/builder/capture.hpp	/^      void validate(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture::WINSServer
validate	tun/builder/capture.hpp	/^    void validate() const$/;"	f	class:openvpn::TunBuilderCapture
validate_	tun/builder/capture.hpp	/^      void validate_(const std::string& title, const bool require_canonical) const$/;"	f	class:openvpn::TunBuilderCapture::RouteBase
validate_arg	common/options.hpp	/^    void validate_arg(const size_t index, const size_t max_len) const$/;"	f	class:openvpn::Option
validate_auth_cred	auth/validatecreds.hpp	/^  inline bool validate_auth_cred(const STRING& cred)$/;"	f	namespace:openvpn
validate_cert	openssl/ssl/sslctx.hpp	/^      virtual std::string validate_cert(const std::string& cert_txt) const$/;"	f	class:openvpn::OpenSSLContext::Config
validate_cert	polarssl/ssl/sslctx.hpp	/^      virtual std::string validate_cert(const std::string& cert_txt) const$/;"	f	class:openvpn::PolarSSLContext::Config
validate_cert_list	openssl/ssl/sslctx.hpp	/^      virtual std::string validate_cert_list(const std::string& certs_txt) const$/;"	f	class:openvpn::OpenSSLContext::Config
validate_cert_list	polarssl/ssl/sslctx.hpp	/^      virtual std::string validate_cert_list(const std::string& certs_txt) const$/;"	f	class:openvpn::PolarSSLContext::Config
validate_complete	ssl/proto.hpp	/^      void validate_complete() const$/;"	f	class:openvpn::ProtoContext::Config
validate_crl	openssl/ssl/sslctx.hpp	/^      virtual std::string validate_crl(const std::string& crl_txt) const$/;"	f	class:openvpn::OpenSSLContext::Config
validate_crl	polarssl/ssl/sslctx.hpp	/^      virtual std::string validate_crl(const std::string& crl_txt) const$/;"	f	class:openvpn::PolarSSLContext::Config
validate_dh	openssl/ssl/sslctx.hpp	/^      virtual std::string validate_dh(const std::string& dh_txt) const$/;"	f	class:openvpn::OpenSSLContext::Config
validate_dh	polarssl/ssl/sslctx.hpp	/^      virtual std::string validate_dh(const std::string& dh_txt) const$/;"	f	class:openvpn::PolarSSLContext::Config
validate_directive	common/options.hpp	/^      void validate_directive(const Option& opt)$/;"	f	class:openvpn::OptionList::Limits
validate_dynamic	auth/cr.hpp	/^    static void validate_dynamic(const std::string& cookie)$/;"	f	class:openvpn::ChallengeResponse
validate_host	common/hostport.hpp	/^    inline void validate_host(const std::string& host, const std::string& title)$/;"	f	namespace:openvpn::HostPort
validate_initial_packet	server/servproto.hpp	/^      virtual bool validate_initial_packet(const Buffer& net_buf)$/;"	f	class:openvpn::ServerProto::Factory
validate_layer	tun/builder/capture.hpp	/^    void validate_layer(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture
validate_list	tun/builder/capture.hpp	/^    static void validate_list(const LIST& list, const std::string& title)$/;"	f	class:openvpn::TunBuilderCapture
validate_mtu	tun/builder/capture.hpp	/^    void validate_mtu(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture
validate_netmask	addr/ip.hpp	/^      void validate_netmask()$/;"	f	class:openvpn::IP::Addr
validate_port	common/hostport.hpp	/^    inline void validate_port(const std::string& port, const std::string& title, unsigned int *value = nullptr)$/;"	f	namespace:openvpn::HostPort
validate_port	common/hostport.hpp	/^    inline void validate_port(const unsigned int port, const std::string& title)$/;"	f	namespace:openvpn::HostPort
validate_private_key	openssl/ssl/sslctx.hpp	/^      virtual std::string validate_private_key(const std::string& key_txt) const$/;"	f	class:openvpn::OpenSSLContext::Config
validate_private_key	polarssl/ssl/sslctx.hpp	/^      virtual std::string validate_private_key(const std::string& key_txt) const$/;"	f	class:openvpn::PolarSSLContext::Config
validate_size	transport/pktstream.hpp	/^    static void validate_size(const size_t size, const Frame::Context& frame_context)$/;"	f	class:openvpn::PacketStream
validate_status	common/options.hpp	/^    enum validate_status {$/;"	g	class:openvpn::Option
validate_status_description	common/options.hpp	/^    static const char *validate_status_description(const validate_status status)$/;"	f	class:openvpn::Option
validate_string	common/options.hpp	/^    static void validate_string(const std::string& name, const std::string& str, const size_t max_len)$/;"	f	class:openvpn::Option
validate_tunnel_address_indices	tun/builder/capture.hpp	/^    void validate_tunnel_address_indices(const std::string& title) const$/;"	f	class:openvpn::TunBuilderCapture
validate_tunnel_index	tun/builder/capture.hpp	/^    bool validate_tunnel_index(const int index) const$/;"	f	class:openvpn::TunBuilderCapture
validate_version	addr/ip.hpp	/^      void validate_version(const char *title, Version required_version) const$/;"	f	class:openvpn::IP::Addr
validate_version	addr/ip.hpp	/^      void validate_version(const std::string& title, Version required_version) const$/;"	f	class:openvpn::IP::Addr
value	common/hash.hpp	/^    inline std::size_t value(Args... args)$/;"	f	namespace:openvpn::Hash
value	common/options.hpp	/^      std::string value;$/;"	m	class:openvpn::OptionList::KeyValue
value	common/process.hpp	/^    std::string value(const size_t idx) const$/;"	f	class:openvpn::Environ
value	http/header.hpp	/^      std::string value;$/;"	m	struct:openvpn::HTTP::Header
value	http/urlparm.hpp	/^      std::string value;$/;"	m	struct:openvpn::URL::Parm
value	pki/x509track.hpp	/^      std::string value;$/;"	m	struct:openvpn::X509Track::KeyValue
value	ssl/peerinfo.hpp	/^      std::string value;$/;"	m	struct:openvpn::PeerInfo::KeyValue
value	tun/layer.hpp	/^    int value() const$/;"	f	class:openvpn::Layer
value_type	buffer/asiobuf.hpp	/^    typedef asio::const_buffer value_type;$/;"	t	class:openvpn::AsioConstBufferSeq2
ver	addr/ip.hpp	/^      Version ver;$/;"	m	class:openvpn::IP::Addr
ver	apple/ver.hpp	/^    int ver[3];$/;"	m	class:openvpn::AppleVersion
ver	tun/mac/macdns.hpp	/^    Mac::Version ver;$/;"	m	class:openvpn::MacDNS
ver_len	ip/ip.hpp	/^    static std::uint8_t ver_len(const unsigned int version,$/;"	f	struct:openvpn::IPHeader
verbose	log/sessionstats.hpp	/^    bool verbose() const { return verbose_; }$/;"	f	class:openvpn::SessionStats
verbose_	log/sessionstats.hpp	/^    bool verbose_;$/;"	m	class:openvpn::SessionStats
verify	openssl/sign/verify.hpp	/^    inline void verify(const OpenSSLPKI::X509Base& cert,$/;"	f	namespace:openvpn::OpenSSLSign
verify_callback_client	openssl/ssl/sslctx.hpp	/^    static int verify_callback_client(int preverify_ok, X509_STORE_CTX *ctx)$/;"	f	class:openvpn::OpenSSLContext
verify_callback_client	polarssl/ssl/sslctx.hpp	/^    static int verify_callback_client(void *arg, x509_crt *cert, int depth, int *flags)$/;"	f	class:openvpn::PolarSSLContext
verify_callback_server	openssl/ssl/sslctx.hpp	/^    static int verify_callback_server(int preverify_ok, X509_STORE_CTX *ctx)$/;"	f	class:openvpn::OpenSSLContext
verify_callback_server	polarssl/ssl/sslctx.hpp	/^    static int verify_callback_server(void *arg, x509_crt *cert, int depth, int *flags)$/;"	f	class:openvpn::PolarSSLContext
verify_canonical	addr/route.hpp	/^      void verify_canonical() const$/;"	f	struct:openvpn::IP::RouteTypeList
verify_dest_psid	ssl/proto.hpp	/^      bool verify_dest_psid(Buffer& buf)$/;"	f	class:openvpn::ProtoContext::KeyContext
verify_initialized	ssl/tlsprf.hpp	/^    void verify_initialized() const$/;"	f	class:openvpn::TLSPRF
verify_ns_cert_type	openssl/ssl/sslctx.hpp	/^    bool verify_ns_cert_type(const ::X509* cert) const$/;"	f	class:openvpn::OpenSSLContext
verify_ns_cert_type	polarssl/ssl/sslctx.hpp	/^    bool verify_ns_cert_type(const x509_crt *cert) const$/;"	f	class:openvpn::PolarSSLContext
verify_packet_id	crypto/crypto_aead.hpp	/^	bool verify_packet_id(PacketIDReceive& pid_recv, const PacketID::time_t now)$/;"	f	class:openvpn::AEAD::Crypto::Nonce
verify_packet_id	crypto/decrypt_chm.hpp	/^    bool verify_packet_id(BufferAllocated& buf, const PacketID::time_t now)$/;"	f	class:openvpn::DecryptCHM
verify_pkcs7	openssl/sign/pkcs7verify.hpp	/^    inline void verify_pkcs7(const OpenSSLPKI::X509Base& cert,$/;"	f	namespace:openvpn::OpenSSLSign
verify_src_psid	ssl/proto.hpp	/^      bool verify_src_psid(const ProtoSessionID& src_psid)$/;"	f	class:openvpn::ProtoContext::KeyContext
verify_version_consistency	addr/ip.hpp	/^      void verify_version_consistency(const Addr& other) const$/;"	f	class:openvpn::IP::Addr
verify_x509_cert_eku	openssl/ssl/sslctx.hpp	/^    bool verify_x509_cert_eku(::X509 *cert) const$/;"	f	class:openvpn::OpenSSLContext
verify_x509_cert_eku	polarssl/ssl/sslctx.hpp	/^    bool verify_x509_cert_eku(x509_crt *cert)$/;"	f	class:openvpn::PolarSSLContext
verify_x509_cert_ku	openssl/ssl/sslctx.hpp	/^    bool verify_x509_cert_ku(::X509 *cert) const$/;"	f	class:openvpn::OpenSSLContext
verify_x509_cert_ku	polarssl/ssl/sslctx.hpp	/^    bool verify_x509_cert_ku(const x509_crt *cert)$/;"	f	class:openvpn::PolarSSLContext
version	addr/addrpair.hpp	/^      Addr::Version version() const$/;"	f	struct:openvpn::IP::AddrMaskPair
version	addr/ip.hpp	/^      Version version() const { return ver; }$/;"	f	class:openvpn::IP::Addr
version	addr/route.hpp	/^      IP::Addr::Version version() const$/;"	f	struct:openvpn::IP::RouteType
version	ip/ip.hpp	/^    static unsigned int version(const std::uint8_t version_len)$/;"	f	struct:openvpn::IPHeader
version_len	ip/ip.hpp	/^    std::uint8_t    version_len;$/;"	m	struct:openvpn::IPHeader
version_mask	addr/ip.hpp	/^      VersionMask version_mask() const$/;"	f	class:openvpn::IP::Addr
version_mask	addr/ip.hpp	/^      static VersionMask version_mask(const Version ver)$/;"	f	class:openvpn::IP::Addr
version_mask	addr/route.hpp	/^      IP::Addr::VersionMask version_mask() const$/;"	f	struct:openvpn::IP::RouteType
version_mask	addr/route.hpp	/^      IP::Addr::VersionMask version_mask() const$/;"	f	struct:openvpn::IP::RouteTypeList
version_size	addr/ip.hpp	/^      static unsigned int version_size(Version v)$/;"	f	class:openvpn::IP::Addr
version_string	addr/ip.hpp	/^      const char *version_string() const$/;"	f	class:openvpn::IP::Addr
version_string_static	addr/ip.hpp	/^      static const char *version_string_static(Version ver)$/;"	f	class:openvpn::IP::Addr
vpn	tun/win/tunutil.hpp	/^	IPNetmask4 vpn;$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
vpn_gw4	client/clievent.hpp	/^      std::string vpn_gw4;$/;"	m	struct:openvpn::ClientEvent::Connected
vpn_gw4	tun/client/tunbase.hpp	/^    virtual std::string vpn_gw4() const { return std::string(); } \/\/ VPN gateways$/;"	f	struct:openvpn::TunClient
vpn_gw6	client/clievent.hpp	/^      std::string vpn_gw6;$/;"	m	struct:openvpn::ClientEvent::Connected
vpn_gw6	tun/client/tunbase.hpp	/^    virtual std::string vpn_gw6() const { return std::string(); }$/;"	f	struct:openvpn::TunClient
vpn_ip	tun/builder/capture.hpp	/^    const RouteAddress* vpn_ip(const IP::Addr::Version v) const$/;"	f	class:openvpn::TunBuilderCapture
vpn_ip4	client/clievent.hpp	/^      std::string vpn_ip4;$/;"	m	struct:openvpn::ClientEvent::Connected
vpn_ip4	tun/client/tunnull.hpp	/^      virtual std::string vpn_ip4() const$/;"	f	class:openvpn::TunNull::Client
vpn_ip4	tun/linux/client/tuncli.hpp	/^      virtual std::string vpn_ip4() const$/;"	f	class:openvpn::TunLinux::Client
vpn_ip4_addr	tun/client/tunprop.hpp	/^      IP::Addr vpn_ip4_addr;$/;"	m	struct:openvpn::TunProp::State
vpn_ip4_gw	tun/client/tunprop.hpp	/^      IP::Addr vpn_ip4_gw;$/;"	m	struct:openvpn::TunProp::State
vpn_ip6	client/clievent.hpp	/^      std::string vpn_ip6;$/;"	m	struct:openvpn::ClientEvent::Connected
vpn_ip6	tun/client/tunnull.hpp	/^      virtual std::string vpn_ip6() const$/;"	f	class:openvpn::TunNull::Client
vpn_ip6	tun/linux/client/tuncli.hpp	/^      virtual std::string vpn_ip6() const$/;"	f	class:openvpn::TunLinux::Client
vpn_ip6_addr	tun/client/tunprop.hpp	/^      IP::Addr vpn_ip6_addr;$/;"	m	struct:openvpn::TunProp::State
vpn_ip6_gw	tun/client/tunprop.hpp	/^      IP::Addr vpn_ip6_gw;$/;"	m	struct:openvpn::TunProp::State
vpn_ipv4	tun/builder/capture.hpp	/^    const RouteAddress* vpn_ipv4() const$/;"	f	class:openvpn::TunBuilderCapture
vpn_ipv6	tun/builder/capture.hpp	/^    const RouteAddress* vpn_ipv6() const$/;"	f	class:openvpn::TunBuilderCapture
vstatus	applecrypto/util/reachable.hpp	/^    virtual Status vstatus(const SCNetworkReachabilityFlags flags) const$/;"	f	class:openvpn::ReachabilityViaInternet
vstatus	applecrypto/util/reachable.hpp	/^    virtual Status vstatus(const SCNetworkReachabilityFlags flags) const$/;"	f	class:openvpn::ReachabilityViaWiFi
vtype	applecrypto/util/reachable.hpp	/^    virtual Type vtype() const$/;"	f	class:openvpn::ReachabilityViaInternet
vtype	applecrypto/util/reachable.hpp	/^    virtual Type vtype() const$/;"	f	class:openvpn::ReachabilityViaWiFi
wait	common/pthreadcond.hpp	/^    int wait(const unsigned int seconds)$/;"	f	class:openvpn::PThreadBarrier
wfp	tun/win/wfp.hpp	/^      WFP::Ptr wfp;$/;"	m	class:openvpn::TunWin::WFPContext
wfp	tun/win/wfp.hpp	/^      WFPContext::Ptr wfp;$/;"	m	class:openvpn::TunWin::ActionWFP
what	applecrypto/cf/error.hpp	/^    virtual const char* what() const throw() { return errtxt.c_str(); }$/;"	f	class:openvpn::CFException
what	buffer/buffer.hpp	/^    virtual const char* what() const throw() {$/;"	f	class:openvpn::BufferException
what	common/exception.hpp	/^    virtual const char* what() const throw() { return err_.c_str(); }$/;"	f	class:openvpn::Exception
what	error/excode.hpp	/^    virtual const char* what() const throw() { return err_.c_str(); }$/;"	f	class:openvpn::ErrorCode
what	http/webexcept.hpp	/^      virtual const char* what() const throw() { return formatted.c_str(); }$/;"	f	class:openvpn::HTTP::WebException
what	openssl/util/error.hpp	/^    virtual const char* what() const throw() { return errtxt.c_str(); }$/;"	f	class:openvpn::OpenSSLException
what	polarssl/util/error.hpp	/^    virtual const char* what() const throw() { return errtxt.c_str(); }$/;"	f	class:openvpn::PolarSSLException
what_str	applecrypto/cf/error.hpp	/^    std::string what_str() const { return errtxt; }$/;"	f	class:openvpn::CFException
what_str	openssl/util/error.hpp	/^    std::string what_str() const { return errtxt; }$/;"	f	class:openvpn::OpenSSLException
what_str	polarssl/util/error.hpp	/^    std::string what_str() const { return errtxt; }$/;"	f	class:openvpn::PolarSSLException
wifi	applecrypto/util/reachable.hpp	/^    std::unique_ptr<ReachabilityViaWiFi> wifi;$/;"	m	class:openvpn::Reachability
wifi_callback_static	applecrypto/util/reachable.hpp	/^    static void wifi_callback_static(SCNetworkReachabilityRef target,$/;"	f	class:openvpn::ReachabilityTracker
will_modify	tun/mac/macdns.hpp	/^      void will_modify()$/;"	f	class:openvpn::MacDNS::DSDict
win_dev	common/path.hpp	/^    inline bool win_dev(const std::string& path, const bool fully_qualified)$/;"	f	namespace:openvpn::path
win_recalibrate	time/time.hpp	/^    static void win_recalibrate(const DWORD gtc)$/;"	f	class:openvpn::TimeType
win_time	time/time.hpp	/^    static uint64_t win_time()$/;"	f	class:openvpn::TimeType
window_	reliable/relrecv.hpp	/^    MessageWindow<Message, id_t> window_;$/;"	m	class:openvpn::ReliableRecvTemplate
window_	reliable/relsend.hpp	/^    MessageWindow<Message, id_t> window_;$/;"	m	class:openvpn::ReliableSendTemplate
windows_routing_table	tun/win/tunutil.hpp	/^      inline const MIB_IPFORWARDTABLE* windows_routing_table()$/;"	f	namespace:openvpn::TunWin::Util
windows_routing_table2	tun/win/tunutil.hpp	/^      inline const MIB_IPFORWARD_TABLE2* windows_routing_table2(ADDRESS_FAMILY af)$/;"	f	namespace:openvpn::TunWin::Util
wins	tun/win/tunutil.hpp	/^	std::vector<IPv4::Addr> wins;  \/\/ WINS (44)$/;"	m	class:openvpn::TunWin::Util::TAPDHCPMasquerade
wins_servers	tun/builder/capture.hpp	/^    std::vector<WINSServer> wins_servers;  \/\/ Windows WINS servers$/;"	m	class:openvpn::TunBuilderCapture
wipe	buffer/safestr.hpp	/^    void wipe()$/;"	f	class:openvpn::SafeString
wipe_password	auth/authcreds.hpp	/^      void wipe_password()$/;"	f	class:openvpn::AuthCreds
work	compress/lz4.hpp	/^    BufferAllocated work;$/;"	m	class:openvpn::CompressLZ4Base
work	compress/lzo.hpp	/^    BufferAllocated work;$/;"	m	class:openvpn::CompressLZO
work	compress/lzoasym.hpp	/^    BufferAllocated work;$/;"	m	class:openvpn::CompressLZOAsym
work	compress/snappy.hpp	/^    BufferAllocated work;$/;"	m	class:openvpn::CompressSnappy
work	crypto/crypto_aead.hpp	/^	BufferAllocated work;$/;"	m	struct:openvpn::AEAD::Crypto::Decrypt
work	crypto/crypto_aead.hpp	/^	BufferAllocated work;$/;"	m	struct:openvpn::AEAD::Crypto::Encrypt
work	crypto/decrypt_chm.hpp	/^    BufferAllocated work;$/;"	m	class:openvpn::DecryptCHM
work	crypto/encrypt_chm.hpp	/^    BufferAllocated work;$/;"	m	class:openvpn::EncryptCHM
work_available	client/remotelist.hpp	/^      bool work_available() const$/;"	f	class:openvpn::RemoteList::PreResolve
wrap_warning	crypto/packet_id.hpp	/^    bool wrap_warning() const$/;"	f	class:openvpn::PacketIDSend
write	buffer/buffer.hpp	/^    void write(const T* data, const size_t size)$/;"	f	class:openvpn::BufferType
write	common/persistfile.hpp	/^    void write(const Buffer& buf)$/;"	f	class:openvpn::PersistentFile
write	common/persistfile.hpp	/^    void write(const std::string& str)$/;"	f	class:openvpn::PersistentFile
write	common/persistfile.hpp	/^    void write(const void *buf, size_t count)$/;"	f	class:openvpn::PersistentFile
write	common/tempfile.hpp	/^    void write(const std::string& content)$/;"	f	class:openvpn::TempFile
write	crypto/packet_id.hpp	/^    void write(Buffer& buf, const int form, const bool prepend) const$/;"	f	struct:openvpn::PacketID
write	frame/memq_dgram.hpp	/^    void write(const unsigned char *data, size_t size)$/;"	f	class:openvpn::MemQDgram
write	frame/memq_stream.hpp	/^    void write(const unsigned char *data, size_t size)$/;"	f	class:openvpn::MemQStream
write	ssl/psid.hpp	/^    void write(Buffer& buf) const$/;"	f	class:openvpn::ProtoSessionID
write	ssl/tlsprf.hpp	/^    void write(Buffer& buf)$/;"	f	class:openvpn::TLSPRF
write	tun/tunio.hpp	/^    bool write(Buffer& buf)$/;"	f	class:openvpn::TunIO
write_alloc	buffer/buffer.hpp	/^    T* write_alloc(const size_t size)$/;"	f	class:openvpn::BufferType
write_auth_string	ssl/proto.hpp	/^    static void write_auth_string(const S& str, Buffer& buf)$/;"	f	class:openvpn::ProtoContext
write_binary	common/file.hpp	/^  inline void write_binary(const std::string& filename, const Buffer& buf)$/;"	f	namespace:openvpn
write_binary_atomic	common/fileatomic.hpp	/^  inline void write_binary_atomic(const std::string& filename,$/;"	f	namespace:openvpn
write_binary_list	common/file.hpp	/^  inline void write_binary_list(const std::string& filename, const BUFLIST& buflist)$/;"	f	namespace:openvpn
write_buf	buffer/memq.hpp	/^    void write_buf(const BufferPtr& bp)$/;"	f	class:openvpn::MemQBase
write_ciphertext	applecrypto/ssl/sslctx.hpp	/^      virtual void write_ciphertext(const BufferPtr& buf)$/;"	f	class:openvpn::AppleSSLContext::SSL
write_ciphertext	openssl/ssl/sslctx.hpp	/^      virtual void write_ciphertext(const BufferPtr& buf)$/;"	f	class:openvpn::OpenSSLContext::SSL
write_ciphertext	polarssl/ssl/sslctx.hpp	/^      virtual void write_ciphertext(const BufferPtr& buf)$/;"	f	class:openvpn::PolarSSLContext::SSL
write_cleartext_unbuffered	applecrypto/ssl/sslctx.hpp	/^      virtual ssize_t write_cleartext_unbuffered(const void *data, const size_t size)$/;"	f	class:openvpn::AppleSSLContext::SSL
write_cleartext_unbuffered	openssl/ssl/sslctx.hpp	/^      virtual ssize_t write_cleartext_unbuffered(const void *data, const size_t size)$/;"	f	class:openvpn::OpenSSLContext::SSL
write_cleartext_unbuffered	polarssl/ssl/sslctx.hpp	/^      virtual ssize_t write_cleartext_unbuffered(const void *data, const size_t size)$/;"	f	class:openvpn::PolarSSLContext::SSL
write_control_string	ssl/proto.hpp	/^    static void write_control_string(const S& str, Buffer& buf)$/;"	f	class:openvpn::ProtoContext
write_control_string	ssl/proto.hpp	/^    void write_control_string(const S& str)$/;"	f	class:openvpn::ProtoContext
write_dhcp_addr_list	tun/win/tunutil.hpp	/^	static void write_dhcp_addr_list(Buffer& buf,$/;"	f	class:openvpn::TunWin::Util::TAPDHCPMasquerade
write_dhcp_str	tun/win/tunutil.hpp	/^	static void write_dhcp_str(Buffer& buf,$/;"	f	class:openvpn::TunWin::Util::TAPDHCPMasquerade
write_dhcp_u8	tun/win/tunutil.hpp	/^	static void write_dhcp_u8(Buffer& buf,$/;"	f	class:openvpn::TunWin::Util::TAPDHCPMasquerade
write_empty_string	ssl/proto.hpp	/^    static void write_empty_string(Buffer& buf)$/;"	f	class:openvpn::ProtoContext
write_next	crypto/packet_id.hpp	/^    void write_next(Buffer& buf, const bool prepend, const PacketID::time_t now)$/;"	f	class:openvpn::PacketIDSend
write_options	tun/win/tunutil.hpp	/^	void write_options(Buffer& buf) const$/;"	f	class:openvpn::TunWin::Util::TAPDHCPMasquerade
write_pid	common/daemon.hpp	/^  inline void write_pid(const std::string& fn)$/;"	f	namespace:openvpn
write_retry	common/write.hpp	/^  inline ssize_t write_retry(int fd, const void *buf, size_t count)$/;"	f	namespace:openvpn
write_seq	tun/tunio.hpp	/^    bool write_seq(const BUFSEQ& bs)$/;"	f	class:openvpn::TunIO
write_some	tun/persist/tunwrapasio.hpp	/^    std::size_t write_some(const ConstBufferSequence& buffers)$/;"	f	class:openvpn::TunWrapAsioStream
write_string	common/file.hpp	/^  inline void write_string(const std::string& filename, const std::string& str)$/;"	f	namespace:openvpn
write_string_length	ssl/proto.hpp	/^    static void write_string_length(const size_t size, Buffer& buf)$/;"	f	class:openvpn::ProtoContext
wstring	common/wstring.hpp	/^  namespace wstring {$/;"	n	namespace:openvpn
x509_	openssl/pki/x509.hpp	/^      ::X509 *x509_;$/;"	m	class:openvpn::OpenSSLPKI::X509Base
x509_cert_eku_defined	openssl/ssl/sslctx.hpp	/^    bool x509_cert_eku_defined() const$/;"	f	class:openvpn::OpenSSLContext
x509_cert_eku_defined	polarssl/ssl/sslctx.hpp	/^    bool x509_cert_eku_defined() const$/;"	f	class:openvpn::PolarSSLContext
x509_cert_ku_defined	openssl/ssl/sslctx.hpp	/^    bool x509_cert_ku_defined() const$/;"	f	class:openvpn::OpenSSLContext
x509_cert_ku_defined	polarssl/ssl/sslctx.hpp	/^    bool x509_cert_ku_defined() const$/;"	f	class:openvpn::PolarSSLContext
x509_get_common_name	polarssl/ssl/sslctx.hpp	/^    static std::string x509_get_common_name(const x509_crt *cert)$/;"	f	class:openvpn::PolarSSLContext
x509_get_field	openssl/ssl/sslctx.hpp	/^    static std::string x509_get_field(::X509 *cert, const int nid)$/;"	f	class:openvpn::OpenSSLContext
x509_get_serial	openssl/ssl/sslctx.hpp	/^    static std::string x509_get_serial(::X509 *cert)$/;"	f	class:openvpn::OpenSSLContext
x509_get_serial_hex	openssl/ssl/sslctx.hpp	/^    static std::string x509_get_serial_hex(::X509 *cert)$/;"	f	class:openvpn::OpenSSLContext
x509_get_subject	openssl/ssl/sslctx.hpp	/^    static std::string x509_get_subject(::X509 *cert)$/;"	f	class:openvpn::OpenSSLContext
x509_get_subject	polarssl/ssl/sslctx.hpp	/^    static std::string x509_get_subject(const x509_crt *cert)$/;"	f	class:openvpn::PolarSSLContext
x509_store_	openssl/pki/x509store.hpp	/^      X509_STORE* x509_store_;$/;"	m	class:openvpn::OpenSSLPKI::X509Store
x509_track	auth/authcert.hpp	/^      std::unique_ptr<X509Track::Set> x509_track;$/;"	m	struct:openvpn::AuthCert
x509_track_config	openssl/ssl/sslctx.hpp	/^      X509Track::ConfigSet x509_track_config;$/;"	m	class:openvpn::OpenSSLContext::Config
x509_track_config	polarssl/ssl/sslctx.hpp	/^      X509Track::ConfigSet x509_track_config;$/;"	m	class:openvpn::PolarSSLContext::Config
x509_track_extract_from_cert	openssl/ssl/sslctx.hpp	/^    static void x509_track_extract_from_cert(::X509 *cert,$/;"	f	class:openvpn::OpenSSLContext
x509_track_extract_nid	openssl/ssl/sslctx.hpp	/^    static void x509_track_extract_nid(const X509Track::Type xt_type,$/;"	f	class:openvpn::OpenSSLContext
x509_track_get	auth/authcert.hpp	/^      const X509Track::Set* x509_track_get() const$/;"	f	struct:openvpn::AuthCert
x509_track_take_ownership	auth/authcert.hpp	/^      std::unique_ptr<X509Track::Set> x509_track_take_ownership()$/;"	f	struct:openvpn::AuthCert
xid	ip/dhcp.hpp	/^    std::uint32_t xid;        \/* transaction ID, chosen by client *\/$/;"	m	struct:openvpn::DHCP
xmit_acks	ssl/protostack.hpp	/^    ReliableAck xmit_acks;$/;"	m	class:openvpn::ProtoStackBase
xmit_creds	ssl/proto.hpp	/^      bool xmit_creds = true;$/;"	m	class:openvpn::ProtoContext::Config
xsputn	buffer/bufstream.hpp	/^    virtual std::streamsize xsputn(const char* s, std::streamsize n)$/;"	f	class:openvpn::BufferStream
yiaddr	ip/dhcp.hpp	/^    std::uint32_t yiaddr;     \/* 'your' IP address -- server's response to client *\/$/;"	m	struct:openvpn::DHCP
zero	addr/ipv4.hpp	/^      void zero()$/;"	f	class:openvpn::IPv4::Addr
zero	addr/ipv6.hpp	/^      void zero()$/;"	f	class:openvpn::IPv6::Addr
zero	time/time.hpp	/^    static TimeType zero() { return TimeType(T(0)); }$/;"	f	class:openvpn::TimeType
zero_complement	addr/ipv4.hpp	/^      void zero_complement()$/;"	f	class:openvpn::IPv4::Addr
zero_complement	addr/ipv6.hpp	/^      void zero_complement()$/;"	f	class:openvpn::IPv6::Addr
~Action	common/action.hpp	/^    virtual ~Action() {}$/;"	f	struct:openvpn::Action
~ActionThread	common/actionthread.hpp	/^    virtual ~ActionThread()$/;"	f	class:openvpn::ActionThread
~ArgvWrapper	common/argv.hpp	/^    ~ArgvWrapper()$/;"	f	class:openvpn::ArgvWrapper
~AutoReset	common/autoreset.hpp	/^    ~AutoReset()$/;"	f	class:openvpn::AutoReset
~BufferAllocatedType	buffer/buffer.hpp	/^    ~BufferAllocatedType()$/;"	f	class:openvpn::BufferAllocatedType
~BufferException	buffer/buffer.hpp	/^    virtual ~BufferException() throw() {}$/;"	f	class:openvpn::BufferException
~BufferStreamOut	buffer/bufstream.hpp	/^    ~BufferStreamOut()$/;"	f	class:openvpn::BufferStreamOut
~CFException	applecrypto/cf/error.hpp	/^    virtual ~CFException() throw() {}$/;"	f	class:openvpn::CFException
~CRL	openssl/pki/crl.hpp	/^      ~CRL()$/;"	f	class:openvpn::OpenSSLPKI::CRL
~CipherContext	applecrypto/crypto/cipher.hpp	/^      ~CipherContext() { erase() ; }$/;"	f	class:openvpn::AppleCrypto::CipherContext
~CipherContext	openssl/crypto/cipher.hpp	/^      ~CipherContext() { erase() ; }$/;"	f	class:openvpn::OpenSSLCrypto::CipherContext
~CipherContext	polarssl/crypto/cipher.hpp	/^      ~CipherContext() { erase() ; }$/;"	f	class:openvpn::PolarSSLCrypto::CipherContext
~CipherContextGCM	openssl/crypto/ciphergcm.hpp	/^      ~CipherContextGCM() { erase() ; }$/;"	f	class:openvpn::OpenSSLCrypto::CipherContextGCM
~CipherContextGCM	polarssl/crypto/ciphergcm.hpp	/^      ~CipherContextGCM() { erase() ; }$/;"	f	class:openvpn::PolarSSLCrypto::CipherContextGCM
~CleanupType	common/cleanup.hpp	/^    ~CleanupType()$/;"	f	class:openvpn::CleanupType
~Client	transport/client/httpcli.hpp	/^      virtual ~Client() { stop_(); }$/;"	f	class:openvpn::HTTPProxyTransport::Client
~Client	transport/client/tcpcli.hpp	/^      virtual ~Client() { stop_(); }$/;"	f	class:openvpn::TCPTransport::Client
~Client	transport/client/udpcli.hpp	/^      virtual ~Client() { stop_(); }$/;"	f	class:openvpn::UDPTransport::Client
~Client	tun/builder/client.hpp	/^      virtual ~Client() { stop_(); }$/;"	f	class:openvpn::TunBuilderClient::Client
~Client	tun/linux/client/tuncli.hpp	/^      virtual ~Client() { stop_(); }$/;"	f	class:openvpn::TunLinux::Client
~Client	tun/mac/client/tuncli.hpp	/^      virtual ~Client() { stop_(); }$/;"	f	class:openvpn::TunMac::Client
~Client	tun/win/client/tuncli.hpp	/^      virtual ~Client() { stop_(); }$/;"	f	class:openvpn::TunWin::Client
~ClientConnect	client/cliconnect.hpp	/^    ~ClientConnect()$/;"	f	class:openvpn::ClientConnect
~Config	tun/builder/setup.hpp	/^      virtual ~Config() {}$/;"	f	struct:openvpn::TunBuilderSetup::Config
~Context	log/logthread.hpp	/^      ~Context()$/;"	f	struct:openvpn::Log::Context
~DH	openssl/pki/dh.hpp	/^      ~DH()$/;"	f	class:openvpn::OpenSSLPKI::DH
~DH	polarssl/pki/dh.hpp	/^      ~DH()$/;"	f	class:openvpn::PolarSSLPKI::DH
~DestructorBase	common/destruct.hpp	/^    virtual ~DestructorBase() {}$/;"	f	struct:openvpn::DestructorBase
~DigestContext	openssl/crypto/digest.hpp	/^      ~DigestContext() { erase() ; }$/;"	f	class:openvpn::OpenSSLCrypto::DigestContext
~DigestContext	polarssl/crypto/digest.hpp	/^      ~DigestContext() { erase() ; }$/;"	f	class:openvpn::PolarSSLCrypto::DigestContext
~ErrorCode	error/excode.hpp	/^    virtual ~ErrorCode() throw() {}$/;"	f	class:openvpn::ErrorCode
~EventBase	transport/gremlin.hpp	/^	virtual ~EventBase() {}$/;"	f	struct:openvpn::Gremlin::DelayedQueue::EventBase
~Exception	common/exception.hpp	/^    virtual ~Exception() throw() {}$/;"	f	class:openvpn::Exception
~ExceptionCode	error/excode.hpp	/^    virtual ~ExceptionCode() throw() {}$/;"	f	class:openvpn::ExceptionCode
~ExternalPKIBase	pki/epkibase.hpp	/^    virtual ~ExternalPKIBase() {}$/;"	f	class:openvpn::ExternalPKIBase
~Function	common/function.hpp	/^    ~Function()$/;"	f	class:openvpn::Function
~Glob	common/glob.hpp	/^    ~Glob()$/;"	f	class:openvpn::Glob
~HMACContext	applecrypto/crypto/hmac.hpp	/^      ~HMACContext()$/;"	f	class:openvpn::AppleCrypto::HMACContext
~HMACContext	openssl/crypto/hmac.hpp	/^      ~HMACContext() { erase() ; }$/;"	f	class:openvpn::OpenSSLCrypto::HMACContext
~HMACContext	polarssl/crypto/hmac.hpp	/^      ~HMACContext() { erase() ; }$/;"	f	class:openvpn::PolarSSLCrypto::HMACContext
~IP46AutoRelease	server/vpnservpool.hpp	/^      ~IP46AutoRelease()$/;"	f	class:openvpn::VPNServerPool::IP46AutoRelease
~Init	init/initprocess.hpp	/^      ~Init()$/;"	f	class:openvpn::InitProcess::Init
~Input	win/console.hpp	/^	~Input()$/;"	f	class:openvpn::Win::Console::Input
~Link	transport/tcplink.hpp	/^      ~Link() { stop(); }$/;"	f	class:openvpn::TCPTransport::Link
~Link	transport/udplink.hpp	/^      ~Link() { stop(); }$/;"	f	class:openvpn::UDPTransport::Link
~MacDNSWatchdog	tun/mac/macdns_watchdog.hpp	/^    virtual ~MacDNSWatchdog()$/;"	f	class:openvpn::MacDNSWatchdog
~MacLifeCycle	apple/maclife.hpp	/^    virtual ~MacLifeCycle()$/;"	f	class:openvpn::MacLifeCycle
~MacSleep	apple/macsleep.hpp	/^    virtual ~MacSleep()$/;"	f	class:openvpn::MacSleep
~NotifyBase	common/rc.hpp	/^      virtual ~NotifyBase() {}$/;"	f	class:openvpn::RCWeak::NotifyBase
~OpenSSLContext	openssl/ssl/sslctx.hpp	/^    ~OpenSSLContext()$/;"	f	class:openvpn::OpenSSLContext
~OpenSSLException	openssl/util/error.hpp	/^    virtual ~OpenSSLException() throw() {}$/;"	f	class:openvpn::OpenSSLException
~PKContext	polarssl/pki/pkctx.hpp	/^      ~PKContext()$/;"	f	class:openvpn::PolarSSLPKI::PKContext
~PKey	openssl/pki/pkey.hpp	/^      ~PKey()$/;"	f	class:openvpn::OpenSSLPKI::PKey
~PolarSSLContext	polarssl/ssl/sslctx.hpp	/^    ~PolarSSLContext()$/;"	f	class:openvpn::PolarSSLContext
~PolarSSLException	polarssl/util/error.hpp	/^    virtual ~PolarSSLException() throw() {}$/;"	f	class:openvpn::PolarSSLException
~ProtoContext	ssl/proto.hpp	/^    virtual ~ProtoContext() {}$/;"	f	class:openvpn::ProtoContext
~RC	common/rc.hpp	/^    virtual ~RC() {}$/;"	f	class:openvpn::RC
~RCCopyable	common/rc.hpp	/^    virtual ~RCCopyable() {}$/;"	f	class:openvpn::RCCopyable
~RCPtr	common/rc.hpp	/^    ~RCPtr()$/;"	f	class:openvpn::RCPtr
~RCWeak	common/rc.hpp	/^    virtual ~RCWeak()$/;"	f
~ReachabilityInterface	applecrypto/util/reach.hpp	/^    virtual ~ReachabilityInterface() {}$/;"	f	struct:openvpn::ReachabilityInterface
~ReachabilityTracker	applecrypto/util/reachable.hpp	/^    virtual ~ReachabilityTracker()$/;"	f	class:openvpn::ReachabilityTracker
~RedirectBase	common/redir.hpp	/^    virtual ~RedirectBase() {}$/;"	f	struct:openvpn::RedirectBase
~RegKey	win/reg.hpp	/^      ~RegKey()$/;"	f	class:openvpn::Win::RegKey
~RouteListLinux	netconf/linux/route.hpp	/^    virtual ~RouteListLinux()$/;"	f	class:openvpn::RouteListLinux
~SSL	applecrypto/ssl/sslctx.hpp	/^      ~SSL()$/;"	f	class:openvpn::AppleSSLContext::SSL
~SSL	openssl/ssl/sslctx.hpp	/^      ~SSL()$/;"	f	class:openvpn::OpenSSLContext::SSL
~SSL	polarssl/ssl/sslctx.hpp	/^      ~SSL()$/;"	f	class:openvpn::PolarSSLContext::SSL
~Scope	common/stop.hpp	/^      ~Scope()$/;"	f	class:openvpn::Stop::Scope
~ScopedAsioStream	common/scoped_asio_stream.hpp	/^    ~ScopedAsioStream()$/;"	f	class:openvpn::ScopedAsioStream
~ScopedFD	common/scoped_fd.hpp	/^    virtual ~ScopedFD()$/;"	f	class:openvpn::ScopedFD
~ScopedHANDLE	win/scoped_handle.hpp	/^      ~ScopedHANDLE()$/;"	f	class:openvpn::Win::ScopedHANDLE
~Session	client/cliproto.hpp	/^      virtual ~Session()$/;"	f	class:openvpn::ClientProto::Session
~Session	server/servproto.hpp	/^      virtual ~Session()$/;"	f	class:openvpn::ServerProto::Session
~Setup	tun/mac/client/tunsetup.hpp	/^      virtual ~Setup()$/;"	f	class:openvpn::TunMac::Setup
~Setup	tun/win/client/tunsetup.hpp	/^      virtual ~Setup()$/;"	f	class:openvpn::TunWin::Setup
~Signal	common/signal.hpp	/^    ~Signal()$/;"	f	class:openvpn::Signal
~SignalBlocker	common/signal.hpp	/^    ~SignalBlocker()$/;"	f	class:openvpn::SignalBlocker
~TLSPRF	ssl/tlsprf.hpp	/^    ~TLSPRF()$/;"	f	class:openvpn::TLSPRF
~TempFile	common/tempfile.hpp	/^    ~TempFile()$/;"	f	class:openvpn::TempFile
~ThreadContext	common/runcontext.hpp	/^      ~ThreadContext()$/;"	f	class:openvpn::RunContext::ThreadContext
~Title	win/console.hpp	/^	~Title()$/;"	f	class:openvpn::Win::Console::Title
~TokenEncrypt	openssl/util/tokenencrypt.hpp	/^    ~TokenEncrypt()$/;"	f	class:openvpn::TokenEncrypt
~Tun	tun/builder/client.hpp	/^      ~Tun() { Base::stop(); }$/;"	f	class:openvpn::TunBuilderClient::Tun
~Tun	tun/linux/tun.hpp	/^      ~Tun() { Base::stop(); }$/;"	f	class:openvpn::TunLinux::Tun
~TunBuilderBase	tun/builder/base.hpp	/^    virtual ~TunBuilderBase() {}$/;"	f	class:openvpn::TunBuilderBase
~TunIO	tun/tunio.hpp	/^    virtual ~TunIO()$/;"	f	class:openvpn::TunIO
~TunPersistTemplate	tun/persist/tunpersist.hpp	/^    virtual ~TunPersistTemplate()$/;"	f	class:openvpn::TunPersistTemplate
~TunWrapTemplate	tun/persist/tunwrap.hpp	/^    virtual ~TunWrapTemplate()$/;"	f	class:openvpn::TunWrapTemplate
~UMask	common/umask.hpp	/^    ~UMask()$/;"	f	class:openvpn::UMask
~UseCount	common/usecount.hpp	/^    ~UseCount()$/;"	f	class:openvpn::UseCount
~WFPEngine	tun/win/wfp.hpp	/^	~WFPEngine()$/;"	f	class:openvpn::TunWin::WFP::WFPEngine
~Wrap	applecrypto/cf/cf.hpp	/^      virtual ~Wrap()$/;"	f	class:openvpn::CF::Wrap
~X509	openssl/pki/x509.hpp	/^      ~X509()$/;"	f	class:openvpn::OpenSSLPKI::X509
~X509CRL	polarssl/pki/x509crl.hpp	/^      ~X509CRL()$/;"	f	class:openvpn::PolarSSLPKI::X509CRL
~X509Cert	polarssl/pki/x509cert.hpp	/^      ~X509Cert()$/;"	f	class:openvpn::PolarSSLPKI::X509Cert
~X509Store	openssl/pki/x509store.hpp	/^      ~X509Store()$/;"	f	class:openvpn::OpenSSLPKI::X509Store
